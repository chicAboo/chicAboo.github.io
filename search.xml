<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>flex-骰子布局</title>
      <link href="/2019/02/13/css/flex-%E9%AA%B0%E5%AD%90%E5%B8%83%E5%B1%80/"/>
      <url>/2019/02/13/css/flex-%E9%AA%B0%E5%AD%90%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>###目录：</p><ul><li><ol><li>概念</li></ol></li><li><ol start="2"><li>flex容器的属性<ul><li>2.1.  flex-direction</li><li>2.2.  flex-wrap</li><li>2.3.  flex-flow</li><li>2.4.  justify-content</li><li>2.5.  align-items</li><li>2.6.  align-content</li></ul></li></ol></li><li><ol start="3"><li>项目的属性<ul><li>3.1.  order</li><li>3.2. flex-grow</li><li>3.3. flex-shrink</li><li>3.4. flex-basis</li><li>3.5. flex</li><li>3.6. align-self</li></ul></li></ol></li><li><ol start="4"><li>flex布局实践（骰子布局）</li></ol></li><li><ol start="5"><li>总结</li></ol></li><li><ol start="6"><li>源码</li></ol></li></ul><hr><hr><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex布局称为flex容器，flex容器默认两根轴：水平主轴和垂直交叉轴。以下概念都围绕水平主轴和垂直交叉轴而定义。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-278ac8a5c9777d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex"></p><h3 id="二、flex容器的属性"><a href="#二、flex容器的属性" class="headerlink" title="二、flex容器的属性"></a>二、flex容器的属性</h3><p>以下6个属性设置在容器上。</p><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><p>######1. flex-direction 决定主轴的方向</p><blockquote><ul><li>row(默认值): 主轴水平方向，左端为起点</li><li>row-reverse: 主轴水平方向，右端为起点</li><li>column: 主轴垂直方向，上端为起点</li><li>column-reverse: 主轴垂直方向，下端为起点</li></ul></blockquote><p>######2. flex-wrap 项目是否排列在轴线上，是否换行属性</p><blockquote><ul><li>nowrap(默认值): 不换行</li><li>wrap: 换行，第一行在上方</li><li>wrap-reverse: 换行，第一行在下方</li></ul></blockquote><p>######3. flex-flow:<flex-direction> <flex-wrap> flex-direction和flex-wrap的简写</flex-wrap></flex-direction></p><p>######4. justify-content 定义主轴上的对其方式</p><blockquote><ul><li>flex-start(默认值): 左对齐</li><li>flex-end: 右对齐</li><li>center: 居中</li><li>space-between: 两端对其，项目间间距相等</li><li>space-around: 每个项目两端的间距相等</li></ul></blockquote><p> ######5. align-items 项目在交叉线上的对齐方式</p><blockquote><ul><li>flex-start: 交叉线的起点对齐</li><li>flex-end: 交叉线的终点对齐</li><li>center: 交叉线的中心对齐</li><li>baseline: 项目第一行文字的基线对齐</li><li>stretch(默认值): 如果项目未设置高度或auto,将占满容器的高度</li></ul></blockquote><h6 id="6-align-content-多行对其，如果只有一行，不起作用"><a href="#6-align-content-多行对其，如果只有一行，不起作用" class="headerlink" title="6. align-content 多行对其，如果只有一行，不起作用"></a>6. align-content 多行对其，如果只有一行，不起作用</h6><blockquote><p>flex-start: 与交叉点的起点对齐</p><ul><li>flex-end: 与交叉点的终点对齐</li><li>center: 与交叉点的中心对齐</li><li>space-between: 与交叉线两端对齐，轴线间间隔平均分配</li><li>space-around: 每根轴线间隔相等</li><li>stretch: 轴线占满整个交叉线</li></ul></blockquote><p>###三、项目的属性<br>以下6个属性设置在项目上。</p><blockquote><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></blockquote><h6 id="1-order定义项目的排列顺序，值越小越靠前，默认为0"><a href="#1-order定义项目的排列顺序，值越小越靠前，默认为0" class="headerlink" title="1. order定义项目的排列顺序，值越小越靠前，默认为0"></a>1. <code>order</code>定义项目的排列顺序，值越小越靠前，默认为0</h6><blockquote><p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;order: <integer>;<br>}</integer></p></blockquote><h6 id="2-flex-grow定义项目的放大比例，默认为0"><a href="#2-flex-grow定义项目的放大比例，默认为0" class="headerlink" title="2. flex-grow定义项目的放大比例，默认为0"></a>2. <code>flex-grow</code>定义项目的放大比例，默认为0</h6><blockquote><p>.item {<br> &nbsp;&nbsp;&nbsp;&nbsp; flex-grow: <number>;<br>}</number></p></blockquote><p>如果flex-grow为1，则项目等分，如果有一个为2，其他为1，则该项目是其他项目的两倍。</p><h6 id="3-flex-shrink定义项目的缩小比例，默认值为1。"><a href="#3-flex-shrink定义项目的缩小比例，默认值为1。" class="headerlink" title="3. flex-shrink定义项目的缩小比例，默认值为1。"></a>3. <code>flex-shrink</code>定义项目的缩小比例，默认值为1。</h6><blockquote><p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex-shrink: <number>;<br>}</number></p></blockquote><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效</p><h6 id="4-flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。"><a href="#4-flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。" class="headerlink" title="4. flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。"></a>4. <code>flex-basis</code>定义在分配空间之前，项目占主轴空间，默认值为auto。</h6><blockquote><p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex-basis: <length> | auto;<br>}</length></p></blockquote><p>它可以设为跟width或height属性一样的值（比如250px），则项目将占据固定空间。</p><h6 id="5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。"><a href="#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。" class="headerlink" title="5. flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。"></a>5. <code>flex</code>属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h6><blockquote><p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>}</p></blockquote><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。习惯使用这个属性。</p><h6 id="6-align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性-默认值为auto。"><a href="#6-align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性-默认值为auto。" class="headerlink" title="6. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。"></a>6. <code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。</h6><blockquote><p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>}</p></blockquote><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h3 id="四、flex布局实践（骰子布局）"><a href="#四、flex布局实践（骰子布局）" class="headerlink" title="四、flex布局实践（骰子布局）"></a>四、flex布局实践（骰子布局）</h3><p>假设骰子的一面最多可以放9个点。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-8f9d7b507cc4e469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sz.png"></p><p>下面来说如何使用flex布局骰子，html默认为</p><pre><code>&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>.box元素代表flex容器，.item元素代表一个项目，需要几个项目就有几个class为item的div元素。</p><h6 id="1-单项目"><a href="#1-单项目" class="headerlink" title="1. 单项目"></a>1. 单项目</h6><p>1.1 首先左上角一个点，默认情况即可。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-31aa052e71fa02d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s1.png"></p><pre><code>.box {    width: 60px;    height: 60px;    border: 1px solid white;    background: white;    border-radius: 5px;    display: flex;    margin: 10px;}</code></pre><p>.box的样式为以上，下面所有都依据这个来的。</p><p>1.2  黑点在第一行居中对齐，使用justify-content: center即可。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-594bad91c28f82b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s2.png"></p><pre><code>.box.one1 {    flex-direction: row;   /* 默认值可以不写*/    justify-content: center;}</code></pre><p>1.3  黑点在第一行右对齐，使用justify-content: flex-end。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-916a18b312d4e110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s3.png"></p><pre><code>.box.one2 {    justify-content: flex-end;}</code></pre><p>1.4 黑点在第二行第一个，转化为垂直交叉线排列方式，居中即可。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-7910eb9240525655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s4.png"></p><pre><code>.box.one3 {    align-items: center;}</code></pre><p>1.5 黑点垂直水平居中<br><img src="https://upload-images.jianshu.io/upload_images/12926544-2321c6bf813ccb7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s5.png"></p><pre><code>.box.one4 {    align-items: center;    justify-content: center;}</code></pre><p>1.6  黑点在第二行右侧<br><img src="https://upload-images.jianshu.io/upload_images/12926544-bdd3f037bb492287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s6.png"></p><pre><code>.box.one5 {    align-items: center;    justify-content: flex-end;}</code></pre><p>1.7 黑点在最后一行第一个<br><img src="https://upload-images.jianshu.io/upload_images/12926544-431e21b1d0a7be05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s7.png"></p><pre><code>.box.one6 {    align-items: flex-end;}</code></pre><p>1.8 黑点在最后一行居中<br><img src="https://upload-images.jianshu.io/upload_images/12926544-86b6c527e8f3a2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s8.png"></p><pre><code>.box.one7 {    align-items: flex-end;    justify-content: center;}</code></pre><p>1.9 黑点在最后一行最后一个<br><img src="https://upload-images.jianshu.io/upload_images/12926544-7da734d393ce6d06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s9.png"></p><pre><code>.box.one8 {    align-items: flex-end;    justify-content: flex-end;}</code></pre><h6 id="2-双项目"><a href="#2-双项目" class="headerlink" title="2. 双项目"></a>2. 双项目</h6><p>html模版为</p><pre><code>&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>2.1 第一行左右布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-5a8fbdcd6d59e6f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b1.png"></p><pre><code>.box.two1 {    justify-content: space-between;}</code></pre><p>2.2 左侧上下布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-5256f7af839acf53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b2.png"></p><pre><code>.box.two2 {      flex-direction: column;      justify-content: space-between;  }</code></pre><p>2.3 居中上下布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-e41d6015bcee5774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b3.png"></p><pre><code>.box.two3 {    flex-direction: column;    justify-content: space-between;    align-items: center;}</code></pre><p>2.4 右侧上下布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-4230e04e5d09f890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b4.png"></p><pre><code>.box.two4 {    flex-direction: column;    justify-content: space-between;    align-items: flex-end;}</code></pre><p>2.5 左上右下布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-e1291f7d2384be47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b5"></p><pre><code>.box.two3 {    justify-content: space-between;}.two3 .item:last-child {    align-self: flex-end;}</code></pre><h6 id="3-三项目"><a href="#3-三项目" class="headerlink" title="3. 三项目"></a>3. 三项目</h6><p>html模版</p><pre><code>&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>3.1 一左二中三右布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-41ba3b783523a526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="t1"></p><pre><code>.three1 {    flex-direction: column;}.three1 .item:nth-child(2) {    align-self: center;}.three1 .item:nth-child(3) {    align-self: flex-end;}</code></pre><p>3.2 一右二中三左布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-bcdc9c2be0c61691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="t2"></p><pre><code>.three2 {    flex-direction: column;    align-items: flex-end;}.three2 .item:nth-child(2) {    align-self: center;}.three2 .item:nth-child(3) {    align-self: flex-start;}</code></pre><h6 id="4-四项目"><a href="#4-四项目" class="headerlink" title="4. 四项目"></a>4. 四项目</h6><p>4.1 第一排铺满，最后一排右布局<br>模版：</p><pre><code>&lt;div class=&quot;box four1&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>图：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-f2f9b589ef356b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="f1"><br>样式：</p><pre><code>.four1 {    flex-wrap: wrap;    justify-content: flex-end;    align-content: space-between;}</code></pre><p>4.2 上下左右四个角布局<br>html模版:</p><pre><code>&lt;div class=&quot;box four2&quot;&gt;    &lt;div class=&quot;column&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;column&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>图：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-6aa53e9895823320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>样式：</p><pre><code>.four2 {    flex-direction: column;    justify-content: space-between;}.column {    display: flex;    justify-content: space-between;}</code></pre><h6 id="5-五项目"><a href="#5-五项目" class="headerlink" title="5. 五项目"></a>5. 五项目</h6><p>html模版：</p><pre><code>&lt;div class=&quot;box four2&quot;&gt;    &lt;div class=&quot;column&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;column mid&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;column&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>图：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-b97d167d2b849ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="five"></p><p>样式：</p><pre><code>.four2 {    flex-direction: column;    justify-content: space-between;}.column {    display: flex;    justify-content: space-between;}.mid {    align-items: center;    justify-content: center;}</code></pre><h6 id="6-六项目"><a href="#6-六项目" class="headerlink" title="6. 六项目"></a>6. 六项目</h6><p>html模版：</p><pre><code>&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>6.1 上三下三布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-b81e8009a757c6b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="six1"></p><pre><code>.s1 {    flex-wrap: wrap;    align-content: space-between;}</code></pre><p>6.2 左三右三布局<br><img src="https://upload-images.jianshu.io/upload_images/12926544-246153225ed1dae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="six2"></p><pre><code>.s2 {    flex-direction: column;    flex-wrap: wrap;    align-content: space-between;}</code></pre><h6 id="7-九项目"><a href="#7-九项目" class="headerlink" title="7 九项目"></a>7 九项目</h6><p>html模版：</p><pre><code>&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>图：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-ada77c604a43ad5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>样式：</p><pre><code>.n1 {    flex-wrap: wrap;}</code></pre><h6 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用flex布局很多情况下节省很多工作量，方便简单好用。特别手机端用的很多。</p><h6 id="六、完整代码没上传GitHub，这儿随便写了下符在下面。"><a href="#六、完整代码没上传GitHub，这儿随便写了下符在下面。" class="headerlink" title="六、完整代码没上传GitHub，这儿随便写了下符在下面。"></a>六、完整代码没上传GitHub，这儿随便写了下符在下面。</h6><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        body {            background: black;        }        .con {            margin: 50px;            display: flex;            flex-direction: row;        }        .box {            width: 60px;            height: 60px;            border: 1px solid white;            background: white;            border-radius: 5px;            display: flex;            margin: 10px;        }        .item {            width: 10px;            height: 10px;            background: black;            border-radius: 5px;            margin: 5px;        }        .box.one1 {            flex-direction: row;            justify-content: center;        }        .box.one2 {            flex-direction: row;            justify-content: flex-end;        }        .box.one3 {            flex-direction: row;            align-items: center;        }        .box.one4 {            flex-direction: row;            align-items: center;            justify-content: center;        }        .box.one5 {            align-items: center;            justify-content: flex-end;        }        .box.one6 {            align-items: flex-end;        }        .box.one7 {            align-items: flex-end;            justify-content: center;        }        .box.one8 {            align-items: flex-end;            justify-content: flex-end;        }        .box.two1 {            justify-content: space-between;        }        .box.two2 {            flex-direction: column;            justify-content: space-between;        }        .box.two21 {            flex-direction: column;            justify-content: space-between;            align-items: center;        }        .box.two22 {            flex-direction: column;            justify-content: space-between;            align-items: flex-end;        }        .box .item1 {            align-self: center;        }        .box.two3 {            justify-content: space-between;        }        .two3 .item:last-child {            align-self: flex-end;        }        .t1 {            flex-direction: column;        }        .t1 .item:nth-child(2) {            align-self: center;        }        .t1 .item:nth-child(3) {            align-self: flex-end;        }        .t2 {            flex-direction: column;            align-items: flex-end;        }        .t2 .item:nth-child(2) {            align-self: center;        }        .t2 .item:nth-child(3) {            align-self: flex-start;        }        .f1 {            flex-wrap: wrap;            justify-content: flex-end;            align-content: space-between;        }        .f2 {            flex-direction: column;            justify-content: space-between;        }        .column {            display: flex;            justify-content: space-between;        }        .mid {            align-items: center;            justify-content: center;        }        .s1 {            flex-wrap: wrap;            align-content: space-between;        }        .s2 {            flex-direction: column;            flex-wrap: wrap;            align-content: space-between;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 1 --&gt;    &lt;div class=&quot;con&quot;&gt;        &lt;div class=&quot;box&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one1&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one2&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one3&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one4&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one5&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one6&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one7&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;box one8&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;!-- 2 --&gt;&lt;div class=&quot;con&quot;&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box two1&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box two2&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box two21&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box two22&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item item1&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box two3&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 3 --&gt;&lt;div class=&quot;con&quot;&gt;    &lt;div class=&quot;box t1&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box t2&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 4、5 --&gt;&lt;div class=&quot;con&quot;&gt;    &lt;div class=&quot;box f1&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box f2&quot;&gt;        &lt;div class=&quot;column&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;column&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box f2&quot;&gt;        &lt;div class=&quot;column&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;column mid&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;column&quot;&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- 6、9 --&gt;&lt;div class=&quot;con&quot;&gt;    &lt;div class=&quot;box s1&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box s2&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;box s1&quot;&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-数据结构-队列</title>
      <link href="/2018/12/18/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>/2018/12/18/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过使用js模拟栈的算法，今天主要讲，使用js模拟队列的算法，为什么要这样做呢？说实话是闲的无聊，现在处于一个项目空档期，为了不至于太无聊，就想把数据结构里面的算法都使用js模拟一遍。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h6 id="1、什么是队列？"><a href="#1、什么是队列？" class="headerlink" title="1、什么是队列？"></a>1、什么是队列？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象中午食堂吃饭时、等电梯时、早晚高峰进地铁时，都需要排队。那么肯定是先排队的有优先权，然后依次进入。队列也是这个道理，只有一个出口，一个入口，特点是<code>先进先出</code>，这和栈的思想相反。明白了队列的特点，分析如何使用js实现队列？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列有一个入口，取名为<code>enqueue</code>;出口取名为<code>dequeue</code>;正常情况下，还需要读取队首和队尾元素，命名为<code>front</code>和<code>back</code>，读取队列所有元素，命名为<code>toStringData</code>, 判断队列是否空，命名为<code>isEmpty</code>。现在可以完成队列的构造函数了，如下：</p><pre><code>function Queue() {    this.data = [];    this.enqueue = enqueue;  //队尾添加一个元素    this.dequeue = dequeue;  //队首删除一个元素    this.front = front;  //读取队首元素    this.back = back;  //读取队尾元素    this.toStringData = toStringData;  //显示队内元素    this.isEmpty = isEmpty;  //判断队列是否为空}</code></pre><h6 id="2、使用enqueue-方法，在队尾添加一个元素，如下："><a href="#2、使用enqueue-方法，在队尾添加一个元素，如下：" class="headerlink" title="2、使用enqueue()方法，在队尾添加一个元素，如下："></a>2、使用enqueue()方法，在队尾添加一个元素，如下：</h6><pre><code>function enqueue(element) {    this.data.push(element);}</code></pre><h6 id="3、使用dequeue-方法，在队首删除一个元素，并返回删除的值，如下："><a href="#3、使用dequeue-方法，在队首删除一个元素，并返回删除的值，如下：" class="headerlink" title="3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下："></a>3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下：</h6><pre><code>function dequeue() {    return this.data.shift();}</code></pre><h6 id="4、使用front-方法，返回队首元素，如下："><a href="#4、使用front-方法，返回队首元素，如下：" class="headerlink" title="4、使用front()方法，返回队首元素，如下："></a>4、使用front()方法，返回队首元素，如下：</h6><pre><code>function front() {    return this.data[0];}</code></pre><h6 id="5、使用back-方法，返回队尾元素，如下："><a href="#5、使用back-方法，返回队尾元素，如下：" class="headerlink" title="5、使用back()方法，返回队尾元素，如下："></a>5、使用back()方法，返回队尾元素，如下：</h6><pre><code>function back() {    return this.data[this.data.length - 1];}</code></pre><h6 id="6、使用toStringData-方法，返回队列元素，如下："><a href="#6、使用toStringData-方法，返回队列元素，如下：" class="headerlink" title="6、使用toStringData()方法，返回队列元素，如下："></a>6、使用toStringData()方法，返回队列元素，如下：</h6><pre><code>function toStringData() {    let queueString = &apos;&apos;;    for (let i = 0; i &lt; this.data.length; i++) {        queueString += this.data[i] + &apos;\n&apos;;    }    return queueString;}</code></pre><h6 id="7、使用isEmpty-方法，判断队列是否为空，如下："><a href="#7、使用isEmpty-方法，判断队列是否为空，如下：" class="headerlink" title="7、使用isEmpty()方法，判断队列是否为空，如下："></a>7、使用isEmpty()方法，判断队列是否为空，如下：</h6><pre><code>function isEmpty() {    return this.data.length === 0;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，就使用js实现了一个单向队列。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h6 id="1、使用队列进行排序（基数排序）"><a href="#1、使用队列进行排序（基数排序）" class="headerlink" title="1、使用队列进行排序（基数排序）"></a>1、使用队列进行排序（基数排序）</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍下什么是<code>基数排序</code>，基数排序又叫<code>分配式排序</code>或<code>桶子法</code>，它是通过数据的部分信息，将要排序的元素分配至<code>桶</code>中，以达到排序的作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一串数值，如下所示：</p><pre><code>98、25、31、10、99、81、65、42、51</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：</p><pre><code>0： 101： 31 81 512： 423：4：5： 25 656：7：8： 989： 99</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些桶子中的数值串接起来，如下所示：</p><pre><code>10 31 81 51 42 25 65 98 99</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着根据十位数在进行一次分配，如下所示：</p><pre><code>0：1： 102： 253： 314： 425： 516： 657：8： 819： 98 99</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些数值串接起来，形成以下数值：</p><pre><code>10 25 31 42 51 65 81 98 99</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候排序已经完成；如果有三位数或这更高位数，则持续进行以上动作，直至最高位为止。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使用队列的思想进行排序呢？假设是0～99间的数进行比较，首先需要比较个位数，因为数值在0～99之间，只需对数进行<code>取余</code>,即可得到个位数，对数值除以10，向下取整可得到十位数。到这儿开始使用队列(<code>桶</code>)进行存值，需要是个队列分别存储0～9的值。如下：</p><pre><code>/** *  @param nums 初始数组 *  @param queue 队列数组 *  @param n 几位数 *  @param digit 个位数或十位以上的数 * */function distribute (nums, queue, n, digit) {    for (let i = 0; i &lt; n; i++) {        if (digit === 1) {            queue[nums[i] % 10].enqueue(nums[I]);        } else {            queue[Math.floor(nums[i] / 10)].enqueue(nums[I]);        }    }}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序后展示函数，如下：</p><pre><code>/** *  @param queues 队列数组 *  @nums nums 初始数组 * */function showAfterData (queues, nums) {    let i = 0;    for (let digit = 0; digit &lt; 10; ++digit) {        while (!queues[digit].isEmpty()) {            nums[i++] = queues[digit].dequeue();        }    }    return nums;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成算法后，随机来点数实验下，如下：</p><pre><code>let queues = [];for (let i = 0; i &lt; 10; ++i) {    queues[i] = new Queue();}let nums = [];for (let i = 0; i &lt; 10; ++i) {    nums[i] = Math.floor(Math.floor(Math.random() * 101));}console.log(&apos;个位数排序：&apos;);distribute(nums, queues, 10, 1);console.log(collect(queues, nums));console.log(&apos;十位数排序：&apos;);distribute(nums, queues, 10, 10);console.log(collect(queues, nums));</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-66be795cfa8c3659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基数排序结果"></p><h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双向队列即队列的首尾都能进能出，那么只需在单向队列中添加两个方法，队首添加一个元素方法(<code>fenqueue</code>)，队尾删除一个元素的方法(‘bdequeue’),即可.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列的构造函数添加两个方法，如下：</p><pre><code> function Queue() {     this.data = [];     this.enqueue = enqueue;  //队尾添加一个元素     this.dequeue = dequeue;  //队首删除一个元素     `this.fenqueue = fenqueue;  //队首添加一个元素`     `this.bdequeue = bdequeue;  //队尾删除一个元素`     this.front = front;  //读取队首元素     this.back = back;  //读取队尾元素     this.toStringData = toStringData;  //显示队内元素     this.isEmpty = isEmpty;  //判断队列是否为空 }function fenqueue (element) {    this.data.unshift(element);}function bdequeue () {    return this.data.pop();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就完成了双向队列。双向队列能实现什么功能呢？如回文之类的使用双向队列能很方便的实现，思想如上一片文章中的栈，使用双向队列无论从前还是后插入数据，都一个原理。</p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data-structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-数据结构-栈</title>
      <link href="/2018/12/17/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2018/12/17/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做前端已有几年的时间，各种前端技术学了一堆，换着技术开发网站，感觉自己很牛逼的样子。这段时间总感觉到达了瓶颈，怎么也突破不了，冷静想了下。功能的实现、封装什么都没问题，但是就是算法差强人意。把大学的数据结构拿出来翻了下，这阶段再去看算法，比大学期间清楚太多了，很多原来知道有那回事儿，现在能明白用途在什么地方。我想我找到了突破瓶颈的方式了。从这篇文章开始，我会陆续的把数据结构中的算法用原生js实现。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈是一种数据结构，栈只有一个入口和一个出口，它的特点是<code>LIFO(后入先出)</code>，即比如我们吃的罐装薯片，只有从顶部一片一片的拿出来，才能拿到底部。因为栈的<code>LIFO</code>的特点，所有任何不在栈顶元素都无法访问到，为了得到栈底元素，必须把上面的元素都拿走，才能访问。而栈是一种列表，在js中，可以通过数据的方式来存储。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这儿便有思路了，首先需要一个<code>data</code>存储数据，data是一个数组，因栈只能访问栈顶元素，需要一个变量<code>top</code>存储栈顶元素的位置，当入栈时<code>top + 1</code>,当出栈时，<code>top - 1</code>，那么入栈需要一个方法<code>s_push</code>,出栈需要一个方法<code>s_pop</code>，还需返回栈顶元素的方法<code>s_peek</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，需要清空栈、获取栈的长度或判断元素是否在栈内，以上方法是不够的，还需创建方法，s_clear(清空栈内元素)、s_length(获取栈的长度）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 首先，需要创建一个Stack类的构造函数，如下：</p><pre><code>function Stack () {    this.s_top = 0; //初始化栈顶位置为0    this.s_data = [];   //初始化空栈    this.s_push = s_push;   //入栈方法    this.s_pop = s_pop;     //出栈    this.s_peek = s_peek; //获取栈顶元素    this.s_length = s_length; //栈的长度    this.s_clear = s_clear; //清空栈}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 入栈，实现s_push方法，当向栈中压入新元素时，需要改变s_top对应栈的位置加1，然后指向数组下一个空位置。如下：</p><pre><code>function s_push (element) {    this.s_data[this.s_top++] = element;}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 出栈，s_pop方法和入栈相仿，每次取出元素后，将s_top - 1，然后返回当前删除的值，如下：</p><pre><code>function s_pop () {    --this.s_top;    return this.s_data.pop();}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 获取栈顶元素，s_peek方法，栈顶的位置为s_top,只需要数组中取最后一个元素即可，如下：</p><pre><code>function s_peek () {    return this.s_data[this.s_top - 1];}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 清空栈，s_clear方法，设置栈顶指向为0，清空存储数据，代码如下：</p><pre><code>function s_clear () {    this.s_top = 0;    this.s_data = [];}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 获取栈的长度，s_length, 即s_top的值，如下：</p><pre><code>function s_length () {    return this.s_top;}</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h6 id="1-使用栈模拟递归"><a href="#1-使用栈模拟递归" class="headerlink" title="1. 使用栈模拟递归"></a>1. 使用栈模拟递归</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如需要封装一个阶乘的函数，用递归的思想，如下：</p><pre><code>function factorial (num) {    if (typeof num !== &apos;number&apos;) return num;    if (num &lt;= 1) {        return 1;    } else {        return num * arguments.callee(num - 1);    }}</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果用栈的方式如何处理呢？只需将给定的数递减到1入栈，然后每次s_pop的时候会返回栈顶元素，循环栈，然后将s_pop的值相乘即可，如下：</p><pre><code>function factorial (num) {    if (typeof num !== &apos;number&apos;) return num;    let s = new Stack(),        facNum = 1;    //入栈    while (num &gt; 0) {        s.s_push(num--);    }    //出栈    while (s.s_length() &gt; 0) {        facNum *= s.s_pop();    }    return facNum;}</code></pre><h6 id="2-判断回文"><a href="#2-判断回文" class="headerlink" title="2. 判断回文"></a>2. 判断回文</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说下什么是回文，把相同的字符串或句子颠倒过来，产生首尾循环的句子，意思就是正序和倒叙的结果一样。如何使用栈的思想实现回文呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈的方法有一个pop操作，每次pop返回栈顶元素。那么可以将字符串先push进栈，然后pop即可得到一个逆序的字符串，比较是否相等即可，如下：</p><pre><code>function isPalindrome (str) {    const s = new Stack();    let reverseStr = &apos;&apos;;    for (let i = 0; i &lt; str.length; i++) {        s.s_push(str[i]);    }    while (s.s_length() &gt; 0) {        reverseStr += s.s_pop();    }    return reverseStr === str;}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用栈的思想可以很方便的实现很多功能，比如判断表达式是否括号匹配等？不过说实话，在前端页面的开发中，用不到这些。有兴趣可以玩下，可以提升思维逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> js数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data-structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-in-js框架style-components</title>
      <link href="/2018/11/27/react/style-component/"/>
      <url>/2018/11/27/react/style-component/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端飞一般的发展中，衍生出各式各样的框架，框架的目的是减轻开发人员的开发难度，提高效率。以前网页开发的原则是<code>关注点分离</code>，意思是各种技术只负责自己的领域，不要混合在一起，形成耦合。如html、css、js代码分离。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React的出现，这个原则不在实用，React是组件结构，强制把html、css、js写在一起。如：</p><pre><code>const style = {    &apos;color&apos;: &apos;red&apos;,    &apos;fontSize&apos;: &apos;46px&apos;};const clickHandler = () =&gt; alert(&apos;hi&apos;);ReactDOM.render(    &lt;h1 style={style} onclick={clickHandler}&gt;        Hello, world!    &lt;/h1&gt;,    document.getElementById(&apos;example&apos;));</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在一个js文件里，封装了结构、样式、逻辑，完全违背了<code>关注点分离</code>，很多人刚开始学习React很不适应，但是，这有利于组件的隔离，每个组件需要的代码不依赖于外部、组件之间没有耦合，方便复用。使用React的越来越多，组件模式深入人心，这种<code>关注点混合</code>的新写法逐渐成为主流。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-78fb2ecaa29849c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关注点混合"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表面上，React的写法是html、css、js混合写在一起，实际上是用js在写html、css。React对html的封装是<code>jsx</code>，那么对css的封装是什么呢？这就涉及到今天需要讲的内容<code>style-components</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/12926544-b23d58045a72fa6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css in js"></p><h3 id="什么是style-components"><a href="#什么是style-components" class="headerlink" title="什么是style-components"></a>什么是style-components</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components是针对React写的一套css in js框架，简单来讲就是在js中写css。相对于与预处理器(<code>sass、less</code>)的好处是，css in js使用的是js语法，不用重新再学习新技术，也不会多一道编译步骤。无疑会加快网页速度。如果有sass或less的开发经验，几分钟就可以学会style-components。</p><p><img src="https://upload-images.jianshu.io/upload_images/12926544-bd2a6d306912bb59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="style-components"></p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://www.styled-components.com/docs/basics" target="_blank" rel="noopener">https://www.styled-components.com/docs/basics</a></p><h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h6><p><code>npm install --save style-components</code></p><h6 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components最基础的用法就是以组件的形式编写样式，如下：</p><pre><code>import styled from &apos;styled-components&apos;;const HomeWrapper = styled.div `  width: 960px;  margin: 0 auto;  overflow: hidden;`;const HomeLeft = styled.div `  float: left;  width: 625px;  margin-left: 15px;  padding-top: 30px;  .bannder-img {    width: 625px;    height: 270px;  }`;const HomeRight = styled.div `  float: right;  width: 280px;  margin-left: 15px;  padding-top: 30px;`;render () {    return (        &lt;HomeWrapper&gt;            &lt;HomeLeft&gt;                left            &lt;/HomeLeft&gt;            &lt;HomeRight&gt;                right            &lt;/HomeRight&gt;        &lt;/HomeWrapper&gt;    )}</code></pre><p>上面的代码定义了三个组件，分别为<code>HomeWrapper 、HomeLeft 、HomeRight</code>，这样每一个组件对应唯一的样式，不在出现样式污染的情况。</p><h6 id="2-全局样式"><a href="#2-全局样式" class="headerlink" title="2. 全局样式"></a>2. 全局样式</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个组件对应唯一的样式，那么需要设置全局样式怎么办呢？style-components的最新版提供了<code>createGlobalStyle</code>可以设置全局样式，如下：</p><pre><code>import { createGlobalStyle } from &apos;styled-components&apos;;const GrobalStyle = createGlobalStyle `  html, body, div, span, applet, object, iframe,    h1, h2, h3, h4, h5, h6, p, blockquote, pre,    a, abbr, acronym, address, big, cite, code,    del, dfn, em, img, ins, kbd, q, s, samp,    small, strike, strong, sub, sup, tt, var,    b, u, i, center,    dl, dt, dd, ol, ul, li,    fieldset, form, label, legend,    table, caption, tbody, tfoot, thead, tr, th, td,    article, aside, canvas, details, embed,    figure, figcaption, footer, header, hgroup,    menu, nav, output, ruby, section, summary,    time, mark, audio, video {        margin: 0;        padding: 0;        border: 0;        font-size: 100%;        font: inherit;        vertical-align: baseline;    }    /* HTML5 display-role reset for older browsers */    article, aside, details, figcaption, figure,    footer, header, hgroup, menu, nav, section {        display: block;    }    body {        line-height: 1;    }    ol, ul {        list-style: none;    }    blockquote, q {        quotes: none;    }    blockquote:before, blockquote:after,    q:before, q:after {        content: &apos;&apos;;        content: none;    }    table {        border-collapse: collapse;        border-spacing: 0;    }    @font-face {      font-family: &apos;iconfont&apos;;  /* project id 897264 */      src: url(&apos;//at.alicdn.com/t/font_897264_7ma62sn10m3.eot&apos;);      src: url(&apos;//at.alicdn.com/t/font_897264_7ma62sn10m3.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),      url(&apos;//at.alicdn.com/t/font_897264_7ma62sn10m3.woff&apos;) format(&apos;woff&apos;),      url(&apos;//at.alicdn.com/t/font_897264_7ma62sn10m3.ttf&apos;) format(&apos;truetype&apos;),      url(&apos;//at.alicdn.com/t/font_897264_7ma62sn10m3.svg#iconfont&apos;) format(&apos;svg&apos;);    }    .iconfont {      font-family:&quot;iconfont&quot; !important;      font-size:16px;      font-style:normal;      -webkit-font-smoothing: antialiased;      -moz-osx-font-smoothing: grayscale;    }    .clearfix:after {visibility: hidden;display: block;font-size: 0;content: &quot;.&quot;;clear: both;height: 0;}    .clearfix {zoom: 1;}`;render() {    return (        &lt;Fragment&gt;            &lt;Provider&gt;...&lt;/Provider&gt;            &lt;GrobalStyle/&gt;        &lt;/Fragment&gt;    )}</code></pre><p>上面的代码<code>GrobalStyle</code>是全局样式组件，只需在React组件的最外层引入即可。</p><h6 id="3-图片引入"><a href="#3-图片引入" class="headerlink" title="3. 图片引入"></a>3. 图片引入</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要图片引入，如果像css一样的引入方式，会报错。正确的引入方式是import导入，再以变量的方式引入，如下：</p><pre><code>import styled from &apos;styled-components&apos;;import logPic from &apos;../../statics/images/logo.png&apos;;export const Logo = styled.div `  position: absolute;  top: 0;  left: 0;  width: 100px;  height: 56px;  background-image: url(${logPic});  background-size: contain;`;</code></pre><p>上面的代码<code>logPic</code>是存放logo图片地址的变量，只需使用<code>${logPic}</code>的方式引入即可。如果是后台传过来的图片，如何使用的背景图呢？</p><h6 id="4-props"><a href="#4-props" class="headerlink" title="4. props"></a>4. props</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面提到的问题，可使用组件的传值。先看一个例子：</p><pre><code>recommendList.map((item) =&gt; {    return &lt;RecommendItem key={item} imgUrl={item}/&gt;})const RecommendItem = styled.div `  width: 280px;  height: 50px;  background-image: url(${(props) =&gt; props.imgUrl});  background-size: contain;`;</code></pre><p>从上面的例子，不难发现，父组件传入的值，会存放在子组件的props中，故操作props便能得到预期效果。</p><h6 id="5-标签属性"><a href="#5-标签属性" class="headerlink" title="5. 标签属性"></a>5. 标签属性</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用style-components，需要使用标签属性，如input 的placeholder，a标签的href等，style-components提供了属性<code>attrs</code>，如下：</p><pre><code>export const NavSearch = styled.input.attrs({    placeholder: &apos;搜索&apos;，    type: &apos;text&apos;}) `  width: 160px;  height: 38px;  margin-top: 9px;  padding: 0 40px 0 20px;  box-sizing: border-box;  background-color: #eee;  outline: none;  border: none;  border-radius: 19px;  color: #666;  &amp;::placeholder {    color: #999;  }  &amp;.focused {    width: 240px;  }`;</code></pre><p>上面的代码，<code>attrs</code>里面是一个对象，如果需要多个属性，以对象的形式添加即可。</p><h6 id="6-塑造组件"><a href="#6-塑造组件" class="headerlink" title="6. 塑造组件"></a>6. 塑造组件</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种情况，一些原本就已经是组件，需要给这些组件添加样式，这时需要用到塑造组件，如下：</p><pre><code>const Link = ({className , children}) =&gt; (    &lt;a className={className}&gt;        {children}    &lt;/a&gt;)const StyledLink = styled(Link)`    color: palevioletred;`render(    &lt;div&gt;        &lt;Link&gt;普通组件&lt;/Link&gt;        &lt;StyledLink&gt;添加了样式的组件&lt;/StyledLink&gt;    &lt;/div&gt;);</code></pre><h6 id="7-继承"><a href="#7-继承" class="headerlink" title="7. 继承"></a>7. 继承</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某一组件的样式会用到多个地方，不能每个地方都重新写一套样式，这样代码不够优雅。比如：一个button，有warning、有default、有primary等，这个button只是颜色不同，其他样式一样，这里便可用到继承。</p><pre><code>const Button = styled.button`    line-height: 1.499;    display: inline-block;    font-weight: 400;    text-align: center;    -ms-touch-action: manipulation;    touch-action: manipulation;    cursor: pointer;    background-image: none;    border: 1px solid transparent;    white-space: nowrap;    padding: 0 15px;    font-size: 14px;    border-radius: 4px;    height: 32px;    -webkit-user-select: none;    -moz-user-select: none;    -ms-user-select: none;    user-select: none;    -webkit-transition: all .3s cubic-bezier(.645,.045,.355,1);    transition: all .3s cubic-bezier(.645,.045,.355,1);    position: relative;    -webkit-box-shadow: 0 2px 0 rgba(0,0,0,.015);    box-shadow: 0 2px 0 rgba(0,0,0,.015);    color: rgba(0,0,0,.65);    background-color: #fff;    border-color: #d9d9d9;`;const ButtonPrimary = styled(Button)`    color: #fff;    background-color: #1890ff;    border-color: #1890ff;`;const ButtonWarning = styled(Button)`    color: #f5222d;    background-color: #f5f5f5;    border-color: #d9d9d9;`;</code></pre><p>有人说，公用样式的组件完全可以写到全部样式里面，设置不同的class。这样做可行，但是为什么不直接去写css呢？</p><h6 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a>8. 动画</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官网上有这样一个例子，如下：</p><pre><code>const rotate = keyframes`  from {    transform: rotate(0deg);  }  to {    transform: rotate(360deg);  }`;const Rotate = styled.div`  display: inline-block;  animation: ${rotate} 2s linear infinite;  padding: 2rem 1rem;  font-size: 1.2rem;`;render(    &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt;);</code></pre><p>个人觉得，如果是简单的动画，直接以这样的方式去做，即可，如果动画比较复杂，建议使用react-transition-group框架有更好的体验。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components的常用用法介绍完成，当然官网上还有一些其他的用法，有兴趣可以了解下。使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度，期待下一版能解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> style-components </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux管理状态-todoList实现</title>
      <link href="/2018/11/23/react/Redux%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81-todoList%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/23/react/Redux%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81-todoList%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux的学习，让人又爱又狠，爱它状态管理的便捷，恨它的文档让人一脸懵逼。总之学习Redux的过程痛并快乐着。为什么要些这篇文章？经历了从Redux文档一步一步爬过来，踩了无数地雷，死了无数脑细胞，连亲爱的头发也一天天离我远去，终于神功大成…。话说当年，文档已烂熟于心，本以为从此React江湖任我游，不想，刚出门就差点撞死在<code>Action</code>的门口；好不容易，将货(<code>data</code>),开着兰博基尼(<code>dispatch</code>)送到了仓库(<code>store</code>),不曾想，一堆相同的烂货(<code>initState</code>),陈列在仓库，散发着腐朽的味道，苍蝇呜呜呜的拍打着翅膀，仿佛在嘲笑着<del>傻逼傻逼</del>。拖着疲惫的步伐将货更换完成(<code>reducer</code>),开心的骑着电动小马达，越行越远…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文章的目的为了记录学习新技术的心路历程，以及对当前学习技术的一个总结。顺便带着，如果正在学习，正在看的你有一点点帮助，那么人生便已圆满，废话已经写了这么多，如果不喜欢，欢迎来喷。一直坚信，做技术的，如果不在被喷中成长，就在喷子的口水中变成泼妇。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章讲到使用react实现todoList,使用react做一些简单的页面交互可行，如果页面上的功能比较复杂，多组件之间的交互频繁，只是用react会使整个程序变得非常复杂，不利于维护，可能做到后面自己都不清楚数据是怎么走向的。怎么办呢？2014年Facebook就提出了Flux架构的概念，引发了一系列的实现。2015年，Redux的出现，将Flux与函数式变成结合在一起，很快就成为了前端的热门框架。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux是什么，其实Redux就是React的状态管理工具，当然React状态管理工具不止Redux，比如Mobx等，个人觉得使用Mobx更简单，本文主要介绍如何使用Redux一步一步使用页面功能开发。文章中会简单如何使用阿里的ReactUI组件antd。本文主要讲如何使用Redux管理React的状态，不会涉及太多的原理，想看原理，为啥不直接到官网去，带图的、彩色的、各国的都有，看的你不能自我、欲罢不能。</p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脚手架使用<code>create-react-app</code>, 不清楚如何安装，请看上一篇文章<a href="https://www.jianshu.com/p/60dea52bd960" target="_blank" rel="noopener">React的增删功能-todoList实现</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Redux: <code>npm install -S redux</code></p><h3 id="二、Redux知识总览"><a href="#二、Redux知识总览" class="headerlink" title="二、Redux知识总览"></a>二、Redux知识总览</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux管理React状态的步骤。<code>Action</code>描述事件简单对象，它是改变<code>store</code>中<code>state</code>的唯一方法，通过<code>store.dispatch()</code>方法将<code>Action</code>传到<code>store</code>中。<code>Action</code>的作用只是传递数据，并没有更新数据，如何更新数据<code>Reducer</code>的工作。<code>Reducer</code>接收到<code>Action</code>传入的对应数据，更新数据后返回到store，更新页面。简化来讲，<code>用户触发事件 -&gt;action(dispatch分发) -&gt; store -&gt; Reducer更新数据 -&gt; 返回更新后的数据到store -&gt; 更新页面</code>。如下图：<br>    <img src="https://upload-images.jianshu.io/upload_images/12926544-a3205fe638c36463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux流程图"></p><h3 id="三、Redux实现TodoList"><a href="#三、Redux实现TodoList" class="headerlink" title="三、Redux实现TodoList"></a>三、Redux实现TodoList</h3><h6 id="1-Action"><a href="#1-Action" class="headerlink" title="1. Action"></a>1. Action</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Action</code>是把数据从应用传到<code>store</code>的有效载荷，它是<code>store</code>的<code>唯一</code>来源。通过<code>store.dispatch()</code>将数据传到<code>store</code>。<code>Action</code>是一个对象，里面必须有属性<code>type</code>,type是一个常量,type的作用是数据在Reducer中对应匹配数据使用。在这里我们可以思考下每一个<code>Action</code>都会有对应的type，那么一个网站必然会有很多的type，便于后期维护，最好把type放到统一的文件夹中进行管理。<br>   <code>Action</code>是一个对象，type表示Action的名称。</p><pre><code>{   type: INIT_LIST,   payload: data}</code></pre><p>上面的代码，Action的名称是<code>INIT_LIST</code>,它携带的信息是<code>data</code>数据。</p><h6 id="2-Action-Creator"><a href="#2-Action-Creator" class="headerlink" title="2. Action Creator"></a>2. Action Creator</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View要发多少种信息，就会有多少个Action，如果每个都要写，那么会很麻烦，也不利于维护。使用ActionCreator.js统一管理所有的Action。同时Action的名称type，统一使用ActionTypes.js管理。名称可以随便取，不做强求。</p><pre><code>const INIT_LIST = &apos;init_list&apos;;export const initListAction = (data) =&gt; ({    type: INIT_LIST,    data});</code></pre><p>上面的代码<code>initListAction</code>函数就是一个Action。</p><h6 id="3-store-dispatch"><a href="#3-store-dispatch" class="headerlink" title="3. store.dispatch()"></a>3. store.dispatch()</h6><p>store.dispatch()是View发出Action的唯一方法。</p><pre><code>import { createStore } from &apos;redux&apos;;const store = createStore(fn);store.dispatch({  type: INIT_LIST,  data: &apos;test&apos;});</code></pre><p>上面的代码，<code>store.dispatch</code>接收一个Action对象作为参数，发送给store。<br>结合<code>initListAction</code>，可改写成：</p><pre><code>store.dispatch(initListAction(data));</code></pre><h6 id="4-Reducer"><a href="#4-Reducer" class="headerlink" title="4. Reducer"></a>4. Reducer</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store收到Action后，必须给出新的state，这样View才能发生变化，计算state的过程交Reducer。Reducer是一个纯函数，即有什么样的输入就有什么样的输出。Reducer的写法如下：</p><pre><code>import { CHANGE_INPUT_VALUE, SUBMIT_BTN_ITEM, DELETE_ITEM, INIT_LIST } from &apos;../actions/types&apos;const initialList = {    inputValue: &apos;&apos;,    list: []};const reducerList = (state = initialList, action) =&gt; {    switch (action.type) {        case CHANGE_INPUT_VALUE:            const newState = JSON.parse(JSON.stringify(state));            newState.inputValue = action.inputValue;            return newState;        case SUBMIT_BTN_ITEM:            const submitState = JSON.parse(JSON.stringify(state));            console.log(submitState);            submitState.list.push(submitState.inputValue);            submitState.inputValue = &apos;&apos;;            return submitState;        case DELETE_ITEM:            const deleteState = JSON.parse(JSON.stringify(state));            deleteState.list.splice(action.index);            return deleteState;        case INIT_LIST:            const initState = JSON.parse(JSON.stringify(state));            initState.list = action.data;            return initState;        default:            return state;    }};export default reducerList;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，type放在公用的文件夹中管理，Action的type和Reduce的type必须一致。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因会有很多Action，故使用switch的方式。如果case下面的数据比较复杂，可以单独提出来进行处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const newState = JSON.parse(JSON.stringify(state));</code>这句话的作用是深拷贝，目的是如果直接操作state,会影响其他View的数据。</p><h6 id="5-Store"><a href="#5-Store" class="headerlink" title="5. Store"></a>5. Store</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store是保存数据的地方，整个应用只有一个Store。Redux提供了<code>createStore</code>函数来生成Store。</p><pre><code>import { createStore } from &apos;redux&apos;;const store = createStore(fn);</code></pre><p>上面的代码，<code>createStore</code>接收另外一个函数作为参数，返回新生成的Store对象。</p><h6 id="6-store-subscribe"><a href="#6-store-subscribe" class="headerlink" title="6. store.subscribe()"></a>6. store.subscribe()</h6><p><code>store.subscribe()</code>是Store的监听函数，一旦state改变，就会自动执行这个函数。</p><pre><code>import { createStore } from &apos;redux&apos;;const store = createStore(reducer);store.subscribe(listener);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，只要把View的更新数据替换上面的<code>listener</code>,当state改变时，就能更新数据。<br>绑定事件监听，完成后需要解除事件，只需执行<code>listener</code>就会自动解除监听。</p><h6 id="7-store-getState"><a href="#7-store-getState" class="headerlink" title="7. store.getState"></a>7. store.getState</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在View中需要使用state中的数据，使用<code>store.getState</code>获取store中state数据，展示到页面即可。</p><pre><code>import { createStore } from &apos;redux&apos;;const store = createStore(fn);store.getState(state);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面介绍了Redux一些基础的使用方法，一个完整的项目使用这样的方法，会比较繁琐，那么怎么办呢？下一节会讲到，中间键<code>redux-saga、redux-thunk</code>和异步的使用方法，同时会讲到antd UI组建的使用。想看源码请<a href="https://github.com/zhuLni/redux-todoList" target="_blank" rel="noopener">狠狠的点击这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> React小功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-自定义滚动条</title>
      <link href="/2018/11/22/css/css-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/"/>
      <url>/2018/11/22/css/css-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-初衷"><a href="#1-初衷" class="headerlink" title="1. 初衷"></a>1. 初衷</h3><p>   做了几年的前端了，做笔记都是在自己的网盘里面记录，每次翻原来的笔记，总感觉差了点什么，突然有一天，一声惊雷闪过，文字依旧是那点文字，读者只有唯一，为什么不能分享出来，分享踩过的坑，希望能帮助到正在看的你。</p><h3 id="2-为什么要自定义滚动条？"><a href="#2-为什么要自定义滚动条？" class="headerlink" title="2.为什么要自定义滚动条？"></a>2.为什么要自定义滚动条？</h3><p>一直觉得，滚动条用默认的就好了，没特殊需求为啥要自定义呢？之前做过一个自定义表格，功能有：超出一定的高度滚动起来，表头固定，没列有自定义右键菜单，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-f5dd600e4ca7a183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows端自定义表格"><br>最近入手一台Mac，再看原来的代码，Mac竟然如此神奇，滚动条不占位置，还会显示隐藏，而我自定义的表格在Mac端出问题，因为表格自定义，使用的ul、li模拟的表格，滚动条在windows端占位，到Mac端不占位了，故出现表头和内容不对齐情况，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-7254682ee119f345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mac端自定义表格"><br>图中是有滚动条的，因Mac默认隐藏，故滚动条的<code>17px</code>导致错行。</p><h3 id="3-实现Mac端滚动条兼容"><a href="#3-实现Mac端滚动条兼容" class="headerlink" title="3. 实现Mac端滚动条兼容"></a>3. 实现Mac端滚动条兼容</h3><p>   要做到同时兼容windows和Mac，那么可以自定义滚动条，做法很简单，在全局的css样式中加入下面代码即可：</p><pre><code>//自动移滚动条样式::-webkit-scrollbar{  width: 5px;  height: 5px;}::-webkit-scrollbar-thumb{  border-radius: 1em;  background-color: rgba(50,50,50,.3);}::-webkit-scrollbar-track{  border-radius: 1em;  background-color: rgba(50,50,50,.1);}</code></pre><p>1、::-webkit-scrollbar   定义了滚动条整体的样式；<br>2、::-webkit-scrollbar-thumb  滑块部分；<br>3、::-webkit-scrollbar-thumb  轨道部分；</p><p>加上这个代码，在看下效果，自定义表格完美兼容Mac。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-2e90bfc309a207a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>自定义滚动条有很多方式，这里只是展示了个人觉得比较简单的，还有很多插件可以实现，有兴趣的朋友可以自己玩一下。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-todoList实现</title>
      <link href="/2018/11/13/react/react-todoList%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/13/react/react-todoList%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p> React作为当前最火的框架之一，学习和使用已有一段时间，在这里记录下学习React的心得，纯属个人观点。在学习React之前，了解过Vue,和angular，个人比较喜欢React的开发模式，之前的开发用的比较多jquery的模板（artTemplate,hogan）之类的，和React中的jsx原理类似，因此被吸引。</p><p><img src="https://upload-images.jianshu.io/upload_images/12926544-5d9dd940c034f2b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="一、-React的准备工作"><a href="#一、-React的准备工作" class="headerlink" title="一、 React的准备工作"></a>一、 React的准备工作</h2><p>   学习react有很多途径，可以看官网，可以看博客，可以看视频，这里比较推荐的做法是先看官网，了解基本知识后，做一些例子。然后再学习相关依赖，如<code>Redux、Mobx</code>之类的状态管理工具，之后的文章中会进一步讲解React相关依赖，有：<code>Redux、Mobx、Redux-thunk、Redux-saga、immutable、react-transition-group、antd、styled-components、prop-types</code>等。<br>   开始学习React需要一定的开发基础，如：<code>Es6、webpack</code>等。我学习React使用的是create-react-app脚手架，</p><h5 id="安装：npm-install-g-create-react-app"><a href="#安装：npm-install-g-create-react-app" class="headerlink" title="安装：npm install -g create-react-app"></a>安装：<code>npm install -g create-react-app</code></h5><h5 id="创建React应用：-create-react-app-my-app"><a href="#创建React应用：-create-react-app-my-app" class="headerlink" title="创建React应用： create-react-app my-app"></a>创建React应用： <code>create-react-app my-app</code></h5><pre><code>$ create-react-app my-appCreating a new React app in G:\GitHub\React-demo\my-app.Installing packages. This might take a couple of minutes.Installing react, react-dom, and react-scripts...</code></pre><h6 id="1、主要依赖react-react-dom-react-scripts"><a href="#1、主要依赖react-react-dom-react-scripts" class="headerlink" title="1、主要依赖react,react-dom,react-scripts"></a>1、主要依赖react,react-dom,react-scripts</h6><h6 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h6><p><img src="https://upload-images.jianshu.io/upload_images/12926544-b447353bf665529b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h6 id="3、运行-npm-start"><a href="#3、运行-npm-start" class="headerlink" title="3、运行 npm start"></a>3、运行 <code>npm start</code></h6><h6 id="4、打包-npm-run-build"><a href="#4、打包-npm-run-build" class="headerlink" title="4、打包 npm run build"></a>4、打包 <code>npm run build</code></h6><h2 id="二、正式开发"><a href="#二、正式开发" class="headerlink" title="二、正式开发"></a>二、正式开发</h2><p>1、使用react做一个输入框，点击提交在下面列表展示，点击对应的列表项，删除该项，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-0b9480173bf5297a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>2、项目的数据结构，首先分析需求，一个input框，一个button，一个列表。可以把input和button看成一个组件，列表看成一个组件。在state中的数据结构可以设置为：</p><pre><code>//state的数据结构this.state = {    inputValue: &apos;&apos;, //用于存放input的值    list: []        //存放列表的值}</code></pre><ol start="3"><li><p>input框功能实现，原理：input框绑定onChange事件，每当输入字符时，改变this.state.inputValue的值，React中当state或props中的值改变，render函数会重新执行。实现如下：</p><pre><code>//方法一：改变this.state.inputValue值，通过事件返回的e.target.value,获取输入框中的值&lt;input type=&quot;text&quot; onChange={this.handleChange} value={this.state.inputValue} /&gt;handleChange (e) {    //同步setState    this.setState({        inputValue: e.target.value    });}//方法二：在input框上设置ref属性，ref表示对组件真正实例的引用。//设置ref={(input) =&gt; {this.input = input}}表示，将当前input框中的value值，//绑定到this上，在handleChange方法中，便可以直接取input的值：this.input.value&lt;input type=&quot;text&quot;       id=&quot;inputValue&quot;       onChange={this.handleChange}       value={this.state.inputValue}       ref={(input) =&gt; {this.input = input}}/&gt;handleChange (e) {    const value = this.input.value;    //异步setState，可以为异步方法，带有一个参数prevState,即为上一步state的内容，同时带有回调函数    this.setState(() =&gt; ({        inputValue: value    }), () =&gt; {        console.log(&apos;赋值完成！&apos;);    });}</code></pre></li><li><p>提交功能实现，原理：很容易就想到，当点击提交的时候，将input框中的值push到this.state.list即可。</p><pre><code>&lt;button onClick={this.handleSubmit}&gt;提交&lt;/button&gt;//提交添加UI列表handleSubmit () {    this.setState((prevState) =&gt; ({        list: [...prevState.list, prevState.inputValue],        inputValue: &apos;&apos;    }), () =&gt; { //回调函数        console.log(this.ul.querySelectorAll(&apos;li&apos;).length);    });}</code></pre></li><li><p>将list的值在页面展示出来,可以通过map方法，循环li。</p><pre><code>this.state.list.map((item, index) =&gt; {    return &lt;li key={index}&gt;{item}&lt;/li&gt;})/*    注：react中循环的时候，必须在每一项加上key的属性，不然控制台会报错，    原因是：diff算法在循环的时候,会去匹配对应的key值。此处用index作为key值是不合理的做法，key值应该是唯一的，    diff算法后面会详细讲到。*/</code></pre></li><li><p>点击li，删除当前li,原理：每一个li都有对应的index，点击li时，获取index，在list找到对应下标，然后delete即可。</p><pre><code>this.state.list.map((item, index) =&gt; {    return &lt;li key={index} onClick={this.handleDeleteItem.bind(this, index)}&gt;{item}&lt;/li&gt;})//删除当前点击itemhandleDelete (index) {    this.setState((prevState) =&gt; {        const list = [...prevState.list];        list.splice(index, 1);        return {            list: list        }    });}</code></pre></li></ol><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h6 id="React的原理"><a href="#React的原理" class="headerlink" title="React的原理"></a>React的原理</h6><pre><code>1. state改变2. jsx模板3. 数据 + 模板 生成虚拟dom（虚拟DOM就是一个js对象，用来描述真实的DOM）（损耗了性能）4. 用虚拟DOM结构生成真实的DOM，来显示5. state改变6. 数据 + 模板 生成新的虚拟DOM（极大的提升了性能）7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到区别（diff算法）8. 直接操作DOM，改变不同之处</code></pre><h6 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h6><pre><code>1. 同层对比（变化前和变化后，虚拟DOM同一级进行对比）2. 列表（每个循环的列表都需要一个唯一的key，用于做对比，节约性能，因此用循环的index作为key是不靠谱的做法，浪费性能）3. 组件（一个React的APP有多个组件进行组成，diff对比组件的class）4. 绘制    1). 当调用setState时，React将其标记为Dirty，然后事件轮询介绍时，React会查询dirty组件并重新绘制    2). 当组件的setState方法被调用，组件会重新绘制它的子组件5. react事件委托（通过事件冒泡至document处，合成对象(SyntheticEvent)，当触发事件时，通过dispatchEvent分发函数分发）</code></pre><h6 id="生命周期函数（在某一时刻组件会自动执行调用的函数）"><a href="#生命周期函数（在某一时刻组件会自动执行调用的函数）" class="headerlink" title="生命周期函数（在某一时刻组件会自动执行调用的函数）"></a>生命周期函数（在某一时刻组件会自动执行调用的函数）</h6><pre><code>1. initialization (constructor) 初始化2. Mounting (组件第一次挂载的流程)    1). componentWillMount 在组件即将被挂载到页面的时刻执行，即render前执行    2). render    3). componentDidMount 在组件挂载到页面的时刻执行3. Updation    1). componentWillReceiveProps 从父组件接收参数并且这个组件在之前就存在父组件中 （props）    2). shouldComponentUpdate 在更新前调用，如果该组件返回true,往下执行，否则停止    3). componentWillUpdate 在更新前调用，shouldComponentUpdate返回true之后    4). render    5). componentDidUpdate 更新之后调用4. Unmounting    1). componentWillUnmount 即将被页面移除的时候执行</code></pre><h6 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h6><p>本文使用react做了一个添加删除的功能，代码已放在GitHub上，有兴趣请<a href="https://github.com/zhuLni/todoList" target="_blank" rel="noopener">狠狠的点击这儿</a>。</p>]]></content>
      
      
      <categories>
          
          <category> React小功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE下input框后面默认带有X，去除方法</title>
      <link href="/2018/09/12/css/IE%E4%B8%8Binput%E6%A1%86%E5%90%8E%E9%9D%A2%E9%BB%98%E8%AE%A4%E5%B8%A6%E6%9C%89X%EF%BC%8C%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/12/css/IE%E4%B8%8Binput%E6%A1%86%E5%90%8E%E9%9D%A2%E9%BB%98%E8%AE%A4%E5%B8%A6%E6%9C%89X%EF%BC%8C%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在IE9下，input框带有X,如何去除？<br><img src="https://upload-images.jianshu.io/upload_images/12926544-6a5a267109999018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180912105825.png"></p><p>去除IE下input带x的方法，很简单，只需要css中加一句话就行了</p><pre><code>//去除IE下input框后面的Xinput::-ms-clear, input::-ms-reveal{      display: none;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义鼠标右键</title>
      <link href="/2018/09/11/jQuery/jQuery-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/"/>
      <url>/2018/09/11/jQuery/jQuery-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、自定义鼠标右键的实现原理"><a href="#一、自定义鼠标右键的实现原理" class="headerlink" title="一、自定义鼠标右键的实现原理"></a>一、自定义鼠标右键的实现原理</h1><p><img src="https://upload-images.jianshu.io/upload_images/12926544-0fba8e14b4e89680.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180911164755.png"></p><p>自定义右键菜单功能，需清楚，所有浏览器都自带了右键功能，那么自定义右键菜单，需要先屏蔽系统自带的右键功能，如何实现呢？</p><pre><code>$selector.on(&apos;contextmenu&apos;, &apos;.box&apos;, function () {    return false;})</code></pre><p>注：$selector为选择器，.box为禁用鼠标右键的class<br>完成系统自带鼠标右键的禁用后，开始自定义鼠标右键。</p><hr><p>获取鼠标事件的方法，使用mousedown,获取后需区分是鼠标左键还是右键，事件返回的参数event中，event.which为3表示右键，为1表示左键，为2表示中键。如下：</p><pre><code>$(&quot;#box&quot;).mousedown(function(e){      if(3 === e.which){           alert(&quot;这 是右键单击事件&quot;);        }else if(1 === e.which){               alert(&quot;这 是左键单击事件&quot;);         }  else if (2  ===  e.which)  {            alert(&quot;这是鼠标中键&quot;);        }    })</code></pre><hr><h1 id="二、自定义鼠标右键实例（表格行右键自定菜单）"><a href="#二、自定义鼠标右键实例（表格行右键自定菜单）" class="headerlink" title="二、自定义鼠标右键实例（表格行右键自定菜单）"></a>二、自定义鼠标右键实例（表格行右键自定菜单）</h1><h4 id="html"><a href="#html" class="headerlink" title="html:"></a>html:</h4><pre><code>&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;table-list&quot;&gt;    &lt;div class=&quot;table-thead &quot;&gt;        &lt;ul class=&quot;table-col&quot;&gt;            &lt;li class=&quot;save-item&quot; title=&quot;名称&quot;&gt;                &lt;span&gt;名称&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;类型&quot;&gt;                &lt;span&gt;类型&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;数据&quot;&gt;                &lt;span&gt;数据&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot;&gt;               &lt;span&gt;操作&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;table-tbody&quot;&gt;        &lt;ul class=&quot;table-col saveCol&quot;&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test1&quot;&gt;                &lt;span&gt;test1&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test2&quot;&gt;                &lt;span&gt;test2&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test3&quot;&gt;                &lt;span&gt;test3&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot;&gt;                &lt;i class=&quot;point-icon opratePointDrop&quot; data-toggle=&quot;close&quot;&gt;&lt;/i&gt;                &lt;ul class=&quot;oprate-dropdown opDropDown none&quot;&gt;                    &lt;li class=&quot;op-item btn-mySaveRun&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;运行&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveRename&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;编辑&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveEdit&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;刷新&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveDelete&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;导出&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;table-col saveCol&quot;&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test1&quot;&gt;                &lt;span&gt;test1&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test2&quot;&gt;                &lt;span&gt;test2&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test3&quot;&gt;                &lt;span&gt;test3&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot;&gt;                &lt;i class=&quot;point-icon opratePointDrop&quot; data-toggle=&quot;close&quot;&gt;&lt;/i&gt;                &lt;ul class=&quot;oprate-dropdown opDropDown none&quot;&gt;                    &lt;li class=&quot;op-item btn-mySaveRun&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;运行&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveRename&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;编辑&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveEdit&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;刷新&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveDelete&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;导出&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;table-col saveCol&quot;&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test1&quot;&gt;                &lt;span&gt;test1&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test2&quot;&gt;                &lt;span&gt;test2&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot; title=&quot;test3&quot;&gt;                &lt;span&gt;test3&lt;/span&gt;            &lt;/li&gt;            &lt;li class=&quot;save-item&quot;&gt;                &lt;i class=&quot;point-icon opratePointDrop&quot; data-toggle=&quot;close&quot;&gt;&lt;/i&gt;                &lt;ul class=&quot;oprate-dropdown opDropDown none&quot;&gt;                    &lt;li class=&quot;op-item btn-mySaveRun&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;运行&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveRename&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;编辑&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveEdit&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;刷新&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                    &lt;li class=&quot;op-item btn-mySaveDelete&quot;&gt;                        &lt;a href=&quot;javascript:;&quot;&gt;                            &lt;span&gt;导出&lt;/span&gt;                        &lt;/a&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>   </p><hr><h4 id="css"><a href="#css" class="headerlink" title="css:"></a>css:</h4><pre><code>* {    border: none;    margin: 0;    padding: 0;}ul, ul li, ol li, li {    list-style: none;}a {    text-decoration: none;}.none {    display: none;}.box {    width: 1000px;    margin: 20px 50px;}/* 自定义table */.table-list {    width: 100%;}.table-list .table-tbody {    position: relative;    max-height: 350px;    min-height: 225px;}.table-list .table-thead ul {    background-color: #f5f5f5;}.table-thead &gt; ul li {    font-weight: bold !important;}.table-tbody &gt; ul {    margin-top: -1px;    position: relative;    cursor: pointer;}.table-tbody &gt; ul:hover {    background-color: #f5f5f5;}.table-thead, .table-tbody {    width: 100%;}.table-thead &gt; ul, .table-tbody &gt; ul{    display: flex;}.table-thead &gt; ul &gt; li, .table-tbody &gt; ul &gt; li {    flex: 1;    height: 36px;    font: normal 12px/36px &apos;Microsoft YaHei&apos;, &apos;Arial&apos;;    border: 1px solid #d9d9d9;    border-left: none;}.table-thead &gt; ul &gt; li:first-child, .table-tbody &gt; ul &gt; li:first-child {    border-left: 1px solid #d9d9d9;}.table-thead &gt; ul &gt; li &gt; span, .table-tbody &gt; ul &gt; li &gt; span {    width: 90%;    display: inline-block;    margin: 0 10px;    overflow: hidden;    white-space: nowrap;    text-overflow: ellipsis;}/* 下拉 */.oprate-dropdown {    position: absolute;    top: 28px;    right: 3px;    width: 90px;    border: 1px solid #d9d9d9;    box-shadow: 0 0 5px #ccc;    z-index: 100;    /* 禁用选择字体 */    -moz-user-select: none; /*火狐*/    -webkit-user-select: none; /*webkit浏览器*/    -ms-user-select: none; /*IE10*/    user-select: none;}.oprate-dropdown li.op-item {    width: 100%;    height: 32px;    background-color: #fff;}.oprate-dropdown li.op-item:hover {     background-color: #f2f3f6;}.oprate-dropdown li.op-item a {    display: inline-block;    width: 70px;    line-height: 32px;    border-bottom: 1px solid #d9d9d9;    color: #2a313f;    margin: 0 10px;    overflow: hidden;}.oprate-dropdown li.op-item .op-icon {    position: relative;    left: 0;    top: 5px;    display: inline-block;    width: 15px;    height: 20px;}.point-icon {    display: inline-block;    width: 20px;    height: 15px;    background: url(../image/point-icon.png) no-repeat;    background-position: 0 10px;    cursor: pointer;    margin-left: 10px;}</code></pre><hr><h4 id="js"><a href="#js" class="headerlink" title="js:"></a>js:</h4><pre><code>var _rightMenu = {    init: function () {        var _this = this;        _this.rightMenuOprate();    },    rightMenuOprate: function () {        var $searchPart = $(&apos;.box&apos;);        //操作点击下拉        $searchPart.on(&apos;click&apos;, &apos;.opratePointDrop&apos;, function (e) {            e.stopPropagation();            var $this = $(this),                _isOpen = $this.attr(&apos;data-toggle&apos;),                $dropDown = $this.next();            //清空所有显示下拉            $searchPart.find(&apos;.opDropDown&apos;).each(function () {                var $this = $(this);                $this.hide();                $this.prev().attr(&apos;data-toggle&apos;, &apos;close&apos;);            });            if (_isOpen === &apos;close&apos;) {                $dropDown.show().css(&apos;left&apos;, &apos;&apos;);                $this.attr(&apos;data-toggle&apos;, &apos;open&apos;)            } else if (_isOpen === &apos;open&apos;) {                $dropDown.hide();                $this.attr(&apos;data-toggle&apos;, &apos;close&apos;)            }        });        //禁止鼠标右键事件        $searchPart.on(&apos;contextmenu&apos;, &apos;.saveCol&apos;, function () {            return false;        });        //鼠标右键        $searchPart.on(&apos;mousedown&apos;, &apos;.saveCol&apos;, function (e) {            e.stopPropagation();            var $this = $(this);            if (3 === e.which) {                //隐藏其他展开的下拉                $searchPart.find(&apos;.opDropDown&apos;).each(function () {                    var $this = $(this);                    $this.hide();                    $this.prev().attr(&apos;data-toggle&apos;, &apos;close&apos;);                });                $this.find(&apos;.opDropDown&apos;).show().css({                    &apos;left&apos;: e.pageX - 50  + &apos;px&apos;                });            }        });        //点击清除        $(document).click(function (e) {            //兼容火狐            if (1 === e.which) {                $searchPart.find(&apos;.opratePointDrop&apos;).attr(&apos;data-toggle&apos;, &apos;close&apos;);                $searchPart.find(&apos;.opDropDown&apos;).hide();            }        });    }};$(function () {    _rightMenu.init();});</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> jQuery自定义功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
