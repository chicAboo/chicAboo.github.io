<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js-数据结构-链表]]></title>
    <url>%2F2019%2F02%2F22%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是链表？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一 个节点的引用叫做链表。其中链表分为基本链表、双向链表及循环链表，如下图： 基本链表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过，栈和队列使用数组模拟，在JavaScript中数组被模拟成对象，相比于其他语言（如java或C++），效率明显低了很多，如果使用数组比较慢的情况，那么就应该使用链表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先定义一个链表，链表中包含两个节点，Node类表示头节点，LinkedList类提供链表的插入、删除、查找、显示等辅助方法。 Node类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node类包含两个属性：element属性用来保存节点上的元素，next属性指向下一个节点，Node的构造函数实现，代码如下：1234567/** * 节点构造函数 * */function Node (element) &#123; this.element = element; this.next = null;&#125; LinkedList类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedList类提供了链表的插入、删除、查找、显示等操作，LinkedList类的构造函数实现如下：1234567891011/** * 链表构造函数 * */function LList () &#123; this.head = new Node('head'); this.find = find; this.insert = insert; this.findPrev = findPrev; this.remove = remove; this.display = display;&#125; 默认head节点指向为空，当有节点插入时指向下一个节点，find方法为查找链表指定元素，insert方法指在链表指定节点后插入元素，findPrev方法指查找链表上一个元素，remove方法指删除指定元素，display方法指遍历链表，显示链表元素。 find方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find方法用于遍历链表，查找指定元素，并返回指定元素节点，实现如下：12345678910111213/** * 遍历链表，查找链表指定节点 * */function find (item) &#123; var currNode = this.head; //从头节点开始遍历，查找到给定元素，结束循环 while (currNode.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find()演示了遍历链表的过程。 insert方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入节点前，首先需要创建一个新节点，将链表头节点复值给新创建节点，并查找指定元素(find())，在指定元素后插入新节点。插入方法，将新节点的next指向当前元素的next，当前元素的next指向新节点。如图： 代码如下：12345678910/** * 在链表指定节点中插入元素 * */function insert (newElement, item) &#123; var newNode = new Node(newElement); var currentNode = this.find(item); newNode.next = currentNode.next; newNode.previous = currentNode; currentNode.next = newNode;&#125; display方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display方法用于显示链表上的节点，故需要遍历链表，每次循环打印出当前节点，并将当前节点的next指向下一个节点，直到null时结束。代码如下：1234567891011/** * 展示链表的所有元素 * */function display () &#123; var currNode = this.head; while (!(currNode.next == null)) &#123; console.log(currNode.next.element + ','); currNode = currNode.next; &#125;&#125; findPrev方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findPrev方法查找链表指定节点的前一个元素，并返回该节点。遍历链表，如果当前节点的下一个元素的element等于指定元素，择找到指定元素的前一个元素，返回。代码如下：123456789101112/** * 查找指定元素上一个元素 * */function findPrev (item) &#123; var currNode = this.head; while (currNode.next !== null &amp;&amp; currNode.next.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125; remove方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove方法删除指定元素，在删除指定元素前需要找到指定元素的前一个元素，并改变前一个元素的指针，将前一个元素的next指向前一个元素的next的next，如图： 代码如下：123456789/** * 删除链表指定元素 * */function remove (item) &#123; var prevNode = this.findPrev(item); if (prevNode.next !== null) &#123; prevNode.next = prevNode.next.next; &#125;&#125; 到这里基本链表的常用方法已经完成，该是测试代码的时候了，做点简单的增删功能试试。 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设需要向链表中依此插入A、B、C、D，然后在A的后面插入H，删除B和C。12345678910111213141516var city = new LList();//插入console.log('插入');city.insert('A', 'head');city.insert('B', 'A');city.insert('C', 'B');city.insert('D', 'C');city.insert('H', 'A');city.display();//删除console.log('-----------------');console.log('删除');city.remove('B');city.remove('C');city.display(); 执行结果：]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-骰子布局]]></title>
    <url>%2F2019%2F02%2F13%2Fcss%2Fflex-%E9%AA%B0%E5%AD%90%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[目录： 概念 flex容器的属性 2.1. flex-direction 2.2. flex-wrap 2.3. flex-flow 2.4. justify-content 2.5. align-items 2.6. align-content 项目的属性 3.1. order 3.2. flex-grow 3.3. flex-shrink 3.4. flex-basis 3.5. flex 3.6. align-self flex布局实践（骰子布局） 总结 源码 一、概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex布局称为flex容器，flex容器默认两根轴：水平主轴和垂直交叉轴。以下概念都围绕水平主轴和垂直交叉轴而定义。 二、flex容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1. flex-direction 决定主轴的方向 row(默认值): 主轴水平方向，左端为起点 row-reverse: 主轴水平方向，右端为起点 column: 主轴垂直方向，上端为起点 column-reverse: 主轴垂直方向，下端为起点 2. flex-wrap 项目是否排列在轴线上，是否换行属性 nowrap(默认值): 不换行 wrap: 换行，第一行在上方 wrap-reverse: 换行，第一行在下方 3. flex-flow: flex-direction和flex-wrap的简写4. justify-content 定义主轴上的对其方式 flex-start(默认值): 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对其，项目间间距相等 space-around: 每个项目两端的间距相等 5. align-items 项目在交叉线上的对齐方式 flex-start: 交叉线的起点对齐 flex-end: 交叉线的终点对齐 center: 交叉线的中心对齐 baseline: 项目第一行文字的基线对齐 stretch(默认值): 如果项目未设置高度或auto,将占满容器的高度 6. align-content 多行对其，如果只有一行，不起作用 flex-start: 与交叉点的起点对齐 flex-end: 与交叉点的终点对齐 center: 与交叉点的中心对齐 space-between: 与交叉线两端对齐，轴线间间隔平均分配 space-around: 每根轴线间隔相等 stretch: 轴线占满整个交叉线 三、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1. order定义项目的排列顺序，值越小越靠前，默认为0 .item { &nbsp;&nbsp;&nbsp;&nbsp;order: ;} 2. flex-grow定义项目的放大比例，默认为0 .item { &nbsp;&nbsp;&nbsp;&nbsp; flex-grow: ;} 如果flex-grow为1，则项目等分，如果有一个为2，其他为1，则该项目是其他项目的两倍。 3. flex-shrink定义项目的缩小比例，默认值为1。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex-shrink: ;} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效 4. flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex-basis: | auto;} 它可以设为跟width或height属性一样的值（比如250px），则项目将占据固定空间。 5. flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。习惯使用这个属性。 6. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。 .item { &nbsp;&nbsp;&nbsp;&nbsp;align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 四、flex布局实践（骰子布局）假设骰子的一面最多可以放9个点。 下面来说如何使用flex布局骰子，html默认为 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; .box元素代表flex容器，.item元素代表一个项目，需要几个项目就有几个class为item的div元素。 1. 单项目1.1 首先左上角一个点，默认情况即可。 .box { width: 60px; height: 60px; border: 1px solid white; background: white; border-radius: 5px; display: flex; margin: 10px; } .box的样式为以上，下面所有都依据这个来的。 1.2 黑点在第一行居中对齐，使用justify-content: center即可。 .box.one1 { flex-direction: row; /* 默认值可以不写*/ justify-content: center; } 1.3 黑点在第一行右对齐，使用justify-content: flex-end。 .box.one2 { justify-content: flex-end; } 1.4 黑点在第二行第一个，转化为垂直交叉线排列方式，居中即可。 .box.one3 { align-items: center; } 1.5 黑点垂直水平居中 .box.one4 { align-items: center; justify-content: center; } 1.6 黑点在第二行右侧 .box.one5 { align-items: center; justify-content: flex-end; } 1.7 黑点在最后一行第一个 .box.one6 { align-items: flex-end; } 1.8 黑点在最后一行居中 .box.one7 { align-items: flex-end; justify-content: center; } 1.9 黑点在最后一行最后一个 .box.one8 { align-items: flex-end; justify-content: flex-end; } 2. 双项目html模版为 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 2.1 第一行左右布局 .box.two1 { justify-content: space-between; } 2.2 左侧上下布局 .box.two2 { flex-direction: column; justify-content: space-between; } 2.3 居中上下布局 .box.two3 { flex-direction: column; justify-content: space-between; align-items: center; } 2.4 右侧上下布局 .box.two4 { flex-direction: column; justify-content: space-between; align-items: flex-end; } 2.5 左上右下布局 .box.two3 { justify-content: space-between; } .two3 .item:last-child { align-self: flex-end; } 3. 三项目html模版 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 3.1 一左二中三右布局 .three1 { flex-direction: column; } .three1 .item:nth-child(2) { align-self: center; } .three1 .item:nth-child(3) { align-self: flex-end; } 3.2 一右二中三左布局 .three2 { flex-direction: column; align-items: flex-end; } .three2 .item:nth-child(2) { align-self: center; } .three2 .item:nth-child(3) { align-self: flex-start; } 4. 四项目4.1 第一排铺满，最后一排右布局模版： &lt;div class=&quot;box four1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 图：样式： .four1 { flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } 4.2 上下左右四个角布局html模版: &lt;div class=&quot;box four2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 图： 样式： .four2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } 5. 五项目html模版： &lt;div class=&quot;box four2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column mid&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 图： 样式： .four2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } .mid { align-items: center; justify-content: center; } 6. 六项目html模版： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 6.1 上三下三布局 .s1 { flex-wrap: wrap; align-content: space-between; } 6.2 左三右三布局 .s2 { flex-direction: column; flex-wrap: wrap; align-content: space-between; } 7 九项目html模版： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 图： 样式： .n1 { flex-wrap: wrap; } 五、总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用flex布局很多情况下节省很多工作量，方便简单好用。特别手机端用的很多。 六、完整代码没上传GitHub，这儿随便写了下符在下面。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body { background: black; } .con { margin: 50px; display: flex; flex-direction: row; } .box { width: 60px; height: 60px; border: 1px solid white; background: white; border-radius: 5px; display: flex; margin: 10px; } .item { width: 10px; height: 10px; background: black; border-radius: 5px; margin: 5px; } .box.one1 { flex-direction: row; justify-content: center; } .box.one2 { flex-direction: row; justify-content: flex-end; } .box.one3 { flex-direction: row; align-items: center; } .box.one4 { flex-direction: row; align-items: center; justify-content: center; } .box.one5 { align-items: center; justify-content: flex-end; } .box.one6 { align-items: flex-end; } .box.one7 { align-items: flex-end; justify-content: center; } .box.one8 { align-items: flex-end; justify-content: flex-end; } .box.two1 { justify-content: space-between; } .box.two2 { flex-direction: column; justify-content: space-between; } .box.two21 { flex-direction: column; justify-content: space-between; align-items: center; } .box.two22 { flex-direction: column; justify-content: space-between; align-items: flex-end; } .box .item1 { align-self: center; } .box.two3 { justify-content: space-between; } .two3 .item:last-child { align-self: flex-end; } .t1 { flex-direction: column; } .t1 .item:nth-child(2) { align-self: center; } .t1 .item:nth-child(3) { align-self: flex-end; } .t2 { flex-direction: column; align-items: flex-end; } .t2 .item:nth-child(2) { align-self: center; } .t2 .item:nth-child(3) { align-self: flex-start; } .f1 { flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } .f2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } .mid { align-items: center; justify-content: center; } .s1 { flex-wrap: wrap; align-content: space-between; } .s2 { flex-direction: column; flex-wrap: wrap; align-content: space-between; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one3&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one4&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one5&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one6&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one7&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one8&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 2 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two21&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two22&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two3&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box t1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box t2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4、5 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box f1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box f2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box f2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column mid&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 6、9 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box s1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box s2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box s1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-数据结构-队列]]></title>
    <url>%2F2018%2F12%2F18%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过使用js模拟栈的算法，今天主要讲，使用js模拟队列的算法，为什么要这样做呢？说实话是闲的无聊，现在处于一个项目空档期，为了不至于太无聊，就想把数据结构里面的算法都使用js模拟一遍。 队列1、什么是队列？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象中午食堂吃饭时、等电梯时、早晚高峰进地铁时，都需要排队。那么肯定是先排队的有优先权，然后依次进入。队列也是这个道理，只有一个出口，一个入口，特点是先进先出，这和栈的思想相反。明白了队列的特点，分析如何使用js实现队列？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列有一个入口，取名为enqueue;出口取名为dequeue;正常情况下，还需要读取队首和队尾元素，命名为front和back，读取队列所有元素，命名为toStringData, 判断队列是否空，命名为isEmpty。现在可以完成队列的构造函数了，如下：123456789function Queue() &#123; this.data = []; this.enqueue = enqueue; //队尾添加一个元素 this.dequeue = dequeue; //队首删除一个元素 this.front = front; //读取队首元素 this.back = back; //读取队尾元素 this.toStringData = toStringData; //显示队内元素 this.isEmpty = isEmpty; //判断队列是否为空&#125; 2、使用enqueue()方法，在队尾添加一个元素，如下：123function enqueue(element) &#123; this.data.push(element);&#125; 3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下：123function dequeue() &#123; return this.data.shift();&#125; 4、使用front()方法，返回队首元素，如下：123456789 function front() &#123; return this.data[0]; &#125;```JavaScript###### 5、使用back()方法，返回队尾元素，如下：```JavaScript function back() &#123; return this.data[this.data.length - 1]; &#125; 6、使用toStringData()方法，返回队列元素，如下：12345678function toStringData() &#123; let queueString = ''; for (let i = 0; i &lt; this.data.length; i++) &#123; queueString += this.data[i] + '\n'; &#125; return queueString;&#125; 7、使用isEmpty()方法，判断队列是否为空，如下：123function isEmpty() &#123; return this.data.length === 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，就使用js实现了一个单向队列。 实例1、使用队列进行排序（基数排序）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍下什么是基数排序，基数排序又叫分配式排序或桶子法，它是通过数据的部分信息，将要排序的元素分配至桶中，以达到排序的作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一串数值，如下所示： 98、25、31、10、99、81、65、42、51 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：123456789100： 101： 31 81 512： 423：4：5： 25 656：7：8： 989： 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些桶子中的数值串接起来，如下所示：110 31 81 51 42 25 65 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着根据十位数在进行一次分配，如下所示：123456789100：1： 102： 253： 314： 425： 516： 657：8： 819： 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些数值串接起来，形成以下数值：110 25 31 42 51 65 81 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候排序已经完成；如果有三位数或这更高位数，则持续进行以上动作，直至最高位为止。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使用队列的思想进行排序呢？假设是0～99间的数进行比较，首先需要比较个位数，因为数值在0～99之间，只需对数进行取余,即可得到个位数，对数值除以10，向下取整可得到十位数。到这儿开始使用队列(桶)进行存值，需要是个队列分别存储0～9的值。如下：123456789101112131415/** * @param nums 初始数组 * @param queue 队列数组 * @param n 几位数 * @param digit 个位数或十位以上的数 * */function distribute (nums, queue, n, digit) &#123; for (let i = 0; i &lt; n; i++) &#123; if (digit === 1) &#123; queue[nums[i] % 10].enqueue(nums[I]); &#125; else &#123; queue[Math.floor(nums[i] / 10)].enqueue(nums[I]); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序后展示函数，如下：12345678910111213/** * @param queues 队列数组 * @nums nums 初始数组 * */function showAfterData (queues, nums) &#123; let i = 0; for (let digit = 0; digit &lt; 10; ++digit) &#123; while (!queues[digit].isEmpty()) &#123; nums[i++] = queues[digit].dequeue(); &#125; &#125; return nums;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成算法后，随机来点数实验下，如下：123456789101112131415let queues = [];for (let i = 0; i &lt; 10; ++i) &#123; queues[i] = new Queue();&#125;let nums = [];for (let i = 0; i &lt; 10; ++i) &#123; nums[i] = Math.floor(Math.floor(Math.random() * 101));&#125;console.log('个位数排序：');distribute(nums, queues, 10, 1);console.log(collect(queues, nums));console.log('十位数排序：');distribute(nums, queues, 10, 10);console.log(collect(queues, nums)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果如下： 双向队列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双向队列即队列的首尾都能进能出，那么只需在单向队列中添加两个方法，队首添加一个元素方法(fenqueue)，队尾删除一个元素的方法(‘bdequeue’),即可.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列的构造函数添加两个方法，如下：12345678910111213141516171819 function Queue() &#123; this.data = []; this.enqueue = enqueue; //队尾添加一个元素 this.dequeue = dequeue; //队首删除一个元素 `this.fenqueue = fenqueue; //队首添加一个元素` `this.bdequeue = bdequeue; //队尾删除一个元素` this.front = front; //读取队首元素 this.back = back; //读取队尾元素 this.toStringData = toStringData; //显示队内元素 this.isEmpty = isEmpty; //判断队列是否为空 &#125;function fenqueue (element) &#123; this.data.unshift(element);&#125;function bdequeue () &#123; return this.data.pop();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就完成了双向队列。双向队列能实现什么功能呢？如回文之类的使用双向队列能很方便的实现，思想如上一片文章中的栈，使用双向队列无论从前还是后插入数据，都一个原理。]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-数据结构-栈]]></title>
    <url>%2F2018%2F12%2F17%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做前端已有几年的时间，各种前端技术学了一堆，换着技术开发网站，感觉自己很牛逼的样子。这段时间总感觉到达了瓶颈，怎么也突破不了，冷静想了下。功能的实现、封装什么都没问题，但是就是算法差强人意。把大学的数据结构拿出来翻了下，这阶段再去看算法，比大学期间清楚太多了，很多原来知道有那回事儿，现在能明白用途在什么地方。我想我找到了突破瓶颈的方式了。从这篇文章开始，我会陆续的把数据结构中的算法用原生js实现。 栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈是一种数据结构，栈只有一个入口和一个出口，它的特点是LIFO(后入先出)，即比如我们吃的罐装薯片，只有从顶部一片一片的拿出来，才能拿到底部。因为栈的LIFO的特点，所有任何不在栈顶元素都无法访问到，为了得到栈底元素，必须把上面的元素都拿走，才能访问。而栈是一种列表，在js中，可以通过数据的方式来存储。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这儿便有思路了，首先需要一个data存储数据，data是一个数组，因栈只能访问栈顶元素，需要一个变量top存储栈顶元素的位置，当入栈时top + 1,当出栈时，top - 1，那么入栈需要一个方法s_push,出栈需要一个方法s_pop，还需返回栈顶元素的方法s_peek。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，需要清空栈、获取栈的长度或判断元素是否在栈内，以上方法是不够的，还需创建方法，s_clear(清空栈内元素)、s_length(获取栈的长度）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 首先，需要创建一个Stack类的构造函数，如下：123456789function Stack () &#123; this.s_top = 0; //初始化栈顶位置为0 this.s_data = []; //初始化空栈 this.s_push = s_push; //入栈方法 this.s_pop = s_pop; //出栈 this.s_peek = s_peek; //获取栈顶元素 this.s_length = s_length; //栈的长度 this.s_clear = s_clear; //清空栈&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 入栈，实现s_push方法，当向栈中压入新元素时，需要改变s_top对应栈的位置加1，然后指向数组下一个空位置。如下：123function s_push (element) &#123; this.s_data[this.s_top++] = element;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 出栈，s_pop方法和入栈相仿，每次取出元素后，将s_top - 1，然后返回当前删除的值，如下：1234function s_pop () &#123; --this.s_top; return this.s_data.pop();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 获取栈顶元素，s_peek方法，栈顶的位置为s_top,只需要数组中取最后一个元素即可，如下：123function s_peek () &#123; return this.s_data[this.s_top - 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 清空栈，s_clear方法，设置栈顶指向为0，清空存储数据，代码如下：1234function s_clear () &#123; this.s_top = 0; this.s_data = [];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 获取栈的长度，s_length, 即s_top的值，如下：123function s_length () &#123; return this.s_top;&#125; 实例1. 使用栈模拟递归&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如需要封装一个阶乘的函数，用递归的思想，如下：12345678function factorial (num) &#123; if (typeof num !== 'number') return num; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果用栈的方式如何处理呢？只需将给定的数递减到1入栈，然后每次s_pop的时候会返回栈顶元素，循环栈，然后将s_pop的值相乘即可，如下：1234567891011121314151617function factorial (num) &#123; if (typeof num !== 'number') return num; let s = new Stack(), facNum = 1; //入栈 while (num &gt; 0) &#123; s.s_push(num--); &#125; //出栈 while (s.s_length() &gt; 0) &#123; facNum *= s.s_pop(); &#125; return facNum;&#125; 2. 判断回文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说下什么是回文，把相同的字符串或句子颠倒过来，产生首尾循环的句子，意思就是正序和倒叙的结果一样。如何使用栈的思想实现回文呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈的方法有一个pop操作，每次pop返回栈顶元素。那么可以将字符串先push进栈，然后pop即可得到一个逆序的字符串，比较是否相等即可，如下：1234567891011121314function isPalindrome (str) &#123; const s = new Stack(); let reverseStr = ''; for (let i = 0; i &lt; str.length; i++) &#123; s.s_push(str[i]); &#125; while (s.s_length() &gt; 0) &#123; reverseStr += s.s_pop(); &#125; return reverseStr === str;&#125; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用栈的思想可以很方便的实现很多功能，比如判断表达式是否括号匹配等？不过说实话，在前端页面的开发中，用不到这些。有兴趣可以玩下，可以提升思维逻辑。]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-in-js框架style-components]]></title>
    <url>%2F2018%2F11%2F27%2Freact%2Fstyle-component%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端飞一般的发展中，衍生出各式各样的框架，框架的目的是减轻开发人员的开发难度，提高效率。以前网页开发的原则是关注点分离，意思是各种技术只负责自己的领域，不要混合在一起，形成耦合。如html、css、js代码分离。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React的出现，这个原则不在实用，React是组件结构，强制把html、css、js写在一起。如：12345678910111213const style = &#123; 'color': 'red', 'fontSize': '46px'&#125;;const clickHandler = () =&gt; alert('hi');ReactDOM.render( &lt;h1 style=&#123;style&#125; onclick=&#123;clickHandler&#125;&gt; Hello, world! &lt;/h1&gt;, document.getElementById('example')); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在一个js文件里，封装了结构、样式、逻辑，完全违背了关注点分离，很多人刚开始学习React很不适应，但是，这有利于组件的隔离，每个组件需要的代码不依赖于外部、组件之间没有耦合，方便复用。使用React的越来越多，组件模式深入人心，这种关注点混合的新写法逐渐成为主流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表面上，React的写法是html、css、js混合写在一起，实际上是用js在写html、css。React对html的封装是jsx，那么对css的封装是什么呢？这就涉及到今天需要讲的内容style-components。 什么是style-components&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components是针对React写的一套css in js框架，简单来讲就是在js中写css。相对于与预处理器(sass、less)的好处是，css in js使用的是js语法，不用重新再学习新技术，也不会多一道编译步骤。无疑会加快网页速度。如果有sass或less的开发经验，几分钟就可以学会style-components。 官方文档https://www.styled-components.com/docs/basics 1. 安装npm install --save style-components 2. 基础用法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components最基础的用法就是以组件的形式编写样式，如下：123456789101112131415161718192021222324252627282930313233343536import styled from 'styled-components';const HomeWrapper = styled.div ` width: 960px; margin: 0 auto; overflow: hidden;`;const HomeLeft = styled.div ` float: left; width: 625px; margin-left: 15px; padding-top: 30px; .bannder-img &#123; width: 625px; height: 270px; &#125;`;const HomeRight = styled.div ` float: right; width: 280px; margin-left: 15px; padding-top: 30px;`;render () &#123; return ( &lt;HomeWrapper&gt; &lt;HomeLeft&gt; left &lt;/HomeLeft&gt; &lt;HomeRight&gt; right &lt;/HomeRight&gt; &lt;/HomeWrapper&gt; )&#125; 上面的代码定义了三个组件，分别为HomeWrapper 、HomeLeft 、HomeRight，这样每一个组件对应唯一的样式，不在出现样式污染的情况。 2. 全局样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个组件对应唯一的样式，那么需要设置全局样式怎么办呢？style-components的最新版提供了createGlobalStyle可以设置全局样式，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import &#123; createGlobalStyle &#125; from 'styled-components';const GrobalStyle = createGlobalStyle ` html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125; /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125; body &#123; line-height: 1; &#125; ol, ul &#123; list-style: none; &#125; blockquote, q &#123; quotes: none; &#125; blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; @font-face &#123; font-family: 'iconfont'; /* project id 897264 */ src: url('//at.alicdn.com/t/font_897264_7ma62sn10m3.eot'); src: url('//at.alicdn.com/t/font_897264_7ma62sn10m3.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.woff') format('woff'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.ttf') format('truetype'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.svg#iconfont') format('svg'); &#125; .iconfont &#123; font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; .clearfix:after &#123;visibility: hidden;display: block;font-size: 0;content: ".";clear: both;height: 0;&#125; .clearfix &#123;zoom: 1;&#125;`;render() &#123; return ( &lt;Fragment&gt; &lt;Provider&gt;...&lt;/Provider&gt; &lt;GrobalStyle/&gt; &lt;/Fragment&gt; )&#125; 上面的代码GrobalStyle是全局样式组件，只需在React组件的最外层引入即可。 3. 图片引入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要图片引入，如果像css一样的引入方式，会报错。正确的引入方式是import导入，再以变量的方式引入，如下：123456789101112import styled from 'styled-components';import logPic from '../../statics/images/logo.png';export const Logo = styled.div ` position: absolute; top: 0; left: 0; width: 100px; height: 56px; background-image: url($&#123;logPic&#125;); background-size: contain;`; 上面的代码logPic是存放logo图片地址的变量，只需使用${logPic}的方式引入即可。如果是后台传过来的图片，如何使用的背景图呢？ 4. props&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面提到的问题，可使用组件的传值。先看一个例子：12345678910recommendList.map((item) =&gt; &#123; return &lt;RecommendItem key=&#123;item&#125; imgUrl=&#123;item&#125;/&gt;&#125;)const RecommendItem = styled.div ` width: 280px; height: 50px; background-image: url($&#123;(props) =&gt; props.imgUrl&#125;); background-size: contain;`; 从上面的例子，不难发现，父组件传入的值，会存放在子组件的props中，故操作props便能得到预期效果。 5. 标签属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用style-components，需要使用标签属性，如input 的placeholder，a标签的href等，style-components提供了属性attrs，如下：123456789101112131415161718192021export const NavSearch = styled.input.attrs(&#123; placeholder: '搜索'， type: 'text'&#125;) ` width: 160px; height: 38px; margin-top: 9px; padding: 0 40px 0 20px; box-sizing: border-box; background-color: #eee; outline: none; border: none; border-radius: 19px; color: #666; &amp;::placeholder &#123; color: #999; &#125; &amp;.focused &#123; width: 240px; &#125;`; 上面的代码，attrs里面是一个对象，如果需要多个属性，以对象的形式添加即可。 6. 塑造组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种情况，一些原本就已经是组件，需要给这些组件添加样式，这时需要用到塑造组件，如下：123456789101112131415const Link = (&#123;className , children&#125;) =&gt; ( &lt;a className=&#123;className&#125;&gt; &#123;children&#125; &lt;/a&gt;)const StyledLink = styled(Link)` color: palevioletred;`render( &lt;div&gt; &lt;Link&gt;普通组件&lt;/Link&gt; &lt;StyledLink&gt;添加了样式的组件&lt;/StyledLink&gt; &lt;/div&gt;); 7. 继承&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某一组件的样式会用到多个地方，不能每个地方都重新写一套样式，这样代码不够优雅。比如：一个button，有warning、有default、有primary等，这个button只是颜色不同，其他样式一样，这里便可用到继承。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 const Button = styled.button` line-height: 1.499; display: inline-block; font-weight: 400; text-align: center; -ms-touch-action: manipulation; touch-action: manipulation; cursor: pointer; background-image: none; border: 1px solid transparent; white-space: nowrap; padding: 0 15px; font-size: 14px; border-radius: 4px; height: 32px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-transition: all .3s cubic-bezier(.645,.045,.355,1); transition: all .3s cubic-bezier(.645,.045,.355,1); position: relative; -webkit-box-shadow: 0 2px 0 rgba(0,0,0,.015); box-shadow: 0 2px 0 rgba(0,0,0,.015); color: rgba(0,0,0,.65); background-color: #fff; border-color: #d9d9d9; `; const ButtonPrimary = styled(Button)` color: #fff; background-color: #1890ff; border-color: #1890ff; `; const ButtonWarning = styled(Button)` color: #f5222d; background-color: #f5f5f5; border-color: #d9d9d9; `;```javascript有人说，公用样式的组件完全可以写到全部样式里面，设置不同的class。这样做可行，但是为什么不直接去写css呢？###### 8. 动画&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上有这样一个例子，如下：```javascript const rotate = keyframes` from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; `; const Rotate = styled.div` display: inline-block; animation: $&#123;rotate&#125; 2s linear infinite; padding: 2rem 1rem; font-size: 1.2rem; `; render( &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt; ); 个人觉得，如果是简单的动画，直接以这样的方式去做，即可，如果动画比较复杂，建议使用react-transition-group框架有更好的体验。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components的常用用法介绍完成，当然官网上还有一些其他的用法，有兴趣可以了解下。使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度，期待下一版能解决这个问题。]]></content>
      <categories>
        <category>style-components</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux管理状态-todoList实现]]></title>
    <url>%2F2018%2F11%2F23%2Freact%2FRedux%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81-todoList%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[初衷&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux的学习，让人又爱又狠，爱它状态管理的便捷，恨它的文档让人一脸懵逼。总之学习Redux的过程痛并快乐着。为什么要些这篇文章？经历了从Redux文档一步一步爬过来，踩了无数地雷，死了无数脑细胞，连亲爱的头发也一天天离我远去，终于神功大成…。话说当年，文档已烂熟于心，本以为从此React江湖任我游，不想，刚出门就差点撞死在Action的门口；好不容易，将货(data),开着兰博基尼(dispatch)送到了仓库(store),不曾想，一堆相同的烂货(initState),陈列在仓库，散发着腐朽的味道，苍蝇呜呜呜的拍打着翅膀，仿佛在嘲笑着傻逼傻逼。拖着疲惫的步伐将货更换完成(reducer),开心的骑着电动小马达，越行越远…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文章的目的为了记录学习新技术的心路历程，以及对当前学习技术的一个总结。顺便带着，如果正在学习，正在看的你有一点点帮助，那么人生便已圆满，废话已经写了这么多，如果不喜欢，欢迎来喷。一直坚信，做技术的，如果不在被喷中成长，就在喷子的口水中变成泼妇。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章讲到使用react实现todoList,使用react做一些简单的页面交互可行，如果页面上的功能比较复杂，多组件之间的交互频繁，只是用react会使整个程序变得非常复杂，不利于维护，可能做到后面自己都不清楚数据是怎么走向的。怎么办呢？2014年Facebook就提出了Flux架构的概念，引发了一系列的实现。2015年，Redux的出现，将Flux与函数式变成结合在一起，很快就成为了前端的热门框架。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux是什么，其实Redux就是React的状态管理工具，当然React状态管理工具不止Redux，比如Mobx等，个人觉得使用Mobx更简单，本文主要介绍如何使用Redux一步一步使用页面功能开发。文章中会简单如何使用阿里的ReactUI组件antd。本文主要讲如何使用Redux管理React的状态，不会涉及太多的原理，想看原理，为啥不直接到官网去，带图的、彩色的、各国的都有，看的你不能自我、欲罢不能。 一、准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脚手架使用create-react-app, 不清楚如何安装，请看上一篇文章React的增删功能-todoList实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Redux: npm install -S redux 二、Redux知识总览&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux管理React状态的步骤。Action描述事件简单对象，它是改变store中state的唯一方法，通过store.dispatch()方法将Action传到store中。Action的作用只是传递数据，并没有更新数据，如何更新数据Reducer的工作。Reducer接收到Action传入的对应数据，更新数据后返回到store，更新页面。简化来讲，用户触发事件 -&gt;action(dispatch分发) -&gt; store -&gt; Reducer更新数据 -&gt; 返回更新后的数据到store -&gt; 更新页面。如下图： 三、Redux实现TodoList1. Action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action是把数据从应用传到store的有效载荷，它是store的唯一来源。通过store.dispatch()将数据传到store。Action是一个对象，里面必须有属性type,type是一个常量,type的作用是数据在Reducer中对应匹配数据使用。在这里我们可以思考下每一个Action都会有对应的type，那么一个网站必然会有很多的type，便于后期维护，最好把type放到统一的文件夹中进行管理。 Action是一个对象，type表示Action的名称。1234&#123; type: INIT_LIST, payload: data&#125; 上面的代码，Action的名称是INIT_LIST,它携带的信息是data数据。 2. Action Creator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View要发多少种信息，就会有多少个Action，如果每个都要写，那么会很麻烦，也不利于维护。使用ActionCreator.js统一管理所有的Action。同时Action的名称type，统一使用ActionTypes.js管理。名称可以随便取，不做强求。12345const INIT_LIST = 'init_list';export const initListAction = (data) =&gt; (&#123; type: INIT_LIST, data&#125;); 上面的代码initListAction函数就是一个Action。 3. store.dispatch()store.dispatch()是View发出Action的唯一方法。1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: INIT_LIST, data: 'test'&#125;); 上面的代码，store.dispatch接收一个Action对象作为参数，发送给store。结合initListAction，可改写成：1store.dispatch(initListAction(data)); 4. Reducer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store收到Action后，必须给出新的state，这样View才能发生变化，计算state的过程交Reducer。Reducer是一个纯函数，即有什么样的输入就有什么样的输出。Reducer的写法如下：1234567891011121314151617181920212223242526272829import &#123; CHANGE_INPUT_VALUE, SUBMIT_BTN_ITEM, DELETE_ITEM, INIT_LIST &#125; from '../actions/types'const initialList = &#123; inputValue: '', list: []&#125;;const reducerList = (state = initialList, action) =&gt; &#123; switch (action.type) &#123; case CHANGE_INPUT_VALUE: const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.inputValue; return newState; case SUBMIT_BTN_ITEM: const submitState = JSON.parse(JSON.stringify(state)); console.log(submitState); submitState.list.push(submitState.inputValue); submitState.inputValue = ''; return submitState; case DELETE_ITEM: const deleteState = JSON.parse(JSON.stringify(state)); deleteState.list.splice(action.index); return deleteState; case INIT_LIST: const initState = JSON.parse(JSON.stringify(state)); initState.list = action.data; return initState; default: return state; &#125;&#125;; export default reducerList; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，type放在公用的文件夹中管理，Action的type和Reduce的type必须一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因会有很多Action，故使用switch的方式。如果case下面的数据比较复杂，可以单独提出来进行处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newState = JSON.parse(JSON.stringify(state));这句话的作用是深拷贝，目的是如果直接操作state,会影响其他View的数据。 5. Store&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store是保存数据的地方，整个应用只有一个Store。Redux提供了createStore函数来生成Store。12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面的代码，createStore接收另外一个函数作为参数，返回新生成的Store对象。 6. store.subscribe()store.subscribe()是Store的监听函数，一旦state改变，就会自动执行这个函数。12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); store.subscribe(listener); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，只要把View的更新数据替换上面的listener,当state改变时，就能更新数据。绑定事件监听，完成后需要解除事件，只需执行listener就会自动解除监听。 7. store.getState&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在View中需要使用state中的数据，使用store.getState获取store中state数据，展示到页面即可。123import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.getState(state); 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面介绍了Redux一些基础的使用方法，一个完整的项目使用这样的方法，会比较繁琐，那么怎么办呢？下一节会讲到，中间键redux-saga、redux-thunk和异步的使用方法，同时会讲到antd UI组建的使用。想看源码请狠狠的点击这里。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-自定义滚动条]]></title>
    <url>%2F2018%2F11%2F22%2Fcss%2Fcss-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[1. 初衷 做了几年的前端了，做笔记都是在自己的网盘里面记录，每次翻原来的笔记，总感觉差了点什么，突然有一天，一声惊雷闪过，文字依旧是那点文字，读者只有唯一，为什么不能分享出来，分享踩过的坑，希望能帮助到正在看的你。 2.为什么要自定义滚动条？一直觉得，滚动条用默认的就好了，没特殊需求为啥要自定义呢？之前做过一个自定义表格，功能有：超出一定的高度滚动起来，表头固定，没列有自定义右键菜单，如下：最近入手一台Mac，再看原来的代码，Mac竟然如此神奇，滚动条不占位置，还会显示隐藏，而我自定义的表格在Mac端出问题，因为表格自定义，使用的ul、li模拟的表格，滚动条在windows端占位，到Mac端不占位了，故出现表头和内容不对齐情况，如下：图中是有滚动条的，因Mac默认隐藏，故滚动条的17px导致错行。 3. 实现Mac端滚动条兼容 要做到同时兼容windows和Mac，那么可以自定义滚动条，做法很简单，在全局的css样式中加入下面代码即可： 12345678910111213//自动移滚动条样式::-webkit-scrollbar&#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-thumb&#123; border-radius: 1em; background-color: rgba(50,50,50,.3);&#125;::-webkit-scrollbar-track&#123; border-radius: 1em; background-color: rgba(50,50,50,.1);&#125; 1、::-webkit-scrollbar 定义了滚动条整体的样式；2、::-webkit-scrollbar-thumb 滑块部分；3、::-webkit-scrollbar-thumb 轨道部分； 加上这个代码，在看下效果，自定义表格完美兼容Mac。 自定义滚动条有很多方式，这里只是展示了个人觉得比较简单的，还有很多插件可以实现，有兴趣的朋友可以自己玩一下。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-todoList实现]]></title>
    <url>%2F2018%2F11%2F13%2Freact%2Freact-todoList%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[React作为当前最火的框架之一，学习和使用已有一段时间，在这里记录下学习React的心得，纯属个人观点。在学习React之前，了解过Vue,和angular，个人比较喜欢React的开发模式，之前的开发用的比较多jquery的模板（artTemplate,hogan）之类的，和React中的jsx原理类似，因此被吸引。 一、 React的准备工作 学习react有很多途径，可以看官网，可以看博客，可以看视频，这里比较推荐的做法是先看官网，了解基本知识后，做一些例子。然后再学习相关依赖，如Redux、Mobx之类的状态管理工具，之后的文章中会进一步讲解React相关依赖，有：Redux、Mobx、Redux-thunk、Redux-saga、immutable、react-transition-group、antd、styled-components、prop-types等。 开始学习React需要一定的开发基础，如：Es6、webpack等。我学习React使用的是create-react-app脚手架， 安装：npm install -g create-react-app创建React应用： create-react-app my-app$ create-react-app my-app Creating a new React app in G:\GitHub\React-demo\my-app. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts... 1、主要依赖react,react-dom,react-scripts2、目录结构 3、运行 npm start4、打包 npm run build二、正式开发1、使用react做一个输入框，点击提交在下面列表展示，点击对应的列表项，删除该项，如下： 2、项目的数据结构，首先分析需求，一个input框，一个button，一个列表。可以把input和button看成一个组件，列表看成一个组件。在state中的数据结构可以设置为：12345//state的数据结构this.state = &#123; inputValue: '', //用于存放input的值 list: [] //存放列表的值&#125; input框功能实现，原理：input框绑定onChange事件，每当输入字符时，改变this.state.inputValue的值，React中当state或props中的值改变，render函数会重新执行。实现如下： 123456789101112131415161718192021222324252627//方法一：改变this.state.inputValue值，通过事件返回的e.target.value,获取输入框中的值&lt;input type="text" onChange=&#123;this.handleChange&#125; value=&#123;this.state.inputValue&#125; /&gt;handleChange (e) &#123; //同步setState this.setState(&#123; inputValue: e.target.value &#125;);&#125;//方法二：在input框上设置ref属性，ref表示对组件真正实例的引用。//设置ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125;表示，将当前input框中的value值，//绑定到this上，在handleChange方法中，便可以直接取input的值：this.input.value&lt;input type="text" id="inputValue" onChange=&#123;this.handleChange&#125; value=&#123;this.state.inputValue&#125; ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125;/&gt;handleChange (e) &#123; const value = this.input.value; //异步setState，可以为异步方法，带有一个参数prevState,即为上一步state的内容，同时带有回调函数 this.setState(() =&gt; (&#123; inputValue: value &#125;), () =&gt; &#123; console.log('赋值完成！'); &#125;);&#125; 提交功能实现，原理：很容易就想到，当点击提交的时候，将input框中的值push到this.state.list即可。 12345678910&lt;button onClick=&#123;this.handleSubmit&#125;&gt;提交&lt;/button&gt;//提交添加UI列表handleSubmit () &#123; this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue], inputValue: '' &#125;), () =&gt; &#123; //回调函数 console.log(this.ul.querySelectorAll('li').length); &#125;);&#125; 将list的值在页面展示出来,可以通过map方法，循环li。 12345678this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;)/* 注：react中循环的时候，必须在每一项加上key的属性，不然控制台会报错， 原因是：diff算法在循环的时候,会去匹配对应的key值。此处用index作为key值是不合理的做法，key值应该是唯一的， diff算法后面会详细讲到。*/ 点击li，删除当前li,原理：每一个li都有对应的index，点击li时，获取index，在list找到对应下标，然后delete即可。 12345678910111213this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125; onClick=&#123;this.handleDeleteItem.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;)//删除当前点击itemhandleDelete (index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list: list &#125; &#125;);&#125; 三、总结React的原理 1. state改变 2. jsx模板 3. 数据 + 模板 生成虚拟dom（虚拟DOM就是一个js对象，用来描述真实的DOM）（损耗了性能） 4. 用虚拟DOM结构生成真实的DOM，来显示 5. state改变 6. 数据 + 模板 生成新的虚拟DOM（极大的提升了性能） 7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到区别（diff算法） 8. 直接操作DOM，改变不同之处 Diff算法 1. 同层对比（变化前和变化后，虚拟DOM同一级进行对比） 2. 列表（每个循环的列表都需要一个唯一的key，用于做对比，节约性能，因此用循环的index作为key是不靠谱的做法，浪费性能） 3. 组件（一个React的APP有多个组件进行组成，diff对比组件的class） 4. 绘制 1). 当调用setState时，React将其标记为Dirty，然后事件轮询介绍时，React会查询dirty组件并重新绘制 2). 当组件的setState方法被调用，组件会重新绘制它的子组件 5. react事件委托（通过事件冒泡至document处，合成对象(SyntheticEvent)，当触发事件时，通过dispatchEvent分发函数分发） 生命周期函数（在某一时刻组件会自动执行调用的函数） 1. initialization (constructor) 初始化 2. Mounting (组件第一次挂载的流程) 1). componentWillMount 在组件即将被挂载到页面的时刻执行，即render前执行 2). render 3). componentDidMount 在组件挂载到页面的时刻执行 3. Updation 1). componentWillReceiveProps 从父组件接收参数并且这个组件在之前就存在父组件中 （props） 2). shouldComponentUpdate 在更新前调用，如果该组件返回true,往下执行，否则停止 3). componentWillUpdate 在更新前调用，shouldComponentUpdate返回true之后 4). render 5). componentDidUpdate 更新之后调用 4. Unmounting 1). componentWillUnmount 即将被页面移除的时候执行 结束本文使用react做了一个添加删除的功能，代码已放在GitHub上，有兴趣请狠狠的点击这儿。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE下input框后面默认带有X，去除方法]]></title>
    <url>%2F2018%2F09%2F12%2Fcss%2FIE%E4%B8%8Binput%E6%A1%86%E5%90%8E%E9%9D%A2%E9%BB%98%E8%AE%A4%E5%B8%A6%E6%9C%89X%EF%BC%8C%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在IE9下，input框带有X,如何去除？ 去除IE下input带x的方法，很简单，只需要css中加一句话就行了1234//去除IE下input框后面的Xinput::-ms-clear, input::-ms-reveal&#123; display: none;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义鼠标右键]]></title>
    <url>%2F2018%2F09%2F11%2FjQuery%2FjQuery-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%2F</url>
    <content type="text"><![CDATA[一、自定义鼠标右键的实现原理 自定义右键菜单功能，需清楚，所有浏览器都自带了右键功能，那么自定义右键菜单，需要先屏蔽系统自带的右键功能，如何实现呢？123$selector.on('contextmenu', '.box', function () &#123; return false;&#125;) 注：$selector为选择器，.box为禁用鼠标右键的class完成系统自带鼠标右键的禁用后，开始自定义鼠标右键。 获取鼠标事件的方法，使用mousedown,获取后需区分是鼠标左键还是右键，事件返回的参数event中，event.which为3表示右键，为1表示左键，为2表示中键。如下：12345678910$("#box").mousedown(function(e)&#123; if(3 === e.which)&#123; alert("这 是右键单击事件"); &#125;else if(1 === e.which)&#123; alert("这 是左键单击事件"); &#125; else if (2 === e.which) &#123; alert("这是鼠标中键"); &#125; &#125;) 二、自定义鼠标右键实例（表格行右键自定菜单）html:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 &lt;div class="box"&gt; &lt;div class="table-list"&gt; &lt;div class="table-thead "&gt; &lt;ul class="table-col"&gt; &lt;li class="save-item" title="名称"&gt; &lt;span&gt;名称&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="类型"&gt; &lt;span&gt;类型&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="数据"&gt; &lt;span&gt;数据&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;span&gt;操作&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="table-tbody"&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118* &#123; border: none; margin: 0; padding: 0;&#125;ul, ul li, ol li, li &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;.none &#123; display: none;&#125;.box &#123; width: 1000px; margin: 20px 50px;&#125;/* 自定义table */.table-list &#123; width: 100%;&#125;.table-list .table-tbody &#123; position: relative; max-height: 350px; min-height: 225px;&#125;.table-list .table-thead ul &#123; background-color: #f5f5f5;&#125;.table-thead &gt; ul li &#123; font-weight: bold !important;&#125;.table-tbody &gt; ul &#123; margin-top: -1px; position: relative; cursor: pointer;&#125;.table-tbody &gt; ul:hover &#123; background-color: #f5f5f5;&#125;.table-thead, .table-tbody &#123; width: 100%;&#125;.table-thead &gt; ul, .table-tbody &gt; ul&#123; display: flex;&#125;.table-thead &gt; ul &gt; li, .table-tbody &gt; ul &gt; li &#123; flex: 1; height: 36px; font: normal 12px/36px 'Microsoft YaHei', 'Arial'; border: 1px solid #d9d9d9; border-left: none;&#125;.table-thead &gt; ul &gt; li:first-child, .table-tbody &gt; ul &gt; li:first-child &#123; border-left: 1px solid #d9d9d9;&#125;.table-thead &gt; ul &gt; li &gt; span, .table-tbody &gt; ul &gt; li &gt; span &#123; width: 90%; display: inline-block; margin: 0 10px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;/* 下拉 */.oprate-dropdown &#123; position: absolute; top: 28px; right: 3px; width: 90px; border: 1px solid #d9d9d9; box-shadow: 0 0 5px #ccc; z-index: 100; /* 禁用选择字体 */ -moz-user-select: none; /*火狐*/ -webkit-user-select: none; /*webkit浏览器*/ -ms-user-select: none; /*IE10*/ user-select: none;&#125;.oprate-dropdown li.op-item &#123; width: 100%; height: 32px; background-color: #fff;&#125;.oprate-dropdown li.op-item:hover &#123; background-color: #f2f3f6;&#125;.oprate-dropdown li.op-item a &#123; display: inline-block; width: 70px; line-height: 32px; border-bottom: 1px solid #d9d9d9; color: #2a313f; margin: 0 10px; overflow: hidden;&#125;.oprate-dropdown li.op-item .op-icon &#123; position: relative; left: 0; top: 5px; display: inline-block; width: 15px; height: 20px;&#125;.point-icon &#123; display: inline-block; width: 20px; height: 15px; background: url(../image/point-icon.png) no-repeat; background-position: 0 10px; cursor: pointer; margin-left: 10px;&#125; js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var _rightMenu = &#123; init: function () &#123; var _this = this; _this.rightMenuOprate(); &#125;, rightMenuOprate: function () &#123; var $searchPart = $('.box'); //操作点击下拉 $searchPart.on('click', '.opratePointDrop', function (e) &#123; e.stopPropagation(); var $this = $(this), _isOpen = $this.attr('data-toggle'), $dropDown = $this.next(); //清空所有显示下拉 $searchPart.find('.opDropDown').each(function () &#123; var $this = $(this); $this.hide(); $this.prev().attr('data-toggle', 'close'); &#125;); if (_isOpen === 'close') &#123; $dropDown.show().css('left', ''); $this.attr('data-toggle', 'open') &#125; else if (_isOpen === 'open') &#123; $dropDown.hide(); $this.attr('data-toggle', 'close') &#125; &#125;); //禁止鼠标右键事件 $searchPart.on('contextmenu', '.saveCol', function () &#123; return false; &#125;); //鼠标右键 $searchPart.on('mousedown', '.saveCol', function (e) &#123; e.stopPropagation(); var $this = $(this); if (3 === e.which) &#123; //隐藏其他展开的下拉 $searchPart.find('.opDropDown').each(function () &#123; var $this = $(this); $this.hide(); $this.prev().attr('data-toggle', 'close'); &#125;); $this.find('.opDropDown').show().css(&#123; 'left': e.pageX - 50 + 'px' &#125;); &#125; &#125;); //点击清除 $(document).click(function (e) &#123; //兼容火狐 if (1 === e.which) &#123; $searchPart.find('.opratePointDrop').attr('data-toggle', 'close'); $searchPart.find('.opDropDown').hide(); &#125; &#125;); &#125;&#125;;$(function () &#123; _rightMenu.init();&#125;);]]></content>
      <categories>
        <category>jQuery自定义功能</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
