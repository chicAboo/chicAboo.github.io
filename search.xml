<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mulselect]]></title>
    <url>%2F2019%2F03%2F12%2FjQuery%2FMulselect%2F</url>
    <content type="text"><![CDATA[下拉多选-Mulselect自定义封装分析自定义下拉多选封装，首先分下，一个完整的自定义下拉的组成部分： 有个显示框，显示选中能容 有一个新增字段部分，包括一个输入框，一个新增按钮，不能新增重复名称，则需验证信息部分 下拉列表部分，左侧为复选框，右侧为字段名称 已经拆分完一个组件，只需按照功能要求组合起来，便完成一大部分了。假设UI已经完成，现在分析逻辑： 实现方式：构造函数+原型链 创建一个Mulselect原型方法create，新增UI 创建一个方法checkedItem，绑定Mulselect的事件，选中、全选、反选 创建一个方法checkedStatus，判断是否全部选中 创建一个方法getCheckedValue，获取选中的值 创建一个方法addItem，新增项 将创建好的对象绑定要window和jQuery上 逻辑部分已经思考完成，根据逻辑可以很明确的知道需要配合的参数有什么，有新增项功能、有选中、全选、反选功能、选中展示功能，可以分析如下参数： isShowAdd 是否显示新增部分 true为显示，默认为false isCheckAll 是否启用全选功能 true为启用全选，默认false showNumber 选中个数超过当前数显示显示个数 默认值为4 isOpen 是否默认展开列表 true为展开 默认为false selectAllText 选择所有的文本 默认’全选’ chooseText 请选择项文本 默认’请选择项’ noDataText 暂无数据文本 默认’暂无数据’ canNotSameName 不能添加同名字段默认文本 默认’不能添加同名字段默认文本’ data [{ name: ‘字段名称’, disable: ‘是否禁用选择’}] disable为’disable’表示禁用，其他不禁用 getCheckedValue(option, element) 选中回调 option为选中字段数组， element当前下拉多选DOM 创建构造函数首选需要创建构造函数，设置好默认字段，如下：12345678910111213141516171819function MulSelect(element, config) &#123; this.element = element; this.config = &#123; isShowAdd: false, //是否显示新增项 isCheckAll: false, //是否启用全选功能 showNumber: 4, //选中显示的个数 isOpen: false, //是否直接显示下拉 selectAllText: '全选', //全选默认文本 chooseText: '请选择值', //请选择值默认文本 noDataText: '暂无数据', //暂无数据默认文本 canNotSameName: '不能添加同名字段', //不能添加同名字段默认文本 data: [], //下拉数据 getCheckedValue: function () &#123;&#125;, //获取选中的值 &#125;; //扩展默认参数 if (config &amp;&amp; $.isPlainObject(config)) &#123; this.config = $.extend(&#123;&#125;, this.config, config); &#125;&#125; 创建Mulselect静态方法构造函数完成后，开始创建Mulselect静态页面，需要注意的是，因为设置了是否启用新增功能、是否启用全选功能，故这两个模块需要根据配置项判断是否启用，列表项需要传入的是数组，直接循环即可，具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869MulSelect.prototype.create = function () &#123; const _this = this, &#123; isShowAdd, data, isCheckAll, isOpen, selectAllText, chooseText, noDataText, &#125; = _this.config; let _html = ''; const checkAllDisable = data.filter(item =&gt; &#123; return item.disable.length === 0; &#125;).length === 0; _html += ` &lt;div class="mulselect"&gt; &lt;button type="button" class="mulselect-btn dropDownToggle" title="$&#123;chooseText&#125;" data-toggle="$&#123;isOpen ? 'open' : 'close'&#125;"&gt; &lt;span class="mulselect-text"&gt;$&#123;chooseText&#125;&lt;/span&gt; &lt;b class="caret"&gt;&lt;/b&gt; &lt;/button&gt; &lt;ul class="mulselect-list $&#123;isOpen ? '' : 'none'&#125;"&gt; `; //是否显示新增栏 if (isShowAdd) &#123; _html += ` &lt;li class="mulselect-item input"&gt; &lt;input type="text" value="" class="add-col" placeholder="请输入新增项"&gt; &lt;button class="btn btn-add"&gt;增加&lt;/button&gt; &lt;p class="red-font text-center none vilExpression"&gt;&lt;/p&gt; &lt;/li&gt; `; &#125; if (data.length &gt; 0) &#123; //是否显示全选 if (isCheckAll) &#123; _html += ` &lt;li class="mulselect-item checked-item $&#123;checkAllDisable ? 'disable' : ''&#125;"&gt; &lt;input type="checkbox" name="checkAll" data-type="checkAll"&gt; $&#123;selectAllText&#125; &lt;/li&gt; `; &#125; data.forEach(item =&gt; &#123; _html += ` &lt;li class="mulselect-item checked-item $&#123;item.disable&#125;" title="$&#123;item.name&#125;"&gt; &lt;input type="checkbox" value="$&#123;item.name&#125;" name="mulItem" data-type="item"&gt;$&#123;item.name&#125; &lt;/li&gt; `; &#125;); &#125; else &#123; _html += ` &lt;li class="mulselect-item text-center"&gt; &lt;span class="red-font"&gt;$&#123;noDataText&#125;&lt;/span&gt; &lt;/li&gt; `; &#125; _html += `&lt;/ul&gt;&lt;/div&gt;`; _this.element.html(_html);&#125; 创建显示隐藏列表方法完成Mulselect的静态页面创建，这里遇到个问题，需要隐藏和显示下拉多选列表，那么需要绑定显示框的点击事件，点击时判断显示和隐藏状态，如果列表展开状态，则隐藏，反之，则显示。需要注意的时，如果展开时，点击空白位置也需要隐藏，具体代码如下：123456789101112131415161718192021222324252627282930MulSelect.prototype.showList = function () &#123; const $selector = this.element; $selector.off('click').on('click', '.dropDownToggle', function (e) &#123; e.stopPropagation(); const $this = $(this), _toggle = $this.data('toggle'); $('.dropDownToggle').data('toggle', 'close'); $('.mulselect-list').hide(); if (_toggle === 'close') &#123; $this.data('toggle', 'open'); $this.addClass('active'); $selector.find('.mulselect-list').show(); &#125; else &#123; $this.data('toggle', 'close'); $this.removeClass('active'); $selector.find('.mulselect-list').hide(); &#125; &#125;); $selector.on('click', '.mulselect-list', function (e) &#123; e.stopPropagation(); e.preventDefault(); &#125;); $(document).on('click', function () &#123; $selector.find('.mulselect-list').hide(); $selector.find('.dropDownToggle').data('toggle', 'close').removeClass('active'); &#125;);&#125; 创建选中、全选、反选事件绑定方法因为使用CheckBox来做选中、全选、反选，则判断是否选中只需考虑CheckBox的checked是否为true，则能判断当前选中的状态；如果是全选和反选，则需要判断当点击全选时，当前列表的所有CheckBox的checked是否全为true，故还需要一个判断当前下拉多选列表是否全选的状态。是否全选状态代码如下：12345678910111213141516MulSelect.prototype.checkedStatus = function () &#123; let checkedArr = [], disableArr = []; this.element.find('input[name="mulItem"]').each(function () &#123; if ($(this).is(':checked')) &#123; checkedArr.push(1); &#125; if ($(this).parent().hasClass('disable')) &#123; disableArr.push(2); &#125; &#125;); return this.element.find('input[name="mulItem"]').length === checkedArr.length + disableArr.length;&#125; 选中、全选、反选代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748MulSelect.prototype.checkedItem = function () &#123; const _this = this, $selector = _this.element; this.element.on('click', 'input[type="checkbox"]', function (e) &#123; e.stopPropagation(); const $this = $(this), $checkItem = $selector.find("input[name='mulItem']"), $checkAll = $selector.find("input[name='checkAll']"), _dataType = $this.data('type'); if ($this.is(':checked')) &#123; $this.parent().addClass('checked'); &#125; else &#123; $this.parent().removeClass('checked'); &#125; if (_dataType === 'checkAll') &#123; if ($this.prop("checked") === true) &#123; $checkItem.prop('checked', true); $checkItem.parent().addClass('checked'); $selector.find('.disable').removeClass('checked'); $selector.find('.disable input').prop('checked', false); &#125; else &#123; $checkItem.prop('checked', false); $checkItem.parent().removeClass('checked'); &#125; &#125; else &#123; const ischeckedAll = _this.checkedStatus(); //是否全选 if (ischeckedAll) &#123; $checkAll.prop('checked', true); $checkAll.parent().addClass('checked'); &#125; else &#123; $checkAll.prop('checked', false); $checkAll.parent().removeClass('checked'); &#125; &#125; _this.getCheckedValue(); &#125;); _this.element.on('click', '.checked-item', function () &#123; $(this).find('input[type="checkbox"]').click(); &#125;);&#125; 获取选中状态的值已经完成了选中状态，需要返回选中的值，只需获取当前列表下CheckBox的checked为true的值，并存于一个数组中，通过回调函数返回即可，需要注意的是，构造函数中设置了showNumber参数，即当选中个数超出这个设置值时，则显示已选多少个数，这里需要判断一下，还有当全选并且选中的个数大于showNumber时显示全选，代码如下：1234567891011121314151617181920212223242526272829303132MulSelect.prototype.getCheckedValue =function () &#123; let _this = this, checkedArr = [], _string = '', &#123;showNumber, getCheckedValue, data, chooseText&#125; = _this.config; this.element.find('input[name="mulItem"]').each(function () &#123; const $this = $(this); if ($this.is(':checked')) &#123; checkedArr.push($this.val()); &#125; &#125;); getCheckedValue(checkedArr, _this.element); if (showNumber &lt;= checkedArr.length) &#123; _string = `$&#123;checkedArr.length&#125; selected`; &#125; else &#123; _string = checkedArr.join(' , '); &#125; if (checkedArr.length === data.length &amp;&amp; showNumber &lt; checkedArr.length) &#123; _string = `All selected($&#123;checkedArr.length&#125;)`; &#125; if (checkedArr.length === 0) &#123; _string = chooseText; &#125; _this.element.find('.mulselect-text').text(_string).attr('title', _string);&#125; 新增列表项列表的下拉多选基本完成，现在做额外的功能，新增列表项功能，同名的列表项不能新增，触发新增的功能键为：新增按钮或enter，当新增框不为空并且没同名项时，点击新增，在列表的尾部添加一下，并选中，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273MulSelect.prototype.addItem = function () &#123; const _this = this, $selector = _this.element, &#123;canNotSameName&#125; = _this.config; //新增列 $selector.on('click', '.btn-add', function (e) &#123; e.stopPropagation(); const _val = $(this).prev().val(); if (_val.length &gt; 0) &#123; let checkedArr = []; $selector.find('input[name="mulItem"]').each(function () &#123; checkedArr.push($(this).val()); &#125;); if (checkedArr.indexOf(_val) !== -1) &#123; $selector.find('.vilExpression').text(canNotSameName).show(); return; &#125; $selector.find('.vilExpression').hide(); _this.config.data.push(&#123; name: `.$&#123;_val&#125;`, disable: '' &#125;); _this.config.isOpen = true; $selector.find('.mulselect-list').append(` &lt;li class="mulselect-item checked-item checked" title="$&#123;_val&#125;"&gt; &lt;input type="checkbox" value="$&#123;_val&#125;" name="mulItem" data-type="item" checked=true&gt;$&#123;_val&#125; &lt;/li&gt; `); $selector.find('.add-col').val(''); _this.getCheckedValue(); // _this.create(); &#125; &#125;); //enter新增 $selector.on('keyup', '.add-col', function (e) &#123; const _value = $(this).val(); if (_value.length &gt; 0) &#123; let checkedArr = []; $selector.find('input[name="mulItem"]').each(function () &#123; checkedArr.push($(this).val()); &#125;); if (checkedArr.indexOf(_value) !== -1) &#123; $selector.find('.vilExpression').show().text(canNotSameName); return; &#125; $selector.find('.vilExpression').hide(); if (e.keyCode === 13) &#123; _this.config.data.push(&#123; name: _value, disable: '' &#125;); _this.config.isOpen = true; $selector.find('.mulselect-list').append(` &lt;li class="mulselect-item checked-item checked" title="$&#123;_value&#125;"&gt; &lt;input type="checkbox" value="$&#123;_value&#125;" name="mulItem" data-type="item" checked=true&gt;$&#123;_value&#125; &lt;/li&gt; `); _this.getCheckedValue(); $selector.find('.add-col').val(''); &#125; &#125; &#125;);&#125; 封装到jQuery和window上到目前为止已经完成了下拉多选的封装，只需在jQuery和window上扩展可直接使用，代码如下：1234567//封装到window对象上window.MulSelect = MulSelect;//封装到jquery对象上$.fn.MulSelect = function (config) &#123; const mulSelect = new MulSelect(this, config); return mulSelect.init();&#125; 总结一个完整的jQuery下拉多选封装已经完成，目前只是处版，后期有时间会将功能扩展到多层级，完整代码已经上传GitHub，有兴趣狠狠的点击这儿]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery_Pagination封装]]></title>
    <url>%2F2019%2F03%2F11%2FjQuery%2FPagination%2F</url>
    <content type="text"><![CDATA[Pagination封装&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段时间维护以前jQuery做的网站，优化了下分页的封装，主要使用的思想：构造函数+原型链的方式，将封装好的方法挂在到jQuery和window上，先上一个图： 构造函数：123456789101112131415161718192021222324function Pagination (element, config) &#123; this.ele = element; this.config = &#123; currentPage: 1, numberOfPages: 3, total: 1, isJumpPage: true, jumpItems: &#123; jumpTo: 'jump to', page: 'page' &#125;, itemTexts: &#123; first: '&amp;lt;&amp;lt;', prev: '&amp;lt;', next: '&amp;gt;', last: '&amp;gt;&amp;gt;' &#125;, onPageChanged: function () &#123; &#125; &#125;; if (config &amp;&amp; $.isPlainObject(config)) &#123; this.config = $.extend(&#123;&#125;, this.config, config); &#125;&#125; 原型方法：1234567891011121314151617181920Pagination.prototype = &#123; /** * 初始化 * */ init: function () &#123; //... &#125;, /** * 创建分页 * */ createPagination: function () &#123; //... &#125;, /** * 事件绑定 * */ eventBind: function () &#123; //分页事件 &#125;&#125;; window和jQuery上扩展：12345window.Pagination = Pagination;$.fn.Pagination = function (config) &#123; var pagination = new Pagination(this, config); return pagination.init();&#125; 使用方法1. 基础分页123$('.basePagination').Pagination(&#123; isJumpPage: false&#125;); isJumpPage是否显示可跳转输入框，默认true 2. 跳转指定页123456$('.pagePagination').Pagination(&#123; currentPage: 1, numberOfPages: 3, total: 6, isJumpPage: true,&#125;); currentPage当前页， numberOfPages中间显示个数(只能大于3的奇数)，total总页数 3. 文字设置12345678910111213141516$('.setPaginationWord').Pagination(&#123; currentPage: 1, numberOfPages: 3, total: 9, isJumpPage: true, itemTexts: &#123; first: '首页', prev: '上一页', next: '下一页', last: '最后一页' &#125;, jumpItems: &#123; jumpTo: '跳转到', page: '页' &#125;,&#125;); 4. 跳转回调123456789101112131415161718192021$('.jumpPaginationCallBack').Pagination(&#123; currentPage: 1, numberOfPages: 3, total: 12, isJumpPage: true, itemTexts: &#123; first: '首页', prev: '上一页', next: '下一页', last: '最后一页' &#125;, jumpItems: &#123; jumpTo: '跳转到', page: '页' &#125;, onPageChanged: function (option, element) &#123; console.log(option); console.log(element); alert(`跳转到$&#123;option.currentPage&#125;页`); &#125;&#125;); isFooter是否显示底部，true为显示，默认为true 5. 参数 参数 说明 类型 默认值 currentPage 当前页 Number 1 numberOfPages 中间显示个数(只能是大于3的奇数) Number 3 total 总页数 Number 1 isJumpPage 是否显示跳转页：true为显示 Boolean true jumpItems:{jumpTo,page} 跳转文本 string jump to、page itemTexts{first、prev、next、last} 文本 string &lt;&lt;、&lt;、&gt;、&gt;&gt; 6. 方法 参数 说明 onPageChanged(option, element) 选中回调(option：当前选中页的回调信息，element:分页DOM) 完整代码已经上传到GitHub上，有兴趣可以狠狠的点击这儿。]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery_Dialog封装]]></title>
    <url>%2F2019%2F03%2F01%2FjQuery%2FDialog%2F</url>
    <content type="text"><![CDATA[jQuery自定义Dialog封装&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段时间维护以前jQuery写的网站，里面涉及到很多弹框的功能，为方便使用jQuery封装了个模态框，模态框的封装主要使用构造函数和原型链结合的方式实现，然后在window和jQuery上扩展该方法，首先看一下效果： 构造函数代码：12345678910111213141516171819202122232425262728function Dialog(element, config) &#123; this.ele = element; this.config = &#123; title: '信息提示框', maskClick: false, width: 500, height: 'auto', content: '', isHeader: true, isFooter: true, onlyConfirm: false, isContentCenter: false, isConfirmClose: true, isShowConnect: false, confirmName: '确认', cancelName: '取消', connectionName: '连接测试', confirmCallback: function () &#123; &#125;, cancelCallback: function () &#123; &#125;, connctionCallback: function () &#123;&#125; &#125;; //扩展默认参数 if (config &amp;&amp; $.isPlainObject(config)) &#123; this.config = $.extend(&#123;&#125;, this.config, config); &#125;&#125; 原型链上的方法：123456789101112131415161718Dialog.prototype = &#123; init: function () &#123; const _this = this; _this.create(); &#125;, //创建弹框 create: function () &#123; //... &#125;, //事件绑定 eventBind: function () &#123; //... &#125;, //关闭弹窗 closeMask: function (e) &#123; //... &#125;&#125;; window和jQuery上扩展：1234567//封装到window对象上window.Dialog = Dialog;//封装到jquery对象上$.fn.Dialog = function (config) &#123; var dialog = new Dialog(this, config); return dialog.init();&#125; 使用方法1. 基础弹框123$('body').Dialog(&#123; content: '基础弹框测试'&#125;); content表示弹框的内容区，可自定义 2. 基础弹框测试(内容居中)12345$('body').Dialog(&#123; title: '基础弹框(内容居中）', content: '基础弹框测试', isContentCenter: true&#125;); title弹框的标题， isContentCenter表示是否居中，true为居中，默认为false 3. 不显示头部弹框12345$('body').Dialog(&#123; content: '弹框测试', isContentCenter: true, isHeader: false&#125;); isHeader是否显示头部，true为显示，默认为true 4. 不显示底部弹框12345$('body').Dialog(&#123; content: '不显示底部', isContentCenter: true, isFooter: false&#125;); isFooter是否显示底部，true为显示，默认为true 5. 点击空白关闭弹窗12345$('body').Dialog(&#123; content: '点击空白关闭弹窗', isContentCenter: true, maskClick: true&#125;); maskClick点击背景是否关闭弹窗，true为点击能关闭，默认false 6. 确认和取消回调12345678910111213$('body').Dialog(&#123; content: '确认和取消回调', isContentCenter: true, maskClick: true, confirmName: '点我确认', cancelName: '点我取消', confirmCallback: function () &#123; alert('确认'); &#125;, cancelCallback: function () &#123; alert('取消'); &#125;&#125;); confirmCallback确认回调；cancelCallback取消回调 API1. 参数 参数 说明 类型 默认值 title 标题 string 信息提示框 maskClick 点击背景是否关闭弹窗 Boolean false content 弹框内容，可添加HTML元素 – – isHeader 是否显示头部：true为显示 Boolean true isFooter 是否显示底部：true为显示 Boolean true isContentCenter 内容区是否水平居中显示，true为水平居中 Boolean false onlyConfirm 是否只显示确认按钮 Boolean false confirmName 确认按钮名称 string 确认 cancelName 取消按钮名称 string 取消 2. 方法 参数 说明 confirmCallback 确认回调 cancelCallback 取消回调 完整代码已经上传到GitHub上，有兴趣可以狠狠的点击这儿。]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖函数和节流函数]]></title>
    <url>%2F2019%2F02%2F27%2Fjs%2F%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、初次接触防抖和节流函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初次使用防抖和节流函数，之前做一个react项目时，有一块功能是这样的：notebook的每一个新建功能都是新的窗口，每一个编辑框下能支持Python和R语法，编辑框有初始高度，当编辑框内容增多时编辑框会随着增大。即功能要这样做，每一次keyDown时，我都会动态改变高度，再次渲染，那么出现个问题，每一个keyDown都会去更新一次react组件，如果用户一直按着enter时，会非常浪费性能。刚开始时，使用防抖函数，当时思路是每一次触发延迟200ms才能再次触发，似乎不够完善，节能函数便登场了。 二、测试实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说说为什么要使用防抖函数和节流函数，在网页开发过程中经常会遇到需要绑定触发某些功能的持续事件，如：mouseMove、scroll等事件，那么会很浪费性能，特别是极端情况下，这时就需要防抖和节流函数。防抖和节流函数都是优化事件高频执行的一种js方法。具体使用上面根据实际项目需求来。举个简单的例子，鼠标在浏览器上没move一次，count+1,如下：1234567891011&lt;div id="count" style="width: 100%; height: 500px; background-color: #ccc; font-size: 100px; color: #fff; display: flex; justify-content: center; align-items: center;"&gt;&lt;/div&gt;&lt;script&gt; let num = 1; let aCount = document.getElementById('count'); aCount.onmousemove = accumulation; function accumulation() &#123; aCount.innerHTML = num++; &#125;&lt;/script&gt; 效果如下：可以看到，每一次鼠标移动，函数都执行，这样频繁的执行，浪费了很多性能，特别是在大型项目中，如果电脑差点会导致网页卡顿的情况。 三、防抖函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;防抖是指函数在特定的时间内不再被调用执行。先看下函数，与原版有区别，原版使用的时call，这里使用的时apply。123456function debounce (fn, _this, delay) &#123; clearTimeout(fn.timeoutId); fn.timeoutId = setTimeout(() =&gt; &#123; fn.apply(_this, arguments) &#125;, delay); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码fn表示需要执行的函数，_this表示当前对象，delay表示延迟时间，obj表示函数传入所需的参数。即每次触发事件，函数延迟执行指定时间执行一次。使用防抖函数执行上面例子，如下：1aCount.onmousemove = debounce(accumulation, null, 200); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用防抖函数处理鼠标移动，数字叠加的情况，间隔时间200ms，快速移动鼠标，每次触发都在200ms内，那么屏幕上就不会有count累加。如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样和最初的想法有点背离，我想每次移动后，无论间隔是都在200ms内，我累加1，防抖函数无法实现。防抖函数的大多用途在表单验证的情况，用户输入后进行验证，是否合乎规定。错误则提示，如标红显示信息等。要实现上面的需求，需要使用节流函数。 四、节流函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节流函数，节流是指在连续触发事件，但只在指定时间内执行一次。大多使用场景，如：输入框输入请求，监听页面元素滚动，鼠标事件等高频触发事件。那么使用节流无论change的间隔在200ms内还是在200ms外，间隔200ms都执行打印。如下所示：123456789101112131415161718192021222324252627/**** ** 改进节流函数函数 ** @param fn 待执行的函数 ** @param context this ** @param delay 延迟时间 ** @param text 输入框文本 ** @param applyTime 必须执行的时间 ** **/function throttle (fn, context, delay, text, applyTime) &#123; clearTimeout(fn.timer); fn._currTime = new Date(); //记录第一次执行的时间 if (!fn._startTime) &#123; fn._startTime = fn._currTime; &#125; //如果时间间隔大于必须执行的时间，则执行，否则延迟执行 if (fn._currTime - fn._startTime &gt; applyTime) &#123; fn.call(context, text); fn._startTime = fn._currTime; &#125; else &#123; fn.timer = setTimeout(() =&gt; &#123; fn.call(context, text); &#125;, delay) &#125;&#125; 上面的问题调用如下：1aCount.onmousemove = throttle(accumulation, null, 200, val, 200); 显示如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就能完美解决无论什么情况都指定时间内执行。 五、例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到最初的问题，编辑框每次enter时，更新组件，增加编辑框的高度；每次backspace时，更新组件，减小编辑框的高度。单纯问题描述上看，对性能问题没什么太大的影响，我换个描述，问题就严重了。新增notebook会新开窗口，这儿是最外层，每个窗口下面有n个编辑框，然后再是正在编辑的编辑框，每一层都有很复杂的逻辑，我每次对编辑框keyDown时，首先需要找到对应的窗口，对应的编辑框，然后才改变编辑框的高度，貌似不是太复杂。但是我一直按着enter，每次都要从最外层组件开始更新，这样无疑浪费了很多性能。故优化方法，可使用防抖函数或节能函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里使用防抖函数会出现问题，假如使用防抖函数，即延时一定时间执行一次，假定时间为200ms，我一直按着enter，不断地再触发事件，间隔永远小于200ms，则一直不会执行。故这里应该使用节能函数，无论如何测试，设置特定的时间，那么每次在这个时间都会执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用一个打印输入框值得情况来模拟上面描述的问题，问题：用户在input中输入字符，每200ms就需打印输入的内容，实现如下：123456789function test(val) &#123; console.log("inputValue:",val);&#125;const aInput = document.getElementById('Input');aInput.addEventListener('keyup', (e) =&gt; &#123; throttle(test, null, 200, e.target.value, 200);&#125;); 这样完美解决频繁触发造成性能浪费的问题，notebook项目的问题也以这种优雅的方式解决了。防抖和节能函数在实际项目中几乎都可以使用到，如果你看到了这儿，那么还等什么，快到你项目中使用吧。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小西柚的到来]]></title>
    <url>%2F2019%2F02%2F24%2Frecords%2F%E5%B0%8F%E8%A5%BF%E6%9F%9A%E7%9A%84%E5%88%B0%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间28个年头已过，像微风般拂过脸庞，没有一丝察觉，却已悄然而逝。经历去年一年的辛苦经营，终于在开年时收到了一个巨大的礼物，似那么的惹人怜爱，不敢轻易触碰。虽然早已做好了准备，但你的到来，却仍然让人手足无措。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得，第一次抱你时，你睁开一只眼睛看我时的怦然心动，在长时间的对视中，另一只眼也缓缓睁开，充满好奇。我想，你心里应该很疑惑，这位大叔是谁，为什么那么激动的看着我。看着不大不小的眼睛，像极了妈妈，虽然别人都说像我多一点，我仍觉得像妈妈多一点。经历了第一次换尿布，第一次喂奶，第一次换衣服，第一次洗澡…我们之间已经有了更深层次的感情，你的每次一次成长，都是我经受困难更坚决的努力，不放弃。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，辛苦妈妈十月怀胎，为了你付出了巨大的辛苦。有那么多美食不能吃，漂亮的衣服不能穿，为了你的到来经受了巨大的痛苦，之后的日子还要经历很长时间的艰辛。妈妈已经为你付出了那么多，我又有什么理由不更加努力，不对她更好呢？]]></content>
      <categories>
        <category>records</category>
      </categories>
      <tags>
        <tag>records</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-数据结构-链表]]></title>
    <url>%2F2019%2F02%2F22%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是链表？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一 个节点的引用叫做链表。其中链表分为基本链表、双向链表及循环链表，如下图： 基本链表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过，栈和队列使用数组模拟，在JavaScript中数组被模拟成对象，相比于其他语言（如java或C++），效率明显低了很多，如果使用数组比较慢的情况，那么就应该使用链表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先定义一个链表，链表中包含两个节点，Node类表示头节点，LinkedList类提供链表的插入、删除、查找、显示等辅助方法。 Node类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node类包含两个属性：element属性用来保存节点上的元素，next属性指向下一个节点，Node的构造函数实现，代码如下：1234567/** * 节点构造函数 * */function Node (element) &#123; this.element = element; this.next = null;&#125; LinkedList类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedList类提供了链表的插入、删除、查找、显示等操作，LinkedList类的构造函数实现如下：1234567891011/** * 链表构造函数 * */function LList () &#123; this.head = new Node('head'); this.find = find; this.insert = insert; this.findPrev = findPrev; this.remove = remove; this.display = display;&#125; 默认head节点指向为空，当有节点插入时指向下一个节点，find方法为查找链表指定元素，insert方法指在链表指定节点后插入元素，findPrev方法指查找链表上一个元素，remove方法指删除指定元素，display方法指遍历链表，显示链表元素。 find方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find方法用于遍历链表，查找指定元素，并返回指定元素节点，实现如下：12345678910111213/** * 遍历链表，查找链表指定节点 * */function find (item) &#123; var currNode = this.head; //从头节点开始遍历，查找到给定元素，结束循环 while (currNode.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find()演示了遍历链表的过程。 insert方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入节点前，首先需要创建一个新节点，将链表头节点复值给新创建节点，并查找指定元素(find())，在指定元素后插入新节点。插入方法，将新节点的next指向当前元素的next，当前元素的next指向新节点。如图： 代码如下：12345678910/** * 在链表指定节点中插入元素 * */function insert (newElement, item) &#123; var newNode = new Node(newElement); var currentNode = this.find(item); newNode.next = currentNode.next; newNode.previous = currentNode; currentNode.next = newNode;&#125; display方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display方法用于显示链表上的节点，故需要遍历链表，每次循环打印出当前节点，并将当前节点的next指向下一个节点，直到null时结束。代码如下：1234567891011/** * 展示链表的所有元素 * */function display () &#123; var currNode = this.head; while (!(currNode.next == null)) &#123; console.log(currNode.next.element + ','); currNode = currNode.next; &#125;&#125; findPrev方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findPrev方法查找链表指定节点的前一个元素，并返回该节点。遍历链表，如果当前节点的下一个元素的element等于指定元素，择找到指定元素的前一个元素，返回。代码如下：123456789101112/** * 查找指定元素上一个元素 * */function findPrev (item) &#123; var currNode = this.head; while (currNode.next !== null &amp;&amp; currNode.next.element !== item) &#123; currNode = currNode.next; &#125; return currNode;&#125; remove方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove方法删除指定元素，在删除指定元素前需要找到指定元素的前一个元素，并改变前一个元素的指针，将前一个元素的next指向前一个元素的next的next，如图： 代码如下：123456789/** * 删除链表指定元素 * */function remove (item) &#123; var prevNode = this.findPrev(item); if (prevNode.next !== null) &#123; prevNode.next = prevNode.next.next; &#125;&#125; 到这里基本链表的常用方法已经完成，该是测试代码的时候了，做点简单的增删功能试试。 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设需要向链表中依此插入A、B、C、D，然后在A的后面插入H，删除B和C。12345678910111213141516var city = new LList();//插入console.log('插入');city.insert('A', 'head');city.insert('B', 'A');city.insert('C', 'B');city.insert('D', 'C');city.insert('H', 'A');city.display();//删除console.log('-----------------');console.log('删除');city.remove('B');city.remove('C');city.display(); 执行结果：]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-骰子布局]]></title>
    <url>%2F2019%2F02%2F13%2Fcss%2Fflex-%E9%AA%B0%E5%AD%90%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[目录： 概念 flex容器的属性 2.1. flex-direction 2.2. flex-wrap 2.3. flex-flow 2.4. justify-content 2.5. align-items 2.6. align-content 项目的属性 3.1. order 3.2. flex-grow 3.3. flex-shrink 3.4. flex-basis 3.5. flex 3.6. align-self flex布局实践（骰子布局） 总结 源码 一、概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex布局称为flex容器，flex容器默认两根轴：水平主轴和垂直交叉轴。以下概念都围绕水平主轴和垂直交叉轴而定义。 二、flex容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1. flex-direction 决定主轴的方向 row(默认值): 主轴水平方向，左端为起点 row-reverse: 主轴水平方向，右端为起点 column: 主轴垂直方向，上端为起点 column-reverse: 主轴垂直方向，下端为起点 2. flex-wrap 项目是否排列在轴线上，是否换行属性 nowrap(默认值): 不换行 wrap: 换行，第一行在上方 wrap-reverse: 换行，第一行在下方 3. flex-flow: flex-direction和flex-wrap的简写4. justify-content 定义主轴上的对其方式 flex-start(默认值): 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对其，项目间间距相等 space-around: 每个项目两端的间距相等 5. align-items 项目在交叉线上的对齐方式 flex-start: 交叉线的起点对齐 flex-end: 交叉线的终点对齐 center: 交叉线的中心对齐 baseline: 项目第一行文字的基线对齐 stretch(默认值): 如果项目未设置高度或auto,将占满容器的高度 6. align-content 多行对其，如果只有一行，不起作用 flex-start: 与交叉点的起点对齐 flex-end: 与交叉点的终点对齐 center: 与交叉点的中心对齐 space-between: 与交叉线两端对齐，轴线间间隔平均分配 space-around: 每根轴线间隔相等 stretch: 轴线占满整个交叉线 三、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1. order定义项目的排列顺序，值越小越靠前，默认为0 .item { &nbsp;&nbsp;&nbsp;&nbsp;order: ;} 2. flex-grow定义项目的放大比例，默认为0 .item { &nbsp;&nbsp;&nbsp;&nbsp; flex-grow: ;} 如果flex-grow为1，则项目等分，如果有一个为2，其他为1，则该项目是其他项目的两倍。 3. flex-shrink定义项目的缩小比例，默认值为1。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex-shrink: ;} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效 4. flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex-basis: | auto;} 它可以设为跟width或height属性一样的值（比如250px），则项目将占据固定空间。 5. flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { &nbsp;&nbsp;&nbsp;&nbsp;flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。习惯使用这个属性。 6. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。 .item { &nbsp;&nbsp;&nbsp;&nbsp;align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 四、flex布局实践（骰子布局）假设骰子的一面最多可以放9个点。 下面来说如何使用flex布局骰子，html默认为 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; .box元素代表flex容器，.item元素代表一个项目，需要几个项目就有几个class为item的div元素。 1. 单项目1.1 首先左上角一个点，默认情况即可。 .box { width: 60px; height: 60px; border: 1px solid white; background: white; border-radius: 5px; display: flex; margin: 10px; } .box的样式为以上，下面所有都依据这个来的。 1.2 黑点在第一行居中对齐，使用justify-content: center即可。 .box.one1 { flex-direction: row; /* 默认值可以不写*/ justify-content: center; } 1.3 黑点在第一行右对齐，使用justify-content: flex-end。 .box.one2 { justify-content: flex-end; } 1.4 黑点在第二行第一个，转化为垂直交叉线排列方式，居中即可。 .box.one3 { align-items: center; } 1.5 黑点垂直水平居中 .box.one4 { align-items: center; justify-content: center; } 1.6 黑点在第二行右侧 .box.one5 { align-items: center; justify-content: flex-end; } 1.7 黑点在最后一行第一个 .box.one6 { align-items: flex-end; } 1.8 黑点在最后一行居中 .box.one7 { align-items: flex-end; justify-content: center; } 1.9 黑点在最后一行最后一个 .box.one8 { align-items: flex-end; justify-content: flex-end; } 2. 双项目html模版为 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 2.1 第一行左右布局 .box.two1 { justify-content: space-between; } 2.2 左侧上下布局 .box.two2 { flex-direction: column; justify-content: space-between; } 2.3 居中上下布局 .box.two3 { flex-direction: column; justify-content: space-between; align-items: center; } 2.4 右侧上下布局 .box.two4 { flex-direction: column; justify-content: space-between; align-items: flex-end; } 2.5 左上右下布局 .box.two3 { justify-content: space-between; } .two3 .item:last-child { align-self: flex-end; } 3. 三项目html模版 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 3.1 一左二中三右布局 .three1 { flex-direction: column; } .three1 .item:nth-child(2) { align-self: center; } .three1 .item:nth-child(3) { align-self: flex-end; } 3.2 一右二中三左布局 .three2 { flex-direction: column; align-items: flex-end; } .three2 .item:nth-child(2) { align-self: center; } .three2 .item:nth-child(3) { align-self: flex-start; } 4. 四项目4.1 第一排铺满，最后一排右布局模版： &lt;div class=&quot;box four1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 图：样式： .four1 { flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } 4.2 上下左右四个角布局html模版: &lt;div class=&quot;box four2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 图： 样式： .four2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } 5. 五项目html模版： &lt;div class=&quot;box four2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column mid&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 图： 样式： .four2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } .mid { align-items: center; justify-content: center; } 6. 六项目html模版： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 6.1 上三下三布局 .s1 { flex-wrap: wrap; align-content: space-between; } 6.2 左三右三布局 .s2 { flex-direction: column; flex-wrap: wrap; align-content: space-between; } 7 九项目html模版： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; 图： 样式： .n1 { flex-wrap: wrap; } 五、总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用flex布局很多情况下节省很多工作量，方便简单好用。特别手机端用的很多。 六、完整代码没上传GitHub，这儿随便写了下符在下面。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body { background: black; } .con { margin: 50px; display: flex; flex-direction: row; } .box { width: 60px; height: 60px; border: 1px solid white; background: white; border-radius: 5px; display: flex; margin: 10px; } .item { width: 10px; height: 10px; background: black; border-radius: 5px; margin: 5px; } .box.one1 { flex-direction: row; justify-content: center; } .box.one2 { flex-direction: row; justify-content: flex-end; } .box.one3 { flex-direction: row; align-items: center; } .box.one4 { flex-direction: row; align-items: center; justify-content: center; } .box.one5 { align-items: center; justify-content: flex-end; } .box.one6 { align-items: flex-end; } .box.one7 { align-items: flex-end; justify-content: center; } .box.one8 { align-items: flex-end; justify-content: flex-end; } .box.two1 { justify-content: space-between; } .box.two2 { flex-direction: column; justify-content: space-between; } .box.two21 { flex-direction: column; justify-content: space-between; align-items: center; } .box.two22 { flex-direction: column; justify-content: space-between; align-items: flex-end; } .box .item1 { align-self: center; } .box.two3 { justify-content: space-between; } .two3 .item:last-child { align-self: flex-end; } .t1 { flex-direction: column; } .t1 .item:nth-child(2) { align-self: center; } .t1 .item:nth-child(3) { align-self: flex-end; } .t2 { flex-direction: column; align-items: flex-end; } .t2 .item:nth-child(2) { align-self: center; } .t2 .item:nth-child(3) { align-self: flex-start; } .f1 { flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } .f2 { flex-direction: column; justify-content: space-between; } .column { display: flex; justify-content: space-between; } .mid { align-items: center; justify-content: center; } .s1 { flex-wrap: wrap; align-content: space-between; } .s2 { flex-direction: column; flex-wrap: wrap; align-content: space-between; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one3&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one4&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one5&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one6&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one7&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box one8&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 2 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two21&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two22&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box two3&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box t1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box t2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4、5 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box f1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box f2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box f2&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column mid&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 6、9 --&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;box s1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box s2&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box s1&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-数据结构-队列]]></title>
    <url>%2F2018%2F12%2F18%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过使用js模拟栈的算法，今天主要讲，使用js模拟队列的算法，为什么要这样做呢？说实话是闲的无聊，现在处于一个项目空档期，为了不至于太无聊，就想把数据结构里面的算法都使用js模拟一遍。 队列1、什么是队列？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象中午食堂吃饭时、等电梯时、早晚高峰进地铁时，都需要排队。那么肯定是先排队的有优先权，然后依次进入。队列也是这个道理，只有一个出口，一个入口，特点是先进先出，这和栈的思想相反。明白了队列的特点，分析如何使用js实现队列？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列有一个入口，取名为enqueue;出口取名为dequeue;正常情况下，还需要读取队首和队尾元素，命名为front和back，读取队列所有元素，命名为toStringData, 判断队列是否空，命名为isEmpty。现在可以完成队列的构造函数了，如下：123456789function Queue() &#123; this.data = []; this.enqueue = enqueue; //队尾添加一个元素 this.dequeue = dequeue; //队首删除一个元素 this.front = front; //读取队首元素 this.back = back; //读取队尾元素 this.toStringData = toStringData; //显示队内元素 this.isEmpty = isEmpty; //判断队列是否为空&#125; 2、使用enqueue()方法，在队尾添加一个元素，如下：123function enqueue(element) &#123; this.data.push(element);&#125; 3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下：123function dequeue() &#123; return this.data.shift();&#125; 4、使用front()方法，返回队首元素，如下：123456789 function front() &#123; return this.data[0]; &#125;```JavaScript###### 5、使用back()方法，返回队尾元素，如下：```JavaScript function back() &#123; return this.data[this.data.length - 1]; &#125; 6、使用toStringData()方法，返回队列元素，如下：12345678function toStringData() &#123; let queueString = ''; for (let i = 0; i &lt; this.data.length; i++) &#123; queueString += this.data[i] + '\n'; &#125; return queueString;&#125; 7、使用isEmpty()方法，判断队列是否为空，如下：123function isEmpty() &#123; return this.data.length === 0;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，就使用js实现了一个单向队列。 实例1、使用队列进行排序（基数排序）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍下什么是基数排序，基数排序又叫分配式排序或桶子法，它是通过数据的部分信息，将要排序的元素分配至桶中，以达到排序的作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一串数值，如下所示： 98、25、31、10、99、81、65、42、51 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：123456789100： 101： 31 81 512： 423：4：5： 25 656：7：8： 989： 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些桶子中的数值串接起来，如下所示：110 31 81 51 42 25 65 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着根据十位数在进行一次分配，如下所示：123456789100：1： 102： 253： 314： 425： 516： 657：8： 819： 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些数值串接起来，形成以下数值：110 25 31 42 51 65 81 98 99 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候排序已经完成；如果有三位数或这更高位数，则持续进行以上动作，直至最高位为止。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使用队列的思想进行排序呢？假设是0～99间的数进行比较，首先需要比较个位数，因为数值在0～99之间，只需对数进行取余,即可得到个位数，对数值除以10，向下取整可得到十位数。到这儿开始使用队列(桶)进行存值，需要是个队列分别存储0～9的值。如下：123456789101112131415/** * @param nums 初始数组 * @param queue 队列数组 * @param n 几位数 * @param digit 个位数或十位以上的数 * */function distribute (nums, queue, n, digit) &#123; for (let i = 0; i &lt; n; i++) &#123; if (digit === 1) &#123; queue[nums[i] % 10].enqueue(nums[I]); &#125; else &#123; queue[Math.floor(nums[i] / 10)].enqueue(nums[I]); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序后展示函数，如下：12345678910111213/** * @param queues 队列数组 * @nums nums 初始数组 * */function showAfterData (queues, nums) &#123; let i = 0; for (let digit = 0; digit &lt; 10; ++digit) &#123; while (!queues[digit].isEmpty()) &#123; nums[i++] = queues[digit].dequeue(); &#125; &#125; return nums;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成算法后，随机来点数实验下，如下：123456789101112131415let queues = [];for (let i = 0; i &lt; 10; ++i) &#123; queues[i] = new Queue();&#125;let nums = [];for (let i = 0; i &lt; 10; ++i) &#123; nums[i] = Math.floor(Math.floor(Math.random() * 101));&#125;console.log('个位数排序：');distribute(nums, queues, 10, 1);console.log(collect(queues, nums));console.log('十位数排序：');distribute(nums, queues, 10, 10);console.log(collect(queues, nums)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果如下： 双向队列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双向队列即队列的首尾都能进能出，那么只需在单向队列中添加两个方法，队首添加一个元素方法(fenqueue)，队尾删除一个元素的方法(‘bdequeue’),即可.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列的构造函数添加两个方法，如下：12345678910111213141516171819 function Queue() &#123; this.data = []; this.enqueue = enqueue; //队尾添加一个元素 this.dequeue = dequeue; //队首删除一个元素 `this.fenqueue = fenqueue; //队首添加一个元素` `this.bdequeue = bdequeue; //队尾删除一个元素` this.front = front; //读取队首元素 this.back = back; //读取队尾元素 this.toStringData = toStringData; //显示队内元素 this.isEmpty = isEmpty; //判断队列是否为空 &#125;function fenqueue (element) &#123; this.data.unshift(element);&#125;function bdequeue () &#123; return this.data.pop();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就完成了双向队列。双向队列能实现什么功能呢？如回文之类的使用双向队列能很方便的实现，思想如上一片文章中的栈，使用双向队列无论从前还是后插入数据，都一个原理。]]></content>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-数据结构-栈]]></title>
    <url>%2F2018%2F12%2F17%2FdataStructure%2Fjs-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做前端已有几年的时间，各种前端技术学了一堆，换着技术开发网站，感觉自己很牛逼的样子。这段时间总感觉到达了瓶颈，怎么也突破不了，冷静想了下。功能的实现、封装什么都没问题，但是就是算法差强人意。把大学的数据结构拿出来翻了下，这阶段再去看算法，比大学期间清楚太多了，很多原来知道有那回事儿，现在能明白用途在什么地方。我想我找到了突破瓶颈的方式了。从这篇文章开始，我会陆续的把数据结构中的算法用原生js实现。 栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈是一种数据结构，栈只有一个入口和一个出口，它的特点是LIFO(后入先出)，即比如我们吃的罐装薯片，只有从顶部一片一片的拿出来，才能拿到底部。因为栈的LIFO的特点，所有任何不在栈顶元素都无法访问到，为了得到栈底元素，必须把上面的元素都拿走，才能访问。而栈是一种列表，在js中，可以通过数据的方式来存储。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这儿便有思路了，首先需要一个data存储数据，data是一个数组，因栈只能访问栈顶元素，需要一个变量top存储栈顶元素的位置，当入栈时top + 1,当出栈时，top - 1，那么入栈需要一个方法s_push,出栈需要一个方法s_pop，还需返回栈顶元素的方法s_peek。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，需要清空栈、获取栈的长度或判断元素是否在栈内，以上方法是不够的，还需创建方法，s_clear(清空栈内元素)、s_length(获取栈的长度）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 首先，需要创建一个Stack类的构造函数，如下：123456789function Stack () &#123; this.s_top = 0; //初始化栈顶位置为0 this.s_data = []; //初始化空栈 this.s_push = s_push; //入栈方法 this.s_pop = s_pop; //出栈 this.s_peek = s_peek; //获取栈顶元素 this.s_length = s_length; //栈的长度 this.s_clear = s_clear; //清空栈&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 入栈，实现s_push方法，当向栈中压入新元素时，需要改变s_top对应栈的位置加1，然后指向数组下一个空位置。如下：123function s_push (element) &#123; this.s_data[this.s_top++] = element;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 出栈，s_pop方法和入栈相仿，每次取出元素后，将s_top - 1，然后返回当前删除的值，如下：1234function s_pop () &#123; --this.s_top; return this.s_data.pop();&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 获取栈顶元素，s_peek方法，栈顶的位置为s_top,只需要数组中取最后一个元素即可，如下：123function s_peek () &#123; return this.s_data[this.s_top - 1];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 清空栈，s_clear方法，设置栈顶指向为0，清空存储数据，代码如下：1234function s_clear () &#123; this.s_top = 0; this.s_data = [];&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 获取栈的长度，s_length, 即s_top的值，如下：123function s_length () &#123; return this.s_top;&#125; 实例1. 使用栈模拟递归&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如需要封装一个阶乘的函数，用递归的思想，如下：12345678function factorial (num) &#123; if (typeof num !== 'number') return num; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果用栈的方式如何处理呢？只需将给定的数递减到1入栈，然后每次s_pop的时候会返回栈顶元素，循环栈，然后将s_pop的值相乘即可，如下：1234567891011121314151617function factorial (num) &#123; if (typeof num !== 'number') return num; let s = new Stack(), facNum = 1; //入栈 while (num &gt; 0) &#123; s.s_push(num--); &#125; //出栈 while (s.s_length() &gt; 0) &#123; facNum *= s.s_pop(); &#125; return facNum;&#125; 2. 判断回文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说下什么是回文，把相同的字符串或句子颠倒过来，产生首尾循环的句子，意思就是正序和倒叙的结果一样。如何使用栈的思想实现回文呢？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈的方法有一个pop操作，每次pop返回栈顶元素。那么可以将字符串先push进栈，然后pop即可得到一个逆序的字符串，比较是否相等即可，如下：1234567891011121314function isPalindrome (str) &#123; const s = new Stack(); let reverseStr = ''; for (let i = 0; i &lt; str.length; i++) &#123; s.s_push(str[i]); &#125; while (s.s_length() &gt; 0) &#123; reverseStr += s.s_pop(); &#125; return reverseStr === str;&#125; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用栈的思想可以很方便的实现很多功能，比如判断表达式是否括号匹配等？不过说实话，在前端页面的开发中，用不到这些。有兴趣可以玩下，可以提升思维逻辑。]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-in-js框架style-components]]></title>
    <url>%2F2018%2F11%2F27%2Freact%2Fstyle-component%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端飞一般的发展中，衍生出各式各样的框架，框架的目的是减轻开发人员的开发难度，提高效率。以前网页开发的原则是关注点分离，意思是各种技术只负责自己的领域，不要混合在一起，形成耦合。如html、css、js代码分离。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React的出现，这个原则不在实用，React是组件结构，强制把html、css、js写在一起。如：12345678910111213const style = &#123; 'color': 'red', 'fontSize': '46px'&#125;;const clickHandler = () =&gt; alert('hi');ReactDOM.render( &lt;h1 style=&#123;style&#125; onclick=&#123;clickHandler&#125;&gt; Hello, world! &lt;/h1&gt;, document.getElementById('example')); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在一个js文件里，封装了结构、样式、逻辑，完全违背了关注点分离，很多人刚开始学习React很不适应，但是，这有利于组件的隔离，每个组件需要的代码不依赖于外部、组件之间没有耦合，方便复用。使用React的越来越多，组件模式深入人心，这种关注点混合的新写法逐渐成为主流。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表面上，React的写法是html、css、js混合写在一起，实际上是用js在写html、css。React对html的封装是jsx，那么对css的封装是什么呢？这就涉及到今天需要讲的内容style-components。 什么是style-components&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components是针对React写的一套css in js框架，简单来讲就是在js中写css。相对于与预处理器(sass、less)的好处是，css in js使用的是js语法，不用重新再学习新技术，也不会多一道编译步骤。无疑会加快网页速度。如果有sass或less的开发经验，几分钟就可以学会style-components。 官方文档https://www.styled-components.com/docs/basics 1. 安装npm install --save style-components 2. 基础用法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components最基础的用法就是以组件的形式编写样式，如下：123456789101112131415161718192021222324252627282930313233343536import styled from 'styled-components';const HomeWrapper = styled.div ` width: 960px; margin: 0 auto; overflow: hidden;`;const HomeLeft = styled.div ` float: left; width: 625px; margin-left: 15px; padding-top: 30px; .bannder-img &#123; width: 625px; height: 270px; &#125;`;const HomeRight = styled.div ` float: right; width: 280px; margin-left: 15px; padding-top: 30px;`;render () &#123; return ( &lt;HomeWrapper&gt; &lt;HomeLeft&gt; left &lt;/HomeLeft&gt; &lt;HomeRight&gt; right &lt;/HomeRight&gt; &lt;/HomeWrapper&gt; )&#125; 上面的代码定义了三个组件，分别为HomeWrapper 、HomeLeft 、HomeRight，这样每一个组件对应唯一的样式，不在出现样式污染的情况。 2. 全局样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个组件对应唯一的样式，那么需要设置全局样式怎么办呢？style-components的最新版提供了createGlobalStyle可以设置全局样式，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import &#123; createGlobalStyle &#125; from 'styled-components';const GrobalStyle = createGlobalStyle ` html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125; /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125; body &#123; line-height: 1; &#125; ol, ul &#123; list-style: none; &#125; blockquote, q &#123; quotes: none; &#125; blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; @font-face &#123; font-family: 'iconfont'; /* project id 897264 */ src: url('//at.alicdn.com/t/font_897264_7ma62sn10m3.eot'); src: url('//at.alicdn.com/t/font_897264_7ma62sn10m3.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.woff') format('woff'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.ttf') format('truetype'), url('//at.alicdn.com/t/font_897264_7ma62sn10m3.svg#iconfont') format('svg'); &#125; .iconfont &#123; font-family:"iconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; .clearfix:after &#123;visibility: hidden;display: block;font-size: 0;content: ".";clear: both;height: 0;&#125; .clearfix &#123;zoom: 1;&#125;`;render() &#123; return ( &lt;Fragment&gt; &lt;Provider&gt;...&lt;/Provider&gt; &lt;GrobalStyle/&gt; &lt;/Fragment&gt; )&#125; 上面的代码GrobalStyle是全局样式组件，只需在React组件的最外层引入即可。 3. 图片引入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要图片引入，如果像css一样的引入方式，会报错。正确的引入方式是import导入，再以变量的方式引入，如下：123456789101112import styled from 'styled-components';import logPic from '../../statics/images/logo.png';export const Logo = styled.div ` position: absolute; top: 0; left: 0; width: 100px; height: 56px; background-image: url($&#123;logPic&#125;); background-size: contain;`; 上面的代码logPic是存放logo图片地址的变量，只需使用${logPic}的方式引入即可。如果是后台传过来的图片，如何使用的背景图呢？ 4. props&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面提到的问题，可使用组件的传值。先看一个例子：12345678910recommendList.map((item) =&gt; &#123; return &lt;RecommendItem key=&#123;item&#125; imgUrl=&#123;item&#125;/&gt;&#125;)const RecommendItem = styled.div ` width: 280px; height: 50px; background-image: url($&#123;(props) =&gt; props.imgUrl&#125;); background-size: contain;`; 从上面的例子，不难发现，父组件传入的值，会存放在子组件的props中，故操作props便能得到预期效果。 5. 标签属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用style-components，需要使用标签属性，如input 的placeholder，a标签的href等，style-components提供了属性attrs，如下：123456789101112131415161718192021export const NavSearch = styled.input.attrs(&#123; placeholder: '搜索'， type: 'text'&#125;) ` width: 160px; height: 38px; margin-top: 9px; padding: 0 40px 0 20px; box-sizing: border-box; background-color: #eee; outline: none; border: none; border-radius: 19px; color: #666; &amp;::placeholder &#123; color: #999; &#125; &amp;.focused &#123; width: 240px; &#125;`; 上面的代码，attrs里面是一个对象，如果需要多个属性，以对象的形式添加即可。 6. 塑造组件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种情况，一些原本就已经是组件，需要给这些组件添加样式，这时需要用到塑造组件，如下：123456789101112131415const Link = (&#123;className , children&#125;) =&gt; ( &lt;a className=&#123;className&#125;&gt; &#123;children&#125; &lt;/a&gt;)const StyledLink = styled(Link)` color: palevioletred;`render( &lt;div&gt; &lt;Link&gt;普通组件&lt;/Link&gt; &lt;StyledLink&gt;添加了样式的组件&lt;/StyledLink&gt; &lt;/div&gt;); 7. 继承&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某一组件的样式会用到多个地方，不能每个地方都重新写一套样式，这样代码不够优雅。比如：一个button，有warning、有default、有primary等，这个button只是颜色不同，其他样式一样，这里便可用到继承。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 const Button = styled.button` line-height: 1.499; display: inline-block; font-weight: 400; text-align: center; -ms-touch-action: manipulation; touch-action: manipulation; cursor: pointer; background-image: none; border: 1px solid transparent; white-space: nowrap; padding: 0 15px; font-size: 14px; border-radius: 4px; height: 32px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-transition: all .3s cubic-bezier(.645,.045,.355,1); transition: all .3s cubic-bezier(.645,.045,.355,1); position: relative; -webkit-box-shadow: 0 2px 0 rgba(0,0,0,.015); box-shadow: 0 2px 0 rgba(0,0,0,.015); color: rgba(0,0,0,.65); background-color: #fff; border-color: #d9d9d9; `; const ButtonPrimary = styled(Button)` color: #fff; background-color: #1890ff; border-color: #1890ff; `; const ButtonWarning = styled(Button)` color: #f5222d; background-color: #f5f5f5; border-color: #d9d9d9; `;```javascript有人说，公用样式的组件完全可以写到全部样式里面，设置不同的class。这样做可行，但是为什么不直接去写css呢？###### 8. 动画&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上有这样一个例子，如下：```javascript const rotate = keyframes` from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; `; const Rotate = styled.div` display: inline-block; animation: $&#123;rotate&#125; 2s linear infinite; padding: 2rem 1rem; font-size: 1.2rem; `; render( &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt; ); 个人觉得，如果是简单的动画，直接以这样的方式去做，即可，如果动画比较复杂，建议使用react-transition-group框架有更好的体验。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components的常用用法介绍完成，当然官网上还有一些其他的用法，有兴趣可以了解下。使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度，期待下一版能解决这个问题。]]></content>
      <categories>
        <category>style-components</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux管理状态-todoList实现]]></title>
    <url>%2F2018%2F11%2F23%2Freact%2FRedux%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81-todoList%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[初衷&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux的学习，让人又爱又狠，爱它状态管理的便捷，恨它的文档让人一脸懵逼。总之学习Redux的过程痛并快乐着。为什么要些这篇文章？经历了从Redux文档一步一步爬过来，踩了无数地雷，死了无数脑细胞，连亲爱的头发也一天天离我远去，终于神功大成…。话说当年，文档已烂熟于心，本以为从此React江湖任我游，不想，刚出门就差点撞死在Action的门口；好不容易，将货(data),开着兰博基尼(dispatch)送到了仓库(store),不曾想，一堆相同的烂货(initState),陈列在仓库，散发着腐朽的味道，苍蝇呜呜呜的拍打着翅膀，仿佛在嘲笑着傻逼傻逼。拖着疲惫的步伐将货更换完成(reducer),开心的骑着电动小马达，越行越远…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文章的目的为了记录学习新技术的心路历程，以及对当前学习技术的一个总结。顺便带着，如果正在学习，正在看的你有一点点帮助，那么人生便已圆满，废话已经写了这么多，如果不喜欢，欢迎来喷。一直坚信，做技术的，如果不在被喷中成长，就在喷子的口水中变成泼妇。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章讲到使用react实现todoList,使用react做一些简单的页面交互可行，如果页面上的功能比较复杂，多组件之间的交互频繁，只是用react会使整个程序变得非常复杂，不利于维护，可能做到后面自己都不清楚数据是怎么走向的。怎么办呢？2014年Facebook就提出了Flux架构的概念，引发了一系列的实现。2015年，Redux的出现，将Flux与函数式变成结合在一起，很快就成为了前端的热门框架。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux是什么，其实Redux就是React的状态管理工具，当然React状态管理工具不止Redux，比如Mobx等，个人觉得使用Mobx更简单，本文主要介绍如何使用Redux一步一步使用页面功能开发。文章中会简单如何使用阿里的ReactUI组件antd。本文主要讲如何使用Redux管理React的状态，不会涉及太多的原理，想看原理，为啥不直接到官网去，带图的、彩色的、各国的都有，看的你不能自我、欲罢不能。 一、准备工作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脚手架使用create-react-app, 不清楚如何安装，请看上一篇文章React的增删功能-todoList实现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Redux: npm install -S redux 二、Redux知识总览&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux管理React状态的步骤。Action描述事件简单对象，它是改变store中state的唯一方法，通过store.dispatch()方法将Action传到store中。Action的作用只是传递数据，并没有更新数据，如何更新数据Reducer的工作。Reducer接收到Action传入的对应数据，更新数据后返回到store，更新页面。简化来讲，用户触发事件 -&gt;action(dispatch分发) -&gt; store -&gt; Reducer更新数据 -&gt; 返回更新后的数据到store -&gt; 更新页面。如下图： 三、Redux实现TodoList1. Action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action是把数据从应用传到store的有效载荷，它是store的唯一来源。通过store.dispatch()将数据传到store。Action是一个对象，里面必须有属性type,type是一个常量,type的作用是数据在Reducer中对应匹配数据使用。在这里我们可以思考下每一个Action都会有对应的type，那么一个网站必然会有很多的type，便于后期维护，最好把type放到统一的文件夹中进行管理。 Action是一个对象，type表示Action的名称。1234&#123; type: INIT_LIST, payload: data&#125; 上面的代码，Action的名称是INIT_LIST,它携带的信息是data数据。 2. Action Creator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View要发多少种信息，就会有多少个Action，如果每个都要写，那么会很麻烦，也不利于维护。使用ActionCreator.js统一管理所有的Action。同时Action的名称type，统一使用ActionTypes.js管理。名称可以随便取，不做强求。12345const INIT_LIST = 'init_list';export const initListAction = (data) =&gt; (&#123; type: INIT_LIST, data&#125;); 上面的代码initListAction函数就是一个Action。 3. store.dispatch()store.dispatch()是View发出Action的唯一方法。1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: INIT_LIST, data: 'test'&#125;); 上面的代码，store.dispatch接收一个Action对象作为参数，发送给store。结合initListAction，可改写成：1store.dispatch(initListAction(data)); 4. Reducer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store收到Action后，必须给出新的state，这样View才能发生变化，计算state的过程交Reducer。Reducer是一个纯函数，即有什么样的输入就有什么样的输出。Reducer的写法如下：1234567891011121314151617181920212223242526272829import &#123; CHANGE_INPUT_VALUE, SUBMIT_BTN_ITEM, DELETE_ITEM, INIT_LIST &#125; from '../actions/types'const initialList = &#123; inputValue: '', list: []&#125;;const reducerList = (state = initialList, action) =&gt; &#123; switch (action.type) &#123; case CHANGE_INPUT_VALUE: const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.inputValue; return newState; case SUBMIT_BTN_ITEM: const submitState = JSON.parse(JSON.stringify(state)); console.log(submitState); submitState.list.push(submitState.inputValue); submitState.inputValue = ''; return submitState; case DELETE_ITEM: const deleteState = JSON.parse(JSON.stringify(state)); deleteState.list.splice(action.index); return deleteState; case INIT_LIST: const initState = JSON.parse(JSON.stringify(state)); initState.list = action.data; return initState; default: return state; &#125;&#125;; export default reducerList; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，type放在公用的文件夹中管理，Action的type和Reduce的type必须一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因会有很多Action，故使用switch的方式。如果case下面的数据比较复杂，可以单独提出来进行处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const newState = JSON.parse(JSON.stringify(state));这句话的作用是深拷贝，目的是如果直接操作state,会影响其他View的数据。 5. Store&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store是保存数据的地方，整个应用只有一个Store。Redux提供了createStore函数来生成Store。12import &#123; createStore &#125; from 'redux';const store = createStore(fn); 上面的代码，createStore接收另外一个函数作为参数，返回新生成的Store对象。 6. store.subscribe()store.subscribe()是Store的监听函数，一旦state改变，就会自动执行这个函数。12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); store.subscribe(listener); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，只要把View的更新数据替换上面的listener,当state改变时，就能更新数据。绑定事件监听，完成后需要解除事件，只需执行listener就会自动解除监听。 7. store.getState&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在View中需要使用state中的数据，使用store.getState获取store中state数据，展示到页面即可。123import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.getState(state); 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面介绍了Redux一些基础的使用方法，一个完整的项目使用这样的方法，会比较繁琐，那么怎么办呢？下一节会讲到，中间键redux-saga、redux-thunk和异步的使用方法，同时会讲到antd UI组建的使用。想看源码请狠狠的点击这里。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-自定义滚动条]]></title>
    <url>%2F2018%2F11%2F22%2Fcss%2Fcss-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[1. 初衷 做了几年的前端了，做笔记都是在自己的网盘里面记录，每次翻原来的笔记，总感觉差了点什么，突然有一天，一声惊雷闪过，文字依旧是那点文字，读者只有唯一，为什么不能分享出来，分享踩过的坑，希望能帮助到正在看的你。 2.为什么要自定义滚动条？一直觉得，滚动条用默认的就好了，没特殊需求为啥要自定义呢？之前做过一个自定义表格，功能有：超出一定的高度滚动起来，表头固定，没列有自定义右键菜单，如下：最近入手一台Mac，再看原来的代码，Mac竟然如此神奇，滚动条不占位置，还会显示隐藏，而我自定义的表格在Mac端出问题，因为表格自定义，使用的ul、li模拟的表格，滚动条在windows端占位，到Mac端不占位了，故出现表头和内容不对齐情况，如下：图中是有滚动条的，因Mac默认隐藏，故滚动条的17px导致错行。 3. 实现Mac端滚动条兼容 要做到同时兼容windows和Mac，那么可以自定义滚动条，做法很简单，在全局的css样式中加入下面代码即可： 12345678910111213//自动移滚动条样式::-webkit-scrollbar&#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-thumb&#123; border-radius: 1em; background-color: rgba(50,50,50,.3);&#125;::-webkit-scrollbar-track&#123; border-radius: 1em; background-color: rgba(50,50,50,.1);&#125; 1、::-webkit-scrollbar 定义了滚动条整体的样式；2、::-webkit-scrollbar-thumb 滑块部分；3、::-webkit-scrollbar-thumb 轨道部分； 加上这个代码，在看下效果，自定义表格完美兼容Mac。 自定义滚动条有很多方式，这里只是展示了个人觉得比较简单的，还有很多插件可以实现，有兴趣的朋友可以自己玩一下。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-todoList实现]]></title>
    <url>%2F2018%2F11%2F13%2Freact%2Freact-todoList%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[React作为当前最火的框架之一，学习和使用已有一段时间，在这里记录下学习React的心得，纯属个人观点。在学习React之前，了解过Vue,和angular，个人比较喜欢React的开发模式，之前的开发用的比较多jquery的模板（artTemplate,hogan）之类的，和React中的jsx原理类似，因此被吸引。 一、 React的准备工作 学习react有很多途径，可以看官网，可以看博客，可以看视频，这里比较推荐的做法是先看官网，了解基本知识后，做一些例子。然后再学习相关依赖，如Redux、Mobx之类的状态管理工具，之后的文章中会进一步讲解React相关依赖，有：Redux、Mobx、Redux-thunk、Redux-saga、immutable、react-transition-group、antd、styled-components、prop-types等。 开始学习React需要一定的开发基础，如：Es6、webpack等。我学习React使用的是create-react-app脚手架， 安装：npm install -g create-react-app创建React应用： create-react-app my-app$ create-react-app my-app Creating a new React app in G:\GitHub\React-demo\my-app. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts... 1、主要依赖react,react-dom,react-scripts2、目录结构 3、运行 npm start4、打包 npm run build二、正式开发1、使用react做一个输入框，点击提交在下面列表展示，点击对应的列表项，删除该项，如下： 2、项目的数据结构，首先分析需求，一个input框，一个button，一个列表。可以把input和button看成一个组件，列表看成一个组件。在state中的数据结构可以设置为：12345//state的数据结构this.state = &#123; inputValue: '', //用于存放input的值 list: [] //存放列表的值&#125; input框功能实现，原理：input框绑定onChange事件，每当输入字符时，改变this.state.inputValue的值，React中当state或props中的值改变，render函数会重新执行。实现如下： 123456789101112131415161718192021222324252627//方法一：改变this.state.inputValue值，通过事件返回的e.target.value,获取输入框中的值&lt;input type="text" onChange=&#123;this.handleChange&#125; value=&#123;this.state.inputValue&#125; /&gt;handleChange (e) &#123; //同步setState this.setState(&#123; inputValue: e.target.value &#125;);&#125;//方法二：在input框上设置ref属性，ref表示对组件真正实例的引用。//设置ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125;表示，将当前input框中的value值，//绑定到this上，在handleChange方法中，便可以直接取input的值：this.input.value&lt;input type="text" id="inputValue" onChange=&#123;this.handleChange&#125; value=&#123;this.state.inputValue&#125; ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125;/&gt;handleChange (e) &#123; const value = this.input.value; //异步setState，可以为异步方法，带有一个参数prevState,即为上一步state的内容，同时带有回调函数 this.setState(() =&gt; (&#123; inputValue: value &#125;), () =&gt; &#123; console.log('赋值完成！'); &#125;);&#125; 提交功能实现，原理：很容易就想到，当点击提交的时候，将input框中的值push到this.state.list即可。 12345678910&lt;button onClick=&#123;this.handleSubmit&#125;&gt;提交&lt;/button&gt;//提交添加UI列表handleSubmit () &#123; this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue], inputValue: '' &#125;), () =&gt; &#123; //回调函数 console.log(this.ul.querySelectorAll('li').length); &#125;);&#125; 将list的值在页面展示出来,可以通过map方法，循环li。 12345678this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;)/* 注：react中循环的时候，必须在每一项加上key的属性，不然控制台会报错， 原因是：diff算法在循环的时候,会去匹配对应的key值。此处用index作为key值是不合理的做法，key值应该是唯一的， diff算法后面会详细讲到。*/ 点击li，删除当前li,原理：每一个li都有对应的index，点击li时，获取index，在list找到对应下标，然后delete即可。 12345678910111213this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125; onClick=&#123;this.handleDeleteItem.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt;&#125;)//删除当前点击itemhandleDelete (index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list: list &#125; &#125;);&#125; 三、总结React的原理 1. state改变 2. jsx模板 3. 数据 + 模板 生成虚拟dom（虚拟DOM就是一个js对象，用来描述真实的DOM）（损耗了性能） 4. 用虚拟DOM结构生成真实的DOM，来显示 5. state改变 6. 数据 + 模板 生成新的虚拟DOM（极大的提升了性能） 7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到区别（diff算法） 8. 直接操作DOM，改变不同之处 Diff算法 1. 同层对比（变化前和变化后，虚拟DOM同一级进行对比） 2. 列表（每个循环的列表都需要一个唯一的key，用于做对比，节约性能，因此用循环的index作为key是不靠谱的做法，浪费性能） 3. 组件（一个React的APP有多个组件进行组成，diff对比组件的class） 4. 绘制 1). 当调用setState时，React将其标记为Dirty，然后事件轮询介绍时，React会查询dirty组件并重新绘制 2). 当组件的setState方法被调用，组件会重新绘制它的子组件 5. react事件委托（通过事件冒泡至document处，合成对象(SyntheticEvent)，当触发事件时，通过dispatchEvent分发函数分发） 生命周期函数（在某一时刻组件会自动执行调用的函数） 1. initialization (constructor) 初始化 2. Mounting (组件第一次挂载的流程) 1). componentWillMount 在组件即将被挂载到页面的时刻执行，即render前执行 2). render 3). componentDidMount 在组件挂载到页面的时刻执行 3. Updation 1). componentWillReceiveProps 从父组件接收参数并且这个组件在之前就存在父组件中 （props） 2). shouldComponentUpdate 在更新前调用，如果该组件返回true,往下执行，否则停止 3). componentWillUpdate 在更新前调用，shouldComponentUpdate返回true之后 4). render 5). componentDidUpdate 更新之后调用 4. Unmounting 1). componentWillUnmount 即将被页面移除的时候执行 结束本文使用react做了一个添加删除的功能，代码已放在GitHub上，有兴趣请狠狠的点击这儿。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE下input框后面默认带有X，去除方法]]></title>
    <url>%2F2018%2F09%2F12%2Fcss%2FIE%E4%B8%8Binput%E6%A1%86%E5%90%8E%E9%9D%A2%E9%BB%98%E8%AE%A4%E5%B8%A6%E6%9C%89X%EF%BC%8C%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在IE9下，input框带有X,如何去除？ 去除IE下input带x的方法，很简单，只需要css中加一句话就行了1234//去除IE下input框后面的Xinput::-ms-clear, input::-ms-reveal&#123; display: none;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义鼠标右键]]></title>
    <url>%2F2018%2F09%2F11%2FjQuery%2FjQuery-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%2F</url>
    <content type="text"><![CDATA[一、自定义鼠标右键的实现原理 自定义右键菜单功能，需清楚，所有浏览器都自带了右键功能，那么自定义右键菜单，需要先屏蔽系统自带的右键功能，如何实现呢？123$selector.on('contextmenu', '.box', function () &#123; return false;&#125;) 注：$selector为选择器，.box为禁用鼠标右键的class完成系统自带鼠标右键的禁用后，开始自定义鼠标右键。 获取鼠标事件的方法，使用mousedown,获取后需区分是鼠标左键还是右键，事件返回的参数event中，event.which为3表示右键，为1表示左键，为2表示中键。如下：12345678910$("#box").mousedown(function(e)&#123; if(3 === e.which)&#123; alert("这 是右键单击事件"); &#125;else if(1 === e.which)&#123; alert("这 是左键单击事件"); &#125; else if (2 === e.which) &#123; alert("这是鼠标中键"); &#125; &#125;) 二、自定义鼠标右键实例（表格行右键自定菜单）html:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 &lt;div class="box"&gt; &lt;div class="table-list"&gt; &lt;div class="table-thead "&gt; &lt;ul class="table-col"&gt; &lt;li class="save-item" title="名称"&gt; &lt;span&gt;名称&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="类型"&gt; &lt;span&gt;类型&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="数据"&gt; &lt;span&gt;数据&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;span&gt;操作&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="table-tbody"&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="table-col saveCol"&gt; &lt;li class="save-item" title="test1"&gt; &lt;span&gt;test1&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test2"&gt; &lt;span&gt;test2&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item" title="test3"&gt; &lt;span&gt;test3&lt;/span&gt; &lt;/li&gt; &lt;li class="save-item"&gt; &lt;i class="point-icon opratePointDrop" data-toggle="close"&gt;&lt;/i&gt; &lt;ul class="oprate-dropdown opDropDown none"&gt; &lt;li class="op-item btn-mySaveRun"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;运行&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveRename"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveEdit"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;刷新&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="op-item btn-mySaveDelete"&gt; &lt;a href="javascript:;"&gt; &lt;span&gt;导出&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118* &#123; border: none; margin: 0; padding: 0;&#125;ul, ul li, ol li, li &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;.none &#123; display: none;&#125;.box &#123; width: 1000px; margin: 20px 50px;&#125;/* 自定义table */.table-list &#123; width: 100%;&#125;.table-list .table-tbody &#123; position: relative; max-height: 350px; min-height: 225px;&#125;.table-list .table-thead ul &#123; background-color: #f5f5f5;&#125;.table-thead &gt; ul li &#123; font-weight: bold !important;&#125;.table-tbody &gt; ul &#123; margin-top: -1px; position: relative; cursor: pointer;&#125;.table-tbody &gt; ul:hover &#123; background-color: #f5f5f5;&#125;.table-thead, .table-tbody &#123; width: 100%;&#125;.table-thead &gt; ul, .table-tbody &gt; ul&#123; display: flex;&#125;.table-thead &gt; ul &gt; li, .table-tbody &gt; ul &gt; li &#123; flex: 1; height: 36px; font: normal 12px/36px 'Microsoft YaHei', 'Arial'; border: 1px solid #d9d9d9; border-left: none;&#125;.table-thead &gt; ul &gt; li:first-child, .table-tbody &gt; ul &gt; li:first-child &#123; border-left: 1px solid #d9d9d9;&#125;.table-thead &gt; ul &gt; li &gt; span, .table-tbody &gt; ul &gt; li &gt; span &#123; width: 90%; display: inline-block; margin: 0 10px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125;/* 下拉 */.oprate-dropdown &#123; position: absolute; top: 28px; right: 3px; width: 90px; border: 1px solid #d9d9d9; box-shadow: 0 0 5px #ccc; z-index: 100; /* 禁用选择字体 */ -moz-user-select: none; /*火狐*/ -webkit-user-select: none; /*webkit浏览器*/ -ms-user-select: none; /*IE10*/ user-select: none;&#125;.oprate-dropdown li.op-item &#123; width: 100%; height: 32px; background-color: #fff;&#125;.oprate-dropdown li.op-item:hover &#123; background-color: #f2f3f6;&#125;.oprate-dropdown li.op-item a &#123; display: inline-block; width: 70px; line-height: 32px; border-bottom: 1px solid #d9d9d9; color: #2a313f; margin: 0 10px; overflow: hidden;&#125;.oprate-dropdown li.op-item .op-icon &#123; position: relative; left: 0; top: 5px; display: inline-block; width: 15px; height: 20px;&#125;.point-icon &#123; display: inline-block; width: 20px; height: 15px; background: url(../image/point-icon.png) no-repeat; background-position: 0 10px; cursor: pointer; margin-left: 10px;&#125; js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var _rightMenu = &#123; init: function () &#123; var _this = this; _this.rightMenuOprate(); &#125;, rightMenuOprate: function () &#123; var $searchPart = $('.box'); //操作点击下拉 $searchPart.on('click', '.opratePointDrop', function (e) &#123; e.stopPropagation(); var $this = $(this), _isOpen = $this.attr('data-toggle'), $dropDown = $this.next(); //清空所有显示下拉 $searchPart.find('.opDropDown').each(function () &#123; var $this = $(this); $this.hide(); $this.prev().attr('data-toggle', 'close'); &#125;); if (_isOpen === 'close') &#123; $dropDown.show().css('left', ''); $this.attr('data-toggle', 'open') &#125; else if (_isOpen === 'open') &#123; $dropDown.hide(); $this.attr('data-toggle', 'close') &#125; &#125;); //禁止鼠标右键事件 $searchPart.on('contextmenu', '.saveCol', function () &#123; return false; &#125;); //鼠标右键 $searchPart.on('mousedown', '.saveCol', function (e) &#123; e.stopPropagation(); var $this = $(this); if (3 === e.which) &#123; //隐藏其他展开的下拉 $searchPart.find('.opDropDown').each(function () &#123; var $this = $(this); $this.hide(); $this.prev().attr('data-toggle', 'close'); &#125;); $this.find('.opDropDown').show().css(&#123; 'left': e.pageX - 50 + 'px' &#125;); &#125; &#125;); //点击清除 $(document).click(function (e) &#123; //兼容火狐 if (1 === e.which) &#123; $searchPart.find('.opratePointDrop').attr('data-toggle', 'close'); $searchPart.find('.opDropDown').hide(); &#125; &#125;); &#125;&#125;;$(function () &#123; _rightMenu.init();&#125;);]]></content>
      <categories>
        <category>jQuery自定义功能</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
