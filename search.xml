<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3</title>
    <url>/2019/08/20/css/CSS3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="CSS3整理归类"><a href="#CSS3整理归类" class="headerlink" title="CSS3整理归类"></a>CSS3整理归类</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS3新增了很多模块，比较重要的模块有：</p>
<blockquote>
<p>选择器<br>盒模型<br>背景和边框<br>蚊子特效<br>2D和3D转化<br>动画<br>多列布局<br>用户界面</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此文章主要表达常用CSS3的模块的定义，涉及一些简单例子。</p>
<h3 id="一、border-radius-圆角"><a href="#一、border-radius-圆角" class="headerlink" title="一、border-radius 圆角"></a>一、border-radius 圆角</h3><p>定义：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">border-radius: </span>a <span class="keyword">b </span>c d</span><br></pre></td></tr></table></figure></p>
<p>a、b、c、d分别表示对应位置的圆角，a表示：左上，b表示：右上，c表示：右下，d表示：左下。</p>
<p>如果border-radius只有三个值，如下：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">border-radius: </span>a <span class="keyword">b </span>c</span><br></pre></td></tr></table></figure></p>
<p>a表示：左上，b表示：右上和左下， c表示：右下</p>
<p>如果order-radius只有两个值，如下：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">radius</span>: a b</span><br></pre></td></tr></table></figure></p>
<p>a表示：左上和右下， b表示：右上和左下</p>
<p>如果border-radius只有一个值，如下：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">border</span>-<span class="built_in">radius</span>: a</span><br></pre></td></tr></table></figure></p>
<p>a表示: 四个圆角值相同</p>
<p>border-radius可以单独表示每一个圆角：</p>
<blockquote>
<p>border-top-left-radius: a         左上<br>border-top-right-radius: a        右上<br>border-bottom-right-radius: a     右下<br>border-bottom-left-radius: a      左下</p>
</blockquote>
<p>例：<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        .<span class="built_in">box</span> &#123;</span><br><span class="line">            <span class="built_in">width</span>: 100px;</span><br><span class="line">            <span class="built_in">height</span>: 100px;</span><br><span class="line">            <span class="built_in">border</span>: 1px solid red;</span><br><span class="line">            <span class="comment">/*border-radius: 5px 10px 20px 30px;*/</span></span><br><span class="line">            <span class="comment">/*border-radius: 5px 10px 20px;*/</span></span><br><span class="line">            <span class="comment">/*border-radius: 5px 10px;*/</span></span><br><span class="line">            <span class="built_in">border</span>-<span class="built_in">radius</span>: 5px;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/css/br.png" alt="一个参数"></p>
<hr>
<h3 id="二、background背景"><a href="#二、background背景" class="headerlink" title="二、background背景"></a>二、background背景</h3><p>CSS3中为background提供了几种背景属性</p>
<blockquote>
<p>background-image: url(“图片地址1”), url(“图片地址2”)…  添加背景图片,多个图片用都好分隔，显示在最顶端的为第一张<br>background-size: length | percentage | cover | contain;   指定背景图片的大小<br>background-repeat: no-repeat   不重复<br>background-origin: content-box | padding-box | border-box 指定背景图片的位置区域<br>background-clip: content-box | padding-box | border-box 指定背景的绘制区域</p>
</blockquote>
<p>background-size：</p>
<blockquote>
<p>length: 设置背景图片的宽度和高度，第一个参数为宽度，第二个为高度,如果只给第一个值，第二个为auto<br>percentage: 相对于背景定位区域的百分比，第一个百分比为宽度，第二个为高度，只有第一个值，第二个为auto<br>cover：将图片缩放成完全覆盖定位区域的大小<br>contain: 将图片的缩放成适合背景定位区域的大小</p>
</blockquote>
<p>background-origin:</p>
<blockquote>
<p>padding-box: 背景图片填充框的相对位置<br>border-box: 背景图片边界框的相对位置<br>content-box: 背景图片相对位置的内容框</p>
</blockquote>
<p>background-clip:</p>
<blockquote>
<p>padding-box: 背景绘制在内边距方框内<br>border-box: 背景绘制在边框方框内<br>content-box: 被景绘制在内容区方框内</p>
</blockquote>
<hr>
<h3 id="三、gradients渐变"><a href="#三、gradients渐变" class="headerlink" title="三、gradients渐变"></a>三、gradients渐变</h3><p>CSS3提供的渐变可以让两个或多个指定颜色平稳过渡，有两种类型的渐变：</p>
<blockquote>
<p>线性渐变(linear-gradient)：向下 | 向上 | 向左 | 向右 方向渐变<br>径向渐变(radial-gradient)：有中心定义开始渐变</p>
</blockquote>
<p>线性渐变：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">linear-gradient</span><span class="params">(direction, color1, color2...)</span></span></span><br></pre></td></tr></table></figure></p>
<p>direction:</p>
<blockquote>
<p>to right 从左向右<br>to left 从右向左<br>to bottom right 从左上到右下<br>……</p>
</blockquote>
<p>径向渐变：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">radial-gradient</span><span class="params">(angle, color1, color2...)</span></span></span><br></pre></td></tr></table></figure></p>
<p>angle表示角度，指水平线和渐变线之间的角度，逆时针方向计算。</p>
<p>其他功能：</p>
<blockquote>
<p>使用多个颜色点       background: linear-gradient(red, green, blue);<br>使用透明度          background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1));<br>重复的线性渐变       background: repeating-linear-gradient(red, yellow 10%, green 20%);<br>重复的径向渐变       background: repeating-radial-gradient(red, yellow 10%, green 15%);<br>设置形状            background: radial-gradient(circle, red, yellow, green);</p>
</blockquote>
<hr>
<h3 id="四、transform"><a href="#四、transform" class="headerlink" title="四、transform"></a>四、transform</h3><p>CSS3转换可以对元素进行移动、缩放、转动、拉长或拉伸。方法有：</p>
<blockquote>
<p>translate(x, y)： 根据左侧(x轴)和顶部(y轴)位置给定的参数，从当前元素位置移动。如translate(100px, 200px)从左侧开始向右移动100px,从顶部开始向下移动200px;<br>translate3D(x, y, z): 给定x，y，z参数，从当前位置移动。<br>rotate(angle)：给定度数顺时针旋转，如果是负数，则逆时针旋转指定角度。如rotate(30deg)表示顺时针旋转30度。<br>rotate3D(x, y, z, angle)：3D旋转<br>scale(x, y)：该元素增加和减少的大小，取决于x轴和y轴的参数。如scale(2, 3)表示宽度扩展为原来的两倍<br>scale3D(x, y, z)： 3D缩放转换<br>skew(<angle>, [<angle>])：分别表示x轴和y轴的倾斜度，第二个参数默认为0,负数为反方向倾斜<br>skewX(<angle>): x轴的倾斜度<br>skewY(<angle>): y轴的倾斜度<br>matrix(): 有六个参数，包含旋转，缩放，移动（平移）和倾斜功能<br>perspective(n): 为3D转换元素定义透视视图</angle></angle></angle></angle></p>
</blockquote>
<hr>
<h3 id="五、transition-过渡"><a href="#五、transition-过渡" class="headerlink" title="五、transition 过渡"></a>五、transition 过渡</h3><p>过渡是指从一种样式逐渐改变为另一种样式的效果。<br>过渡属性：</p>
<blockquote>
<p>transition-property: 过渡的css属性名称<br>transition-duration: 过渡所花费的时间，默认为0<br>transition-timing-function: 过渡效果的时间曲线，默认为”ease”（linear | ease | ease-in | ease-out | ease-in-out）<br>transition-delay: 延时多久开始过渡，即过渡效果的开始时间。<br>简写方式：<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">transition: <span class="keyword">property</span><span class="title"> </span>duration timing delay</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>例：<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">transition</span>: width <span class="number">1s</span>;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="六、animation-动画"><a href="#六、animation-动画" class="headerlink" title="六、animation 动画"></a>六、animation 动画</h3><p>在说动画之前，首先要知道@keyframes的规则，@keyframes规则能创建动画，原理是将一套css样式转化为另外一套样式，从而达到动画的效果。首先开个例子：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> move &#123; <span class="comment">// move自定义名称</span></span><br><span class="line">    <span class="attribute">from</span>: &#123;<span class="attribute">top</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attribute">to</span>: &#123;<span class="attribute">top</span>: <span class="number">200px</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move_percent &#123;</span><br><span class="line">    <span class="selector-tag">0%</span>: &#123;<span class="attribute">left</span>: <span class="number">0</span>&#125;</span><br><span class="line">    <span class="selector-tag">10%</span>: &#123;<span class="attribute">left</span>: <span class="number">20px</span>&#125;</span><br><span class="line">    <span class="selector-tag">30%</span>: &#123;<span class="attribute">left</span>: <span class="number">50px</span>&#125;</span><br><span class="line">    <span class="selector-tag">50%</span>: &#123;<span class="attribute">left</span>: <span class="number">100px</span>&#125;</span><br><span class="line">    <span class="selector-tag">100%</span>: &#123;<span class="attribute">left</span>: <span class="number">200px</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>了解完@keyframes后，再来看看animation，animation的属性：</p>
<blockquote>
<p>animation-name: keyframes的名称<br>animation-duration: 完成一周动画所花费的秒或毫秒，默认为0<br>animation-timing-function: 过渡效果的时间曲线,默认为ease（linear | ease | ease-in | ease-out | ease-in-out）<br>animation-delay: 规定动画何时开始，默认为0<br>animation-iteration-count: 规定动画被播放的次数，默认为1<br>animation-direction: 规定动画是否在下一周期逆向地播放。默认是 “normal”（normal | alternate）<br>animation-play-state: 规定动画正在运行还是暂停，默认”running”（paused | running）<br>animation-animation-fill-mode : 规定对象动画时间之外的状态。(none | forwards | backwards | both)</p>
</blockquote>
<p>动画属性的简写：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">animation: <span class="built_in">name</span> duration timing <span class="built_in">delay</span> iteration direction play fill</span><br></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> dropdown &#123;</span><br><span class="line">    0% &#123; <span class="attribute">margin-top</span>: <span class="number">0px</span>;&#125;</span><br><span class="line">   <span class="comment">/** 暂停效果 */</span></span><br><span class="line">   10% &#123; <span class="attribute">margin-top</span>: <span class="number">0px</span>;&#125;</span><br><span class="line">   50% &#123; <span class="attribute">margin-top</span>: -<span class="number">100px</span>;&#125;</span><br><span class="line">   60% &#123; <span class="attribute">margin-top</span>: -<span class="number">100px</span>;&#125;</span><br><span class="line">   90% &#123; <span class="attribute">margin-top</span>: -<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123; <span class="attribute">margin-top</span>: -<span class="number">200px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line"> <span class="attribute">animation</span>: dropdown <span class="number">8s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>css-自定义滚动条</title>
    <url>/2018/11/22/css/css-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-初衷"><a href="#1-初衷" class="headerlink" title="1. 初衷"></a>1. 初衷</h3><p>   做了几年的前端了，做笔记都是在自己的网盘里面记录，每次翻原来的笔记，总感觉差了点什么，突然有一天，一声惊雷闪过，文字依旧是那点文字，读者只有唯一，为什么不能分享出来，分享踩过的坑，希望能帮助到正在看的你。</p>
<h3 id="2-为什么要自定义滚动条？"><a href="#2-为什么要自定义滚动条？" class="headerlink" title="2.为什么要自定义滚动条？"></a>2.为什么要自定义滚动条？</h3><p>一直觉得，滚动条用默认的就好了，没特殊需求为啥要自定义呢？之前做过一个自定义表格，功能有：超出一定的高度滚动起来，表头固定，没列有自定义右键菜单，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-f5dd600e4ca7a183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="windows端自定义表格"><br>最近入手一台Mac，再看原来的代码，Mac竟然如此神奇，滚动条不占位置，还会显示隐藏，而我自定义的表格在Mac端出问题，因为表格自定义，使用的ul、li模拟的表格，滚动条在windows端占位，到Mac端不占位了，故出现表头和内容不对齐情况，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-7254682ee119f345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mac端自定义表格"><br>图中是有滚动条的，因Mac默认隐藏，故滚动条的<code>17px</code>导致错行。</p>
<h3 id="3-实现Mac端滚动条兼容"><a href="#3-实现Mac端滚动条兼容" class="headerlink" title="3. 实现Mac端滚动条兼容"></a>3. 实现Mac端滚动条兼容</h3><p>   要做到同时兼容windows和Mac，那么可以自定义滚动条，做法很简单，在全局的css样式中加入下面代码即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//自动移滚动条样式</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span>&#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,.<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span>&#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、::-webkit-scrollbar   定义了滚动条整体的样式；<br>2、::-webkit-scrollbar-thumb  滑块部分；<br>3、::-webkit-scrollbar-thumb  轨道部分；</p>
<p>加上这个代码，在看下效果，自定义表格完美兼容Mac。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-2e90bfc309a207a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>自定义滚动条有很多方式，这里只是展示了个人觉得比较简单的，还有很多插件可以实现，有兴趣的朋友可以自己玩一下。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js-数据结构-栈</title>
    <url>/2018/12/17/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做前端已有几年的时间，各种前端技术学了一堆，换着技术开发网站，感觉自己很牛逼的样子。这段时间总感觉到达了瓶颈，怎么也突破不了，冷静想了下。功能的实现、封装什么都没问题，但是就是算法差强人意。把大学的数据结构拿出来翻了下，这阶段再去看算法，比大学期间清楚太多了，很多原来知道有那回事儿，现在能明白用途在什么地方。我想我找到了突破瓶颈的方式了。从这篇文章开始，我会陆续的把数据结构中的算法用原生js实现。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈是一种数据结构，栈只有一个入口和一个出口，它的特点是<code>LIFO(后入先出)</code>，即比如我们吃的罐装薯片，只有从顶部一片一片的拿出来，才能拿到底部。因为栈的<code>LIFO</code>的特点，所有任何不在栈顶元素都无法访问到，为了得到栈底元素，必须把上面的元素都拿走，才能访问。而栈是一种列表，在js中，可以通过数据的方式来存储。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这儿便有思路了，首先需要一个<code>data</code>存储数据，data是一个数组，因栈只能访问栈顶元素，需要一个变量<code>top</code>存储栈顶元素的位置，当入栈时<code>top + 1</code>,当出栈时，<code>top - 1</code>，那么入栈需要一个方法<code>s_push</code>,出栈需要一个方法<code>s_pop</code>，还需返回栈顶元素的方法<code>s_peek</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，需要清空栈、获取栈的长度或判断元素是否在栈内，以上方法是不够的，还需创建方法，s_clear(清空栈内元素)、s_length(获取栈的长度）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 首先，需要创建一个Stack类的构造函数，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s_top = <span class="number">0</span>; <span class="comment">//初始化栈顶位置为0</span></span><br><span class="line">    <span class="keyword">this</span>.s_data = [];   <span class="comment">//初始化空栈</span></span><br><span class="line">    <span class="keyword">this</span>.s_push = s_push;   <span class="comment">//入栈方法</span></span><br><span class="line">    <span class="keyword">this</span>.s_pop = s_pop;     <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">this</span>.s_peek = s_peek; <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="keyword">this</span>.s_length = s_length; <span class="comment">//栈的长度</span></span><br><span class="line">    <span class="keyword">this</span>.s_clear = s_clear; <span class="comment">//清空栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 入栈，实现s_push方法，当向栈中压入新元素时，需要改变s_top对应栈的位置加1，然后指向数组下一个空位置。如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s_push</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s_data[<span class="keyword">this</span>.s_top++] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 出栈，s_pop方法和入栈相仿，每次取出元素后，将s_top - 1，然后返回当前删除的值，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s_pop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    --<span class="keyword">this</span>.s_top;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.s_data.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 获取栈顶元素，s_peek方法，栈顶的位置为s_top,只需要数组中取最后一个元素即可，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s_peek</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.s_data[<span class="keyword">this</span>.s_top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 清空栈，s_clear方法，设置栈顶指向为0，清空存储数据，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s_clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s_top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.s_data = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 获取栈的长度，s_length, 即s_top的值，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s_length</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.s_top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h6 id="1-使用栈模拟递归"><a href="#1-使用栈模拟递归" class="headerlink" title="1. 使用栈模拟递归"></a>1. 使用栈模拟递归</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如需要封装一个阶乘的函数，用递归的思想，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num !== <span class="string">'number'</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如果用栈的方式如何处理呢？只需将给定的数递减到1入栈，然后每次s_pop的时候会返回栈顶元素，循环栈，然后将s_pop的值相乘即可，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num !== <span class="string">'number'</span>) <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="keyword">new</span> Stack(),</span><br><span class="line">        facNum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s.s_push(num--);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">while</span> (s.s_length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        facNum *= s.s_pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> facNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2-判断回文"><a href="#2-判断回文" class="headerlink" title="2. 判断回文"></a>2. 判断回文</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说下什么是回文，把相同的字符串或句子颠倒过来，产生首尾循环的句子，意思就是正序和倒叙的结果一样。如何使用栈的思想实现回文呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈的方法有一个pop操作，每次pop返回栈顶元素。那么可以将字符串先push进栈，然后pop即可得到一个逆序的字符串，比较是否相等即可，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">let</span> reverseStr = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        s.s_push(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s.s_length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        reverseStr += s.s_pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverseStr === str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用栈的思想可以很方便的实现很多功能，比如判断表达式是否括号匹配等？不过说实话，在前端页面的开发中，用不到这些。有兴趣可以玩下，可以提升思维逻辑。</p>
]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>js-数据结构-链表</title>
    <url>/2019/02/22/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一 个节点的引用叫做链表。其中链表分为<strong>基本链表、双向链表及循环链表</strong>，如下图：<br><img src="/images/dataStructure/linkedList.jpg" alt="LinkedList"></p>
<h3 id="基本链表"><a href="#基本链表" class="headerlink" title="基本链表"></a>基本链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过，栈和队列使用数组模拟，在JavaScript中数组被模拟成对象，相比于其他语言（如java或C++），效率明显低了很多，如果使用数组比较慢的情况，那么就应该使用链表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先定义一个链表，链表中包含两个节点，Node类表示头节点，LinkedList类提供链表的插入、删除、查找、显示等辅助方法。</p>
<h5 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node类包含两个属性：element属性用来保存节点上的元素，next属性指向下一个节点，Node的构造函数实现，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  节点构造函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedList类提供了链表的<strong>插入、删除、查找、显示</strong>等操作，LinkedList类的构造函数实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  链表构造函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.findPrev = findPrev;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认head节点指向为空，当有节点插入时指向下一个节点，find方法为查找链表指定元素，insert方法指在链表指定节点后插入元素，findPrev方法指查找链表上一个元素，remove方法指删除指定元素，display方法指遍历链表，显示链表元素。</p>
<h5 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a>find方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find方法用于遍历链表，查找指定元素，并返回指定元素节点，实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  遍历链表，查找链表指定节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头节点开始遍历，查找到给定元素，结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (currNode.element !== item) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>find()</strong>演示了遍历链表的过程。</p>
<h5 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入节点前，首先需要创建一个新节点，将链表头节点复值给新创建节点，并查找指定元素(<strong>find()</strong>)，在指定元素后插入新节点。插入方法，将新节点的next指向当前元素的next，当前元素的next指向新节点。如图：</p>
<p><img src="/images/dataStructure/insert.jpg" alt="链表的插入"><br>代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  在链表指定节点中插入元素</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">    <span class="keyword">var</span> currentNode = <span class="keyword">this</span>.find(item);</span><br><span class="line">    newNode.next = currentNode.next;</span><br><span class="line">    newNode.previous = currentNode;</span><br><span class="line">    currentNode.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="display方法"><a href="#display方法" class="headerlink" title="display方法"></a>display方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;display方法用于显示链表上的节点，故需要遍历链表，每次循环打印出当前节点，并将当前节点的next指向下一个节点，直到null时结束。代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  展示链表的所有元素</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currNode.next.element + <span class="string">','</span>);</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="findPrev方法"><a href="#findPrev方法" class="headerlink" title="findPrev方法"></a>findPrev方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findPrev方法查找链表指定节点的前一个元素，并返回该节点。遍历链表，如果当前节点的下一个元素的element等于指定元素，择找到指定元素的前一个元素，返回。代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  查找指定元素上一个元素</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPrev</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currNode.next !== <span class="literal">null</span> &amp;&amp; currNode.next.element !== item) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove方法删除指定元素，在删除指定元素前需要找到指定元素的前一个元素，并改变前一个元素的指针，将前一个元素的next指向前一个元素的next的next，如图：</p>
<p><img src="/images/dataStructure/remove.jpg" alt="链表删除"><br>代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  删除链表指定元素</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prevNode = <span class="keyword">this</span>.findPrev(item);</span><br><span class="line">    <span class="keyword">if</span> (prevNode.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里基本链表的常用方法已经完成，该是测试代码的时候了，做点简单的增删功能试试。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设需要向链表中依此插入A、B、C、D，然后在A的后面插入H，删除B和C。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> city = <span class="keyword">new</span> LList();</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'插入'</span>);</span><br><span class="line">city.insert(<span class="string">'A'</span>, <span class="string">'head'</span>);</span><br><span class="line">city.insert(<span class="string">'B'</span>, <span class="string">'A'</span>);</span><br><span class="line">city.insert(<span class="string">'C'</span>, <span class="string">'B'</span>);</span><br><span class="line">city.insert(<span class="string">'D'</span>, <span class="string">'C'</span>);</span><br><span class="line">city.insert(<span class="string">'H'</span>, <span class="string">'A'</span>);</span><br><span class="line">city.display();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-----------------'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'删除'</span>);</span><br><span class="line">city.remove(<span class="string">'B'</span>);</span><br><span class="line">city.remove(<span class="string">'C'</span>);</span><br><span class="line">city.display();</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><img src="/images/dataStructure/insert_or_remove_test.png" alt="例子"></p>
]]></content>
      <categories>
        <category>js数据结构</category>
      </categories>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>IE下input框后面默认带有X，去除方法</title>
    <url>/2018/09/12/css/IE%E4%B8%8Binput%E6%A1%86%E5%90%8E%E9%9D%A2%E9%BB%98%E8%AE%A4%E5%B8%A6%E6%9C%89X%EF%BC%8C%E5%8E%BB%E9%99%A4%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在IE9下，input框带有X,如何去除？<br><img src="https://upload-images.jianshu.io/upload_images/12926544-6a5a267109999018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180912105825.png"></p>
<p>去除IE下input带x的方法，很简单，只需要css中加一句话就行了<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//去除IE下input框后面的X</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-ms-clear</span>, <span class="selector-tag">input</span><span class="selector-pseudo">::-ms-reveal</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js-数据结构-队列</title>
    <url>/2018/12/18/dataStructure/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲过使用js模拟栈的算法，今天主要讲，使用js模拟队列的算法，为什么要这样做呢？说实话是闲的无聊，现在处于一个项目空档期，为了不至于太无聊，就想把数据结构里面的算法都使用js模拟一遍。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h6 id="1、什么是队列？"><a href="#1、什么是队列？" class="headerlink" title="1、什么是队列？"></a>1、什么是队列？</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象中午食堂吃饭时、等电梯时、早晚高峰进地铁时，都需要排队。那么肯定是先排队的有优先权，然后依次进入。队列也是这个道理，只有一个出口，一个入口，特点是<code>先进先出</code>，这和栈的思想相反。明白了队列的特点，分析如何使用js实现队列？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列有一个入口，取名为<code>enqueue</code>;出口取名为<code>dequeue</code>;正常情况下，还需要读取队首和队尾元素，命名为<code>front</code>和<code>back</code>，读取队列所有元素，命名为<code>toStringData</code>, 判断队列是否空，命名为<code>isEmpty</code>。现在可以完成队列的构造函数了，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">    <span class="keyword">this</span>.enqueue = enqueue;  <span class="comment">//队尾添加一个元素</span></span><br><span class="line">    <span class="keyword">this</span>.dequeue = dequeue;  <span class="comment">//队首删除一个元素</span></span><br><span class="line">    <span class="keyword">this</span>.front = front;  <span class="comment">//读取队首元素</span></span><br><span class="line">    <span class="keyword">this</span>.back = back;  <span class="comment">//读取队尾元素</span></span><br><span class="line">    <span class="keyword">this</span>.toStringData = toStringData;  <span class="comment">//显示队内元素</span></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = isEmpty;  <span class="comment">//判断队列是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2、使用enqueue-方法，在队尾添加一个元素，如下："><a href="#2、使用enqueue-方法，在队尾添加一个元素，如下：" class="headerlink" title="2、使用enqueue()方法，在队尾添加一个元素，如下："></a>2、使用enqueue()方法，在队尾添加一个元素，如下：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueue</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3、使用dequeue-方法，在队首删除一个元素，并返回删除的值，如下："><a href="#3、使用dequeue-方法，在队首删除一个元素，并返回删除的值，如下：" class="headerlink" title="3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下："></a>3、使用dequeue()方法，在队首删除一个元素，并返回删除的值，如下：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dequeue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4、使用front-方法，返回队首元素，如下："><a href="#4、使用front-方法，返回队首元素，如下：" class="headerlink" title="4、使用front()方法，返回队首元素，如下："></a>4、使用front()方法，返回队首元素，如下：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">front</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">``</span><span class="string">`JavaScript</span></span><br><span class="line"><span class="string">###### 5、使用back()方法，返回队尾元素，如下：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>JavaScript</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="keyword">this</span>.data.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="6、使用toStringData-方法，返回队列元素，如下："><a href="#6、使用toStringData-方法，返回队列元素，如下：" class="headerlink" title="6、使用toStringData()方法，返回队列元素，如下："></a>6、使用toStringData()方法，返回队列元素，如下：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toStringData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queueString = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.data.length; i++) &#123;</span><br><span class="line">        queueString += <span class="keyword">this</span>.data[i] + <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queueString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="7、使用isEmpty-方法，判断队列是否为空，如下："><a href="#7、使用isEmpty-方法，判断队列是否为空，如下：" class="headerlink" title="7、使用isEmpty()方法，判断队列是否为空，如下："></a>7、使用isEmpty()方法，判断队列是否为空，如下：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmpty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，就使用js实现了一个单向队列。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h6 id="1、使用队列进行排序（基数排序）"><a href="#1、使用队列进行排序（基数排序）" class="headerlink" title="1、使用队列进行排序（基数排序）"></a>1、使用队列进行排序（基数排序）</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先介绍下什么是<code>基数排序</code>，基数排序又叫<code>分配式排序</code>或<code>桶子法</code>，它是通过数据的部分信息，将要排序的元素分配至<code>桶</code>中，以达到排序的作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一串数值，如下所示：</p>
<pre><code>98、25、31、10、99、81、65、42、51
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>： <span class="number">10</span></span><br><span class="line"><span class="number">1</span>： <span class="number">31</span> <span class="number">81</span> <span class="number">51</span></span><br><span class="line"><span class="number">2</span>： <span class="number">42</span></span><br><span class="line"><span class="number">3</span>：</span><br><span class="line"><span class="number">4</span>：</span><br><span class="line"><span class="number">5</span>： <span class="number">25</span> <span class="number">65</span></span><br><span class="line"><span class="number">6</span>：</span><br><span class="line"><span class="number">7</span>：</span><br><span class="line"><span class="number">8</span>： <span class="number">98</span></span><br><span class="line"><span class="number">9</span>： <span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些桶子中的数值串接起来，如下所示：<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">31</span> <span class="number">81</span> <span class="number">51</span> <span class="number">42</span> <span class="number">25</span> <span class="number">65</span> <span class="number">98</span> <span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着根据十位数在进行一次分配，如下所示：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：</span><br><span class="line"><span class="number">1</span>： <span class="number">10</span></span><br><span class="line"><span class="number">2</span>： <span class="number">25</span></span><br><span class="line"><span class="number">3</span>： <span class="number">31</span></span><br><span class="line"><span class="number">4</span>： <span class="number">42</span></span><br><span class="line"><span class="number">5</span>： <span class="number">51</span></span><br><span class="line"><span class="number">6</span>： <span class="number">65</span></span><br><span class="line"><span class="number">7</span>：</span><br><span class="line"><span class="number">8</span>： <span class="number">81</span></span><br><span class="line"><span class="number">9</span>： <span class="number">98</span> <span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将这些数值串接起来，形成以下数值：<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">10 </span><span class="number">25</span> <span class="number">31</span> <span class="number">42</span> <span class="number">51</span> <span class="number">65</span> <span class="number">81</span> <span class="number">98</span> <span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候排序已经完成；如果有三位数或这更高位数，则持续进行以上动作，直至最高位为止。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何使用队列的思想进行排序呢？假设是0～99间的数进行比较，首先需要比较个位数，因为数值在0～99之间，只需对数进行<code>取余</code>,即可得到个位数，对数值除以10，向下取整可得到十位数。到这儿开始使用队列(<code>桶</code>)进行存值，需要是个队列分别存储0～9的值。如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param </span>nums 初始数组</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param </span>queue 队列数组</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param </span>n 几位数</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param </span>digit 个位数或十位以上的数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distribute</span> (<span class="params">nums, queue, n, digit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digit === <span class="number">1</span>) &#123;</span><br><span class="line">            queue[nums[i] % <span class="number">10</span>].enqueue(nums[I]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue[<span class="built_in">Math</span>.floor(nums[i] / <span class="number">10</span>)].enqueue(nums[I]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序后展示函数，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param </span>queues 队列数组</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@nums </span>nums 初始数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAfterData</span> (<span class="params">queues, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> digit = <span class="number">0</span>; digit &lt; <span class="number">10</span>; ++digit) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queues[digit].isEmpty()) &#123;</span><br><span class="line">            nums[i++] = queues[digit].dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成算法后，随机来点数实验下，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queues = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    queues[i] = <span class="keyword">new</span> Queue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> nums = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    nums[i] = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">101</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'个位数排序：'</span>);</span><br><span class="line">distribute(nums, queues, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(collect(queues, nums));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'十位数排序：'</span>);</span><br><span class="line">distribute(nums, queues, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(collect(queues, nums));</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-66be795cfa8c3659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基数排序结果"></p>
<h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双向队列即队列的首尾都能进能出，那么只需在单向队列中添加两个方法，队首添加一个元素方法(<code>fenqueue</code>)，队尾删除一个元素的方法(‘bdequeue’),即可.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列的构造函数添加两个方法，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.data = [];</span><br><span class="line">     <span class="keyword">this</span>.enqueue = enqueue;  <span class="comment">//队尾添加一个元素</span></span><br><span class="line">     <span class="keyword">this</span>.dequeue = dequeue;  <span class="comment">//队首删除一个元素</span></span><br><span class="line">     <span class="string">`this.fenqueue = fenqueue;  //队首添加一个元素`</span></span><br><span class="line">     <span class="string">`this.bdequeue = bdequeue;  //队尾删除一个元素`</span></span><br><span class="line">     <span class="keyword">this</span>.front = front;  <span class="comment">//读取队首元素</span></span><br><span class="line">     <span class="keyword">this</span>.back = back;  <span class="comment">//读取队尾元素</span></span><br><span class="line">     <span class="keyword">this</span>.toStringData = toStringData;  <span class="comment">//显示队内元素</span></span><br><span class="line">     <span class="keyword">this</span>.isEmpty = isEmpty;  <span class="comment">//判断队列是否为空</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fenqueue</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.unshift(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bdequeue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在就完成了双向队列。双向队列能实现什么功能呢？如回文之类的使用双向队列能很方便的实现，思想如上一片文章中的栈，使用双向队列无论从前还是后插入数据，都一个原理。</p>
]]></content>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery_Dialog封装</title>
    <url>/2019/03/01/jQuery/Dialog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="jQuery自定义Dialog封装"><a href="#jQuery自定义Dialog封装" class="headerlink" title="jQuery自定义Dialog封装"></a>jQuery自定义Dialog封装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段时间维护以前jQuery写的网站，里面涉及到很多弹框的功能，为方便使用jQuery封装了个模态框，模态框的封装主要使用构造函数和原型链结合的方式实现，然后在window和jQuery上扩展该方法，首先看一下效果：<br><img src="/images/jquery/dialog.jpg" alt="dialog"></p>
<p>构造函数代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">element, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ele = element;</span><br><span class="line">    <span class="keyword">this</span>.config = &#123;</span><br><span class="line">        title: <span class="string">'信息提示框'</span>,</span><br><span class="line">        maskClick: <span class="literal">false</span>,</span><br><span class="line">        width: <span class="number">500</span>,</span><br><span class="line">        height: <span class="string">'auto'</span>,</span><br><span class="line">        content: <span class="string">''</span>,</span><br><span class="line">        isHeader: <span class="literal">true</span>,</span><br><span class="line">        isFooter: <span class="literal">true</span>,</span><br><span class="line">        onlyConfirm: <span class="literal">false</span>,</span><br><span class="line">        isContentCenter: <span class="literal">false</span>,</span><br><span class="line">        isConfirmClose: <span class="literal">true</span>,</span><br><span class="line">        isShowConnect: <span class="literal">false</span>,</span><br><span class="line">        confirmName: <span class="string">'确认'</span>,</span><br><span class="line">        cancelName: <span class="string">'取消'</span>,</span><br><span class="line">        connectionName: <span class="string">'连接测试'</span>,</span><br><span class="line">        confirmCallback: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        cancelCallback: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        connctionCallback: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//扩展默认参数</span></span><br><span class="line">    <span class="keyword">if</span> (config &amp;&amp; $.isPlainObject(config)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.config = $.extend(&#123;&#125;, <span class="keyword">this</span>.config, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原型链上的方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dialog.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        _this.create();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//创建弹框</span></span><br><span class="line">    create: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//事件绑定</span></span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//关闭弹窗</span></span><br><span class="line">    closeMask: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>window和jQuery上扩展：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装到window对象上</span></span><br><span class="line"><span class="built_in">window</span>.Dialog = Dialog;</span><br><span class="line"><span class="comment">//封装到jquery对象上</span></span><br><span class="line">$.fn.Dialog = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dialog = <span class="keyword">new</span> Dialog(<span class="keyword">this</span>, config);</span><br><span class="line">    <span class="keyword">return</span> dialog.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h6 id="1-基础弹框"><a href="#1-基础弹框" class="headerlink" title="1. 基础弹框"></a>1. 基础弹框</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">'body'</span>).Dialog(&#123;</span><br><span class="line">    <span class="symbol">content:</span> <span class="string">'基础弹框测试'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>content</code>表示弹框的内容区，可自定义</p>
<h6 id="2-基础弹框测试-内容居中"><a href="#2-基础弹框测试-内容居中" class="headerlink" title="2. 基础弹框测试(内容居中)"></a>2. 基础弹框测试(内容居中)</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">'body'</span>).Dialog(&#123;</span><br><span class="line">    <span class="symbol">title:</span> <span class="string">'基础弹框(内容居中）'</span>,</span><br><span class="line">    <span class="symbol">content:</span> <span class="string">'基础弹框测试'</span>,</span><br><span class="line">    <span class="symbol">isContentCenter:</span> <span class="keyword">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>title</code>弹框的标题， isContentCenter表示是否居中，true为居中，默认为false</p>
<h6 id="3-不显示头部弹框"><a href="#3-不显示头部弹框" class="headerlink" title="3. 不显示头部弹框"></a>3. 不显示头部弹框</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('body').Dialog(&#123;</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'弹框测试'</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isContentCenter:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isHeader:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><code>isHeader</code>是否显示头部，true为显示，默认为true</p>
<h6 id="4-不显示底部弹框"><a href="#4-不显示底部弹框" class="headerlink" title="4. 不显示底部弹框"></a>4. 不显示底部弹框</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('body').Dialog(&#123;</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'不显示底部'</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isContentCenter:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isFooter:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><code>isFooter</code>是否显示底部，true为显示，默认为true</p>
<h6 id="5-点击空白关闭弹窗"><a href="#5-点击空白关闭弹窗" class="headerlink" title="5. 点击空白关闭弹窗"></a>5. 点击空白关闭弹窗</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('body').Dialog(&#123;</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'点击空白关闭弹窗'</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isContentCenter:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">maskClick:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><code>maskClick</code>点击背景是否关闭弹窗，true为点击能关闭，默认false</p>
<h6 id="6-确认和取消回调"><a href="#6-确认和取消回调" class="headerlink" title="6. 确认和取消回调"></a>6. 确认和取消回调</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).Dialog(&#123;</span><br><span class="line">    content: <span class="string">'确认和取消回调'</span>,</span><br><span class="line">    isContentCenter: <span class="literal">true</span>,</span><br><span class="line">    maskClick: <span class="literal">true</span>,</span><br><span class="line">    confirmName: <span class="string">'点我确认'</span>,</span><br><span class="line">    cancelName: <span class="string">'点我取消'</span>,</span><br><span class="line">    confirmCallback: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'确认'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    cancelCallback: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'取消'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>confirmCallback</code>确认回调；<code>cancelCallback</code>取消回调</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h6 id="1-参数"><a href="#1-参数" class="headerlink" title="1. 参数"></a>1. 参数</h6><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
<th style="text-align:right">类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">标题</td>
<td style="text-align:right">string</td>
<td>信息提示框</td>
</tr>
<tr>
<td>maskClick</td>
<td style="text-align:center">点击背景是否关闭弹窗</td>
<td style="text-align:right">Boolean</td>
<td>false</td>
</tr>
<tr>
<td>content</td>
<td style="text-align:center">弹框内容，可添加HTML元素</td>
<td style="text-align:right">–</td>
<td>–</td>
</tr>
<tr>
<td>isHeader</td>
<td style="text-align:center">是否显示头部：true为显示</td>
<td style="text-align:right">Boolean</td>
<td>true</td>
</tr>
<tr>
<td>isFooter</td>
<td style="text-align:center">是否显示底部：true为显示</td>
<td style="text-align:right">Boolean</td>
<td>true</td>
</tr>
<tr>
<td>isContentCenter</td>
<td style="text-align:center">内容区是否水平居中显示，true为水平居中</td>
<td style="text-align:right">Boolean</td>
<td>false</td>
</tr>
<tr>
<td>onlyConfirm</td>
<td style="text-align:center">是否只显示确认按钮</td>
<td style="text-align:right">Boolean</td>
<td>false</td>
</tr>
<tr>
<td>confirmName</td>
<td style="text-align:center">确认按钮名称</td>
<td style="text-align:right">string</td>
<td>确认</td>
</tr>
<tr>
<td>cancelName</td>
<td style="text-align:center">取消按钮名称</td>
<td style="text-align:right">string</td>
<td>取消</td>
</tr>
</tbody>
</table>
<h6 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h6><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>confirmCallback</td>
<td style="text-align:left">确认回调</td>
</tr>
<tr>
<td>cancelCallback</td>
<td style="text-align:left">取消回调</td>
</tr>
</tbody>
</table>
<p>完整代码已经上传到GitHub上，有兴趣可以<strong><a href="https://github.com/zhuLni/Dialog" target="_blank" rel="noopener">狠狠的点击这儿</a></strong>。</p>
]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery_Pagination封装</title>
    <url>/2019/03/11/jQuery/Pagination/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Pagination封装"><a href="#Pagination封装" class="headerlink" title="Pagination封装"></a>Pagination封装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段时间维护以前jQuery做的网站，优化了下分页的封装，主要使用的思想：构造函数+原型链的方式，将封装好的方法挂在到jQuery和window上，先上一个图：<br><img src="/images/jquery/pagination.jpg" alt="Pagination"></p>
<p>构造函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pagination</span> (<span class="params">element, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ele = element;</span><br><span class="line">    <span class="keyword">this</span>.config = &#123;</span><br><span class="line">        currentPage: <span class="number">1</span>,</span><br><span class="line">        numberOfPages: <span class="number">3</span>,</span><br><span class="line">        total: <span class="number">1</span>,</span><br><span class="line">        isJumpPage: <span class="literal">true</span>,</span><br><span class="line">        jumpItems: &#123;</span><br><span class="line">            jumpTo: <span class="string">'jump to'</span>,</span><br><span class="line">            page: <span class="string">'page'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        itemTexts: &#123;</span><br><span class="line">            first: <span class="string">'&amp;lt;&amp;lt;'</span>,</span><br><span class="line">            prev: <span class="string">'&amp;lt;'</span>,</span><br><span class="line">            next: <span class="string">'&amp;gt;'</span>,</span><br><span class="line">            last: <span class="string">'&amp;gt;&amp;gt;'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onPageChanged: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (config &amp;&amp; $.isPlainObject(config)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.config = $.extend(&#123;&#125;, <span class="keyword">this</span>.config, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原型方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Pagination.prototype = &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  创建分页</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    createPagination: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  事件绑定</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//分页事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>window和jQuery上扩展：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.Pagination = Pagination;</span><br><span class="line">$.fn.Pagination = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pagination = <span class="keyword">new</span> Pagination(<span class="keyword">this</span>, config);</span><br><span class="line">    <span class="keyword">return</span> pagination.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h6 id="1-基础分页"><a href="#1-基础分页" class="headerlink" title="1. 基础分页"></a>1. 基础分页</h6><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">'.basePagination'</span>).Pagination(&#123;</span><br><span class="line">    <span class="symbol">isJumpPage:</span> <span class="keyword">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>isJumpPage</code>是否显示可跳转输入框，默认true</p>
<h6 id="2-跳转指定页"><a href="#2-跳转指定页" class="headerlink" title="2. 跳转指定页"></a>2. 跳转指定页</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('.pagePagination').Pagination(&#123;</span></span><br><span class="line">    <span class="attr">currentPage:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">    <span class="attr">numberOfPages:</span> <span class="number">3</span><span class="string">,</span></span><br><span class="line">    <span class="attr">total:</span> <span class="number">6</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isJumpPage:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><code>currentPage</code>当前页， numberOfPages中间显示个数(只能大于3的奇数)，total总页数</p>
<h6 id="3-文字设置"><a href="#3-文字设置" class="headerlink" title="3. 文字设置"></a>3. 文字设置</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('.setPaginationWord').Pagination(&#123;</span></span><br><span class="line">    <span class="attr">currentPage:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">    <span class="attr">numberOfPages:</span> <span class="number">3</span><span class="string">,</span></span><br><span class="line">    <span class="attr">total:</span> <span class="number">9</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isJumpPage:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">itemTexts:</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">first:</span> <span class="string">'首页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">prev:</span> <span class="string">'上一页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">next:</span> <span class="string">'下一页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">last:</span> <span class="string">'最后一页'</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="attr">jumpItems:</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">jumpTo:</span> <span class="string">'跳转到'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">page:</span> <span class="string">'页'</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<h6 id="4-跳转回调"><a href="#4-跳转回调" class="headerlink" title="4. 跳转回调"></a>4. 跳转回调</h6><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$('.jumpPaginationCallBack').Pagination(&#123;</span></span><br><span class="line">    <span class="attr">currentPage:</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line">    <span class="attr">numberOfPages:</span> <span class="number">3</span><span class="string">,</span></span><br><span class="line">    <span class="attr">total:</span> <span class="number">12</span><span class="string">,</span></span><br><span class="line">    <span class="attr">isJumpPage:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">itemTexts:</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">first:</span> <span class="string">'首页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">prev:</span> <span class="string">'上一页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">next:</span> <span class="string">'下一页'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">last:</span> <span class="string">'最后一页'</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="attr">jumpItems:</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">jumpTo:</span> <span class="string">'跳转到'</span><span class="string">,</span></span><br><span class="line">        <span class="attr">page:</span> <span class="string">'页'</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="attr">onPageChanged:</span> <span class="string">function</span> <span class="string">(option,</span> <span class="string">element)</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">console.log(option);</span></span><br><span class="line">        <span class="string">console.log(element);</span></span><br><span class="line">        <span class="string">alert(`跳转到$&#123;option.currentPage&#125;页`);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><code>isFooter</code>是否显示底部，true为显示，默认为true</p>
<h6 id="5-参数"><a href="#5-参数" class="headerlink" title="5. 参数"></a>5. 参数</h6><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
<th style="text-align:right">类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>currentPage</td>
<td style="text-align:center">当前页</td>
<td style="text-align:right">Number</td>
<td>1</td>
</tr>
<tr>
<td>numberOfPages</td>
<td style="text-align:center">中间显示个数(只能是大于3的奇数)</td>
<td style="text-align:right">Number</td>
<td>3</td>
</tr>
<tr>
<td>total</td>
<td style="text-align:center">总页数</td>
<td style="text-align:right">Number</td>
<td>1</td>
</tr>
<tr>
<td>isJumpPage</td>
<td style="text-align:center">是否显示跳转页：true为显示</td>
<td style="text-align:right">Boolean</td>
<td>true</td>
</tr>
<tr>
<td>jumpItems:{jumpTo,page}</td>
<td style="text-align:center">跳转文本</td>
<td style="text-align:right">string</td>
<td>jump to、page</td>
</tr>
<tr>
<td>itemTexts{first、prev、next、last}</td>
<td style="text-align:center">文本</td>
<td style="text-align:right">string</td>
<td>&lt;&lt;、&lt;、&gt;、&gt;&gt;</td>
</tr>
</tbody>
</table>
<h6 id="6-方法"><a href="#6-方法" class="headerlink" title="6. 方法"></a>6. 方法</h6><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onPageChanged(option, element)</td>
<td style="text-align:left">选中回调(option：当前选中页的回调信息，element:分页DOM)</td>
</tr>
</tbody>
</table>
<p>完整代码已经上传到GitHub上，有兴趣可以<strong><a href="https://github.com/zhuLni/Pagination" target="_blank" rel="noopener">狠狠的点击这儿</a></strong>。</p>
]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖函数和节流函数</title>
    <url>/2019/02/27/js/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E5%92%8C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、初次接触防抖和节流函数"><a href="#一、初次接触防抖和节流函数" class="headerlink" title="一、初次接触防抖和节流函数"></a>一、初次接触防抖和节流函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初次使用防抖和节流函数，之前做一个react项目时，有一块功能是这样的：notebook的每一个新建功能都是新的窗口，每一个编辑框下能支持Python和R语法，编辑框有初始高度，当编辑框内容增多时编辑框会随着增大。即功能要这样做，每一次keyDown时，我都会动态改变高度，再次渲染，那么出现个问题，每一个keyDown都会去更新一次react组件，如果用户一直按着enter时，会非常浪费性能。刚开始时，使用防抖函数，当时思路是每一次触发延迟200ms才能再次触发，似乎不够完善，节能函数便登场了。<br><img src="/images/js/jlsf.png" alt="节流算法来源"></p>
<h3 id="二、测试实例"><a href="#二、测试实例" class="headerlink" title="二、测试实例"></a>二、测试实例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说说为什么要使用防抖函数和节流函数，在网页开发过程中经常会遇到需要绑定触发某些功能的持续事件，如：mouseMove、scroll等事件，那么会很浪费性能，特别是极端情况下，这时就需要防抖和节流函数。防抖和节流函数都是优化事件高频执行的一种js方法。具体使用上面根据实际项目需求来。举个简单的例子，鼠标在浏览器上没move一次，count+1,如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"count"</span> style=<span class="string">"width: 100%; height: 500px; background-color: #ccc; font-size: 100px; color: #fff; display: flex; justify-content: center; align-items: center;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    let num = 1;</span></span><br><span class="line"><span class="regexp">    let aCount = document.getElementById('count');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    aCount.onmousemove = accumulation;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    function accumulation() &#123;</span></span><br><span class="line"><span class="regexp">        aCount.innerHTML = num++;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="/images/js/move.gif" alt="节流算法来源"><br>可以看到，每一次鼠标移动，函数都执行，这样频繁的执行，浪费了很多性能，特别是在大型项目中，如果电脑差点会导致网页卡顿的情况。</p>
<h3 id="三、防抖函数"><a href="#三、防抖函数" class="headerlink" title="三、防抖函数"></a>三、防抖函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>防抖是指函数在特定的时间内不再被调用执行</strong>。先看下函数，与原版有区别，原版使用的时call，这里使用的时apply。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, _this, delay</span>) </span>&#123;</span><br><span class="line">     clearTimeout(fn.timeoutId);</span><br><span class="line">     fn.timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         fn.apply(_this, <span class="built_in">arguments</span>)</span><br><span class="line">     &#125;, delay);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码<strong>fn</strong>表示需要执行的函数，<strong>_this</strong>表示当前对象，<strong>delay</strong>表示延迟时间，<strong>obj</strong>表示函数传入所需的参数。即每次触发事件，函数延迟执行指定时间执行一次。使用防抖函数执行上面例子，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aCount.onmousemove = debounce(accumulation, <span class="literal">null</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用防抖函数处理鼠标移动，数字叠加的情况，间隔时间200ms，快速移动鼠标，每次触发都在200ms内，那么屏幕上就不会有count累加。如下：<br><img src="/images/js/fd_img.gif" alt="test"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样和最初的想法有点背离，我想每次移动后，无论间隔是都在200ms内，我累加1，防抖函数无法实现。防抖函数的大多用途在表单验证的情况，用户输入后进行验证，是否合乎规定。错误则提示，如标红显示信息等。要实现上面的需求，需要使用节流函数。</p>
<h3 id="四、节流函数"><a href="#四、节流函数" class="headerlink" title="四、节流函数"></a>四、节流函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节流函数，<strong>节流是指在连续触发事件，但只在指定时间内执行一次</strong>。大多使用场景，如：输入框输入请求，监听页面元素滚动，鼠标事件等高频触发事件。那么使用节流无论change的间隔在200ms内还是在200ms外，间隔200ms都执行打印。如下所示：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment"> **  改进节流函数函数</span></span><br><span class="line"><span class="comment"> **  <span class="doctag">@param </span>fn 待执行的函数</span></span><br><span class="line"><span class="comment"> **  <span class="doctag">@param </span>context this</span></span><br><span class="line"><span class="comment"> **  <span class="doctag">@param </span>delay 延迟时间</span></span><br><span class="line"><span class="comment"> **  <span class="doctag">@param </span>text 输入框文本</span></span><br><span class="line"><span class="comment"> **  <span class="doctag">@param </span>applyTime 必须执行的时间</span></span><br><span class="line"><span class="comment"> ** **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, context, delay, text, applyTime</span>) </span>&#123;</span><br><span class="line">    clearTimeout(fn.timer);</span><br><span class="line">    fn._currTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录第一次执行的时间</span></span><br><span class="line">    <span class="keyword">if</span> (!fn._startTime) &#123;</span><br><span class="line">        fn._startTime = fn._currTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果时间间隔大于必须执行的时间，则执行，否则延迟执行</span></span><br><span class="line">    <span class="keyword">if</span> (fn._currTime - fn._startTime &gt; applyTime) &#123;</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">        fn._startTime = fn._currTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.call(context, text);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的问题调用如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aCount.onmousemove = throttle(accumulation, <span class="literal">null</span>, <span class="number">200</span>, val, <span class="number">200</span>);</span><br></pre></td></tr></table></figure></p>
<p>显示如下：<br><img src="/images/js/throttle_img.gif" alt="test"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就能完美解决无论什么情况都指定时间内执行。</p>
<h3 id="五、例子"><a href="#五、例子" class="headerlink" title="五、例子"></a>五、例子</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到最初的问题，编辑框每次<em>enter</em>时，更新组件，增加编辑框的高度；每次<em>backspace</em>时，<br>更新组件，减小编辑框的高度。单纯问题描述上看，对性能问题没什么太大的影响，我换个描述，问题就严重了。新增notebook会新开窗口，这儿是最外层，每个窗口下面有n个编辑框，然后再是正在编辑的编辑框，每一层都有很复杂的逻辑，我每次对编辑框keyDown时，首先需要找到对应的窗口，对应的编辑框，然后才改变编辑框的高度，貌似不是太复杂。但是我一直按着enter，每次都要从最外层组件开始更新，这样无疑浪费了很多性能。故优化方法，可使用防抖函数或节能函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里使用防抖函数会出现问题，假如使用防抖函数，即延时一定时间执行一次，假定时间为200ms，我一直按着enter，不断地再触发事件，间隔永远小于200ms，则一直不会执行。故这里应该使用节能函数，无论如何测试，设置特定的时间，那么每次在这个时间都会执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用一个打印输入框值得情况来模拟上面描述的问题，问题：用户在input中输入字符，每200ms就需打印输入的内容，实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inputValue:"</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aInput = <span class="built_in">document</span>.getElementById(<span class="string">'Input'</span>);</span><br><span class="line"></span><br><span class="line">aInput.addEventListener(<span class="string">'keyup'</span>, (e) =&gt; &#123;</span><br><span class="line">    throttle(test, <span class="literal">null</span>, <span class="number">200</span>, e.target.value, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样完美解决频繁触发造成性能浪费的问题，notebook项目的问题也以这种优雅的方式解决了。防抖和节能函数在实际项目中几乎都可以使用到，如果你看到了这儿，那么还等什么，快到你项目中使用吧。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/04/15/js/Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promise对象是异步编程的一种接口，promise对象可以异步操作成功或失败分别绑定相应的方法，每一个异步任务都是一个promise对象，该对象上有then、catch、reject、resolve、all、race等等方法，让异步操作可以像同步方法那样返回值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个promise可以有几种状态：</p>
<blockquote>
<p>pending: 初始状态，既不成功也不失败<br>fulfilled: 操作成功完成<br>rejected: 操作失败</p>
</blockquote>
<p>promise对象由构造方法+原型链组成，由于构造方法中的属性是不可重写、不可枚举，不可配置，因此只需要关注原型链上的方法。</p>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p><code>new Promise(function (resolve, reject) {//...})</code><br>resolve函数表示执行成功时调用<br>reject函数表示执行失败时调用</p>
<h3 id="三、then-方法"><a href="#三、then-方法" class="headerlink" title="三、then()方法"></a>三、then()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then方法是Promise链式调用的精髓，可以使用<code>.then()</code>的形式实现promise的链式调用，例子如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'异步操作1'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'异步操作2'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'异步操作3'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> p3;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><img src="/images/js/promise1.jpg" alt="promise"><br>上面的方式可以很优雅的实现异步操作，避免以回调实现异步的多层嵌套。</p>
<h3 id="四、catch-方法"><a href="#四、catch-方法" class="headerlink" title="四、catch()方法"></a>四、catch()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用resolve函数，可使用then()方法，接收resolve传过来的值，调用reject时，如何获取失败信息呢？Promise对象提供了catch方法，用于获取失败时的值。同样可使用链式的方式，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'异步操作失败1'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">(resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'异步操作失败2'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'异步操作失败3'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> p3;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/js/promise1.jpg" alt="promise"></p>
<h3 id="五、then-和catch-方法一起使用"><a href="#五、then-和catch-方法一起使用" class="headerlink" title="五、then()和catch()方法一起使用"></a>五、then()和catch()方法一起使用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个完整的Promise对象可以有可能成功，也有可能失败，then和catch结合使用，即可实现不同状态下的开发，如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxNumber</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (number &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">             resolve(<span class="string">'This number getter than '</span>+ number);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             reject(<span class="string">'This number less than '</span>+ number)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> getMaxNumber(<span class="number">101</span>)</span><br><span class="line">     .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))  <span class="comment">// This number getter than 101</span></span><br><span class="line">     .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"> getMaxNumber(<span class="number">99</span>)</span><br><span class="line">     .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">     .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)) <span class="comment">// This number less than 99</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码，当传入的值是大于等于100是，调用resolve函数，通过then的回调打印值；当传入值为99，小于100，调用reject函数，通过catch回调打印值。结果如下：<br><img src="/images/js/promise3.jpg" alt="promise"></p>
<h3 id="六、all-方法"><a href="#六、all-方法" class="headerlink" title="六、all()方法"></a>六、all()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promise.all()方法提供了并行执行异步操作的能力，并在所有异步操作执行完成后才执行回调。<br>如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'第一个异步操作！'</span>);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'第二个异步操作！'</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'第三个异步操作！'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p>
<p>三个异步操作执行完成后，才能执行then方法，回调参数以数组的形式返回三个异步执行结果。如果三个异步操作中存在一个调用reject函数，all方法执行catch，打印err信息，如果多个异步操作都调用reject函数，则catch回调返回花费时间最少的异步操作，该例子只是并行执行的结果，没有异常的信息，打印结果如下：</p>
<p><img src="/images/js/promise4.png" alt="promise"><br>从all方法的用法可以很容易看出，可使用all进行预加载的。</p>
<h3 id="七、race-方法"><a href="#七、race-方法" class="headerlink" title="七、race()方法"></a>七、race()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的all方法知道，all可以使异步操作并行执行，当每一个promise对象都调用了reject函数时，catch回调返回用时最少的异步值。race方法的也是以用时最少的异步执行完成就结束，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'第二个异步操作！'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'第二个异步值大于10'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            resolve(<span class="string">'第三个异步操作！'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'第三个异步值大于10'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面例子有三个异步操作，使用race方法执行，当a小于10时，三个异步操作同时执行，调用resolve函数，当第一个异步操作执行完成后，程序结束，因此最终的结果是返回p3的resolve返回的执行的结果，如果a大于10，那么三个promise对象都调用reject函数，则catch接收的值是p3返回的值。故无论调用reject还是resolve函数，最终得到的结果都是以最快执行完成的为准。<br>知道race方法的用法，那么有什么用呢？想象一下，假设我需要异步请求一张图片，该如何做呢？可以使用回调的方式，如果用race该如何做呢？<br>先看下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">            img.onLoad = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(img);</span><br><span class="line">            &#125;;</span><br><span class="line">            img.src = <span class="string">'xxxxxxxxxxxxx'</span>; <span class="comment">// 请换成可以请求的图片地址</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">'Picture request timeout！'</span>);</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.race([requestImg(), timeout(<span class="number">5000</span>)])</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br></pre></td></tr></table></figure></p>
<p>上面代码执行结果会抛出错误：<span style="color:red">Picture request timeout！</span><br>requestImg会异步请求一张图片，timeout会延时指定时间抛出错误，使用race方法让requestImg和timeout一起执行，看谁执行的快，如果先请求成功，则执行then方法，如果超时，则执行catch方法抛出错误。</p>
<h3 id="八、finally-方法"><a href="#八、finally-方法" class="headerlink" title="八、finally()方法"></a>八、finally()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally方法返回一个promise，在promise结束时，无论结果是成功(fulfilled)和失败(rejected)都会执行finally方法。那么finally的用途就是在promise执行完成后需要做一些处理时使用，具体例子就不给出了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>react-todoList实现</title>
    <url>/2018/11/13/react/react-todoList%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p> React作为当前最火的框架之一，学习和使用已有一段时间，在这里记录下学习React的心得，纯属个人观点。在学习React之前，了解过Vue,和angular，个人比较喜欢React的开发模式，之前的开发用的比较多jquery的模板（artTemplate,hogan）之类的，和React中的jsx原理类似，因此被吸引。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12926544-5d9dd940c034f2b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="一、-React的准备工作"><a href="#一、-React的准备工作" class="headerlink" title="一、 React的准备工作"></a>一、 React的准备工作</h2><p>   学习react有很多途径，可以看官网，可以看博客，可以看视频，这里比较推荐的做法是先看官网，了解基本知识后，做一些例子。然后再学习相关依赖，如<code>Redux、Mobx</code>之类的状态管理工具，之后的文章中会进一步讲解React相关依赖，有：<code>Redux、Mobx、Redux-thunk、Redux-saga、immutable、react-transition-group、antd、styled-components、prop-types</code>等。<br>   开始学习React需要一定的开发基础，如：<code>Es6、webpack</code>等。我学习React使用的是create-react-app脚手架，</p>
<h5 id="安装：npm-install-g-create-react-app"><a href="#安装：npm-install-g-create-react-app" class="headerlink" title="安装：npm install -g create-react-app"></a>安装：<code>npm install -g create-react-app</code></h5><h5 id="创建React应用：-create-react-app-my-app"><a href="#创建React应用：-create-react-app-my-app" class="headerlink" title="创建React应用： create-react-app my-app"></a>创建React应用： <code>create-react-app my-app</code></h5><pre><code>$ create-react-app my-app
Creating a new React app in G:\GitHub\React-demo\my-app.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts...
</code></pre><h6 id="1、主要依赖react-react-dom-react-scripts"><a href="#1、主要依赖react-react-dom-react-scripts" class="headerlink" title="1、主要依赖react,react-dom,react-scripts"></a>1、主要依赖react,react-dom,react-scripts</h6><h6 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h6><p><img src="https://upload-images.jianshu.io/upload_images/12926544-b447353bf665529b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h6 id="3、运行-npm-start"><a href="#3、运行-npm-start" class="headerlink" title="3、运行 npm start"></a>3、运行 <code>npm start</code></h6><h6 id="4、打包-npm-run-build"><a href="#4、打包-npm-run-build" class="headerlink" title="4、打包 npm run build"></a>4、打包 <code>npm run build</code></h6><h2 id="二、正式开发"><a href="#二、正式开发" class="headerlink" title="二、正式开发"></a>二、正式开发</h2><p>1、使用react做一个输入框，点击提交在下面列表展示，点击对应的列表项，删除该项，如下：<br><img src="https://upload-images.jianshu.io/upload_images/12926544-0b9480173bf5297a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>2、项目的数据结构，首先分析需求，一个input框，一个button，一个列表。可以把input和button看成一个组件，列表看成一个组件。在state中的数据结构可以设置为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state的数据结构</span></span><br><span class="line"><span class="keyword">this</span>.state = &#123;</span><br><span class="line">    inputValue: <span class="string">''</span>, <span class="comment">//用于存放input的值</span></span><br><span class="line">    list: []        <span class="comment">//存放列表的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><p>input框功能实现，原理：input框绑定onChange事件，每当输入字符时，改变this.state.inputValue的值，React中当state或props中的值改变，render函数会重新执行。实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：改变this.state.inputValue值，通过事件返回的e.target.value,获取输入框中的值</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.inputValue&#125; /&gt;</span><br><span class="line">handleChange (e) &#123;</span><br><span class="line">    <span class="comment">//同步setState</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        inputValue: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：在input框上设置ref属性，ref表示对组件真正实例的引用。</span></span><br><span class="line"><span class="comment">//设置ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125;表示，将当前input框中的value值，</span></span><br><span class="line"><span class="comment">//绑定到this上，在handleChange方法中，便可以直接取input的值：this.input.value</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span></span><br><span class="line">       id=<span class="string">"inputValue"</span></span><br><span class="line">       onChange=&#123;<span class="keyword">this</span>.handleChange&#125;</span><br><span class="line">       value=&#123;<span class="keyword">this</span>.state.inputValue&#125;</span><br><span class="line">       ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.input = input&#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">handleChange (e) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.input.value;</span><br><span class="line">    <span class="comment">//异步setState，可以为异步方法，带有一个参数prevState,即为上一步state的内容，同时带有回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">        inputValue: value</span><br><span class="line">    &#125;), () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'赋值完成！'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交功能实现，原理：很容易就想到，当点击提交的时候，将input框中的值push到this.state.list即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;提交&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/提交添加UI列表</span></span><br><span class="line"><span class="regexp">handleSubmit () &#123;</span></span><br><span class="line"><span class="regexp">    this.setState((prevState) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">        list: [...prevState.list, prevState.inputValue],</span></span><br><span class="line"><span class="regexp">        inputValue: ''</span></span><br><span class="line"><span class="regexp">    &#125;), () =&gt; &#123; /</span><span class="regexp">/回调函数</span></span><br><span class="line"><span class="regexp">        console.log(this.ul.querySelectorAll('li').length);</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将list的值在页面展示出来,可以通过map方法，循环li。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    注：react中循环的时候，必须在每一项加上key的属性，不然控制台会报错，</span></span><br><span class="line"><span class="comment">    原因是：diff算法在循环的时候,会去匹配对应的key值。此处用index作为key值是不合理的做法，key值应该是唯一的，</span></span><br><span class="line"><span class="comment">    diff算法后面会详细讲到。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击li，删除当前li,原理：每一个li都有对应的index，点击li时，获取index，在list找到对应下标，然后delete即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleDeleteItem.bind(this,</span> <span class="attr">index</span>)&#125;&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除当前点击item</span></span><br><span class="line">handleDelete (index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> list = [...prevState.list];</span><br><span class="line">        list.splice(index, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            list: list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h6 id="React的原理"><a href="#React的原理" class="headerlink" title="React的原理"></a>React的原理</h6><blockquote>
<pre><code>1. state改变
2. jsx模板
3. 数据 + 模板 生成虚拟dom（虚拟DOM就是一个js对象，用来描述真实的DOM）（损耗了性能）
4. 用虚拟DOM结构生成真实的DOM，来显示
5. state改变
6. 数据 + 模板 生成新的虚拟DOM（极大的提升了性能）
7. 比较原始虚拟DOM和新的虚拟DOM的区别，找到区别（diff算法）
8. 直接操作DOM，改变不同之处
</code></pre></blockquote>
<h6 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h6><blockquote>
<pre><code> 1. 同层对比（变化前和变化后，虚拟DOM同一级进行对比）
2. 列表（每个循环的列表都需要一个唯一的key，用于做对比，节约性能，因此用循环的index作为key是不靠谱的做法，浪费性能）
3. 组件（一个React的APP有多个组件进行组成，diff对比组件的class）
4. 绘制
    1). 当调用setState时，React将其标记为Dirty，然后事件轮询介绍时，React会查询dirty组件并重新绘制
    2). 当组件的setState方法被调用，组件会重新绘制它的子组件
5. react事件委托（通过事件冒泡至document处，合成对象(SyntheticEvent)，当触发事件时，通过dispatchEvent分发函数分发）
</code></pre></blockquote>
<h6 id="生命周期函数（在某一时刻组件会自动执行调用的函数）"><a href="#生命周期函数（在某一时刻组件会自动执行调用的函数）" class="headerlink" title="生命周期函数（在某一时刻组件会自动执行调用的函数）"></a>生命周期函数（在某一时刻组件会自动执行调用的函数）</h6><blockquote>
<pre><code>1. initialization (constructor) 初始化
2. Mounting (组件第一次挂载的流程)
    1). componentWillMount 在组件即将被挂载到页面的时刻执行，即render前执行
    2). render
    3). componentDidMount 在组件挂载到页面的时刻执行
3. Updation
    1). componentWillReceiveProps 从父组件接收参数并且这个组件在之前就存在父组件中 （props）
    2). shouldComponentUpdate 在更新前调用，如果该组件返回true,往下执行，否则停止
    3). componentWillUpdate 在更新前调用，shouldComponentUpdate返回true之后
    4). render
    5). componentDidUpdate 更新之后调用
4. Unmounting
    1). componentWillUnmount 即将被页面移除的时候执行
</code></pre></blockquote>
<h6 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h6><p>本文使用react做了一个添加删除的功能，代码已放在GitHub上，有兴趣请<strong><a href="https://github.com/zhuLni/todoList" target="_blank" rel="noopener">狠狠的点击这儿</a></strong>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>小西柚的到来</title>
    <url>/2019/02/24/records/%E5%B0%8F%E8%A5%BF%E6%9F%9A%E7%9A%84%E5%88%B0%E6%9D%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/records/my_baby.jpg" alt="小西柚"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间28个年头已过，像微风般拂过脸庞，没有一丝察觉，却已悄然而逝。经历去年一年的辛苦经营，终于在开年时收到了一个巨大的礼物，似那么的惹人怜爱，不敢轻易触碰。虽然早已做好了准备，但你的到来，却仍然让人手足无措。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得，第一次抱你时，你睁开一只眼睛看我时的怦然心动，在长时间的对视中，另一只眼也缓缓睁开，充满好奇。我想，你心里应该很疑惑，这位大叔是谁，为什么那么激动的看着我。看着不大不小的眼睛，像极了妈妈，虽然别人都说像我多一点，我仍觉得像妈妈多一点。经历了第一次换尿布，第一次喂奶，第一次换衣服，第一次洗澡…我们之间已经有了更深层次的感情，你的每次一次成长，都是我经受困难更坚决的努力，不放弃。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，辛苦妈妈十月怀胎，为了你付出了巨大的辛苦。有那么多美食不能吃，漂亮的衣服不能穿，为了你的到来经受了巨大的痛苦，之后的日子还要经历很长时间的艰辛。妈妈已经为你付出了那么多，我又有什么理由不更加努力，不对她更好呢？</p>
]]></content>
      <categories>
        <category>records</category>
      </categories>
      <tags>
        <tag>records</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub访问慢的解决办法</title>
    <url>/2019/12/05/others/GitHub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1、-修改本地hosts文件"><a href="#1、-修改本地hosts文件" class="headerlink" title="1、 修改本地hosts文件"></a>1、 修改本地hosts文件</h2><p>windows系统的hosts文件的位置如下：<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">C:<span class="symbol">\W</span>indows<span class="symbol">\S</span>ystem32<span class="symbol">\d</span>rivers<span class="symbol">\e</span>tc<span class="symbol">\h</span>osts</span><br></pre></td></tr></table></figure></p>
<p>mac/linux系统的hosts文件的位置如下：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure></p>
<h2 id="2、增加http-github-global-ssl-fastly-net和http-github-com的映射"><a href="#2、增加http-github-global-ssl-fastly-net和http-github-com的映射" class="headerlink" title="2、增加http://github.global.ssl.fastly.net和http://github.com的映射"></a>2、增加<code>http://github.global.ssl.fastly.net</code>和<code>http://github.com</code>的映射</h2><p>获取Github相关网站的ip</p>
<blockquote>
<p>访问<a href="https://www.ipaddress.com" target="_blank" rel="noopener">https://www.ipaddress.com</a><br>拉下来，找到页面中下方的“IP Address Tools – IP Address Lookup”<br>分别输入github.global.ssl.fastly.net和github.com，查询ip地址<br>如下<br><img src="https://upload-images.jianshu.io/upload_images/12926544-a5ddb18fcd3e2696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</blockquote>
<p>下面是我的配置<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">140<span class="selector-class">.82</span><span class="selector-class">.112</span><span class="selector-class">.4</span>	<span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">199<span class="selector-class">.232</span><span class="selector-class">.69</span><span class="selector-class">.194</span>	<span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.fastly</span><span class="selector-class">.net</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-命令提示符中输入ping-github-com"><a href="#3-命令提示符中输入ping-github-com" class="headerlink" title="3.命令提示符中输入ping github.com"></a>3.命令提示符中输入<code>ping github.com</code></h2><p>再次访问<a href="https://github.com/" target="_blank" rel="noopener">github</a>，快了很多</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>vsCode终端不能用yarn、npm解决办法</title>
    <url>/2020/09/11/others/vsCode%E7%BB%88%E7%AB%AF%E4%B8%8D%E8%83%BD%E7%94%A8yarn%E3%80%81npm%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、 <span class="keyword">window</span> +x</span><br><span class="line"><span class="number">2</span>、 Windw.powerShell(管理员A)</span><br><span class="line"><span class="number">3</span>、 set-ExecutionPolicy <span class="comment">RemoteSigned</span></span><br><span class="line"><span class="number">4</span>、 y</span><br><span class="line"><span class="number">5</span>、 <span class="keyword">get</span>-ExecutionPolicy</span><br></pre></td></tr></table></figure>
<p>如图:<br><img src="https://upload-images.jianshu.io/upload_images/12926544-770ae50c7bddaf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery_Mulselect封装</title>
    <url>/2019/03/12/jQuery/Mulselect/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="下拉多选-Mulselect自定义封装"><a href="#下拉多选-Mulselect自定义封装" class="headerlink" title="下拉多选-Mulselect自定义封装"></a>下拉多选-Mulselect自定义封装</h3><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p><img src="/images/jquery/mulselect.jpg" alt="mulselect"><br>自定义下拉多选封装，首先分下，一个完整的自定义下拉的组成部分：</p>
<blockquote>
<ol>
<li>有个显示框，显示选中内容</li>
<li>有一个新增字段部分，包括一个输入框，一个新增按钮，不能新增重复名称，则需验证信息部分</li>
<li>下拉列表部分，左侧为复选框，右侧为字段名称</li>
</ol>
</blockquote>
<p>已经拆分完一个组件，只需按照功能要求组合起来，便完成一大部分了。<br>假设UI已经完成，现在分析逻辑：</p>
<blockquote>
<ol>
<li>实现方式：构造函数+原型链</li>
<li>创建一个Mulselect原型方法create，新增UI</li>
<li>创建一个方法checkedItem，绑定Mulselect的事件，选中、全选、反选</li>
<li>创建一个方法checkedStatus，判断是否全部选中</li>
<li>创建一个方法getCheckedValue，获取选中的值</li>
<li>创建一个方法addItem，新增项</li>
<li>将创建好的对象绑定要window和jQuery上</li>
</ol>
</blockquote>
<p>逻辑部分已经思考完成，根据逻辑可以很明确的知道需要配合的参数有什么，有新增项功能、有选中、全选、反选功能、选中展示功能，可以分析如下参数：</p>
<blockquote>
<ol>
<li>isShowAdd 是否显示新增部分  true为显示，默认为false</li>
<li>isCheckAll 是否启用全选功能  true为启用全选，默认false</li>
<li>showNumber 选中个数超过当前数显示显示个数 默认值为4</li>
<li>isOpen 是否默认展开列表 true为展开 默认为false</li>
<li>selectAllText  选择所有的文本 默认’全选’</li>
<li>chooseText 请选择项文本 默认’请选择项’</li>
<li>noDataText 暂无数据文本 默认’暂无数据’</li>
<li>canNotSameName 不能添加同名字段默认文本 默认’不能添加同名字段默认文本’</li>
<li>data [{ name: ‘字段名称’, disable: ‘是否禁用选择’}] disable为’disable’表示禁用，其他不禁用</li>
<li>getCheckedValue(option, element) 选中回调 option为选中字段数组， element当前下拉多选DOM</li>
</ol>
</blockquote>
<h6 id="创建构造函数"><a href="#创建构造函数" class="headerlink" title="创建构造函数"></a>创建构造函数</h6><p>首选需要创建构造函数，设置好默认字段，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MulSelect</span>(<span class="params">element, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.config = &#123;</span><br><span class="line">        isShowAdd: <span class="literal">false</span>,                   <span class="comment">//是否显示新增项</span></span><br><span class="line">        isCheckAll: <span class="literal">false</span>,                  <span class="comment">//是否启用全选功能</span></span><br><span class="line">        showNumber: <span class="number">4</span>,                      <span class="comment">//选中显示的个数</span></span><br><span class="line">        isOpen: <span class="literal">false</span>,                      <span class="comment">//是否直接显示下拉</span></span><br><span class="line">        selectAllText: <span class="string">'全选'</span>,               <span class="comment">//全选默认文本</span></span><br><span class="line">        chooseText: <span class="string">'请选择值'</span>,               <span class="comment">//请选择值默认文本</span></span><br><span class="line">        noDataText: <span class="string">'暂无数据'</span>,               <span class="comment">//暂无数据默认文本</span></span><br><span class="line">        canNotSameName: <span class="string">'不能添加同名字段'</span>,    <span class="comment">//不能添加同名字段默认文本</span></span><br><span class="line">        data: [],                            <span class="comment">//下拉数据</span></span><br><span class="line">        getCheckedValue: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,     <span class="comment">//获取选中的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//扩展默认参数</span></span><br><span class="line">    <span class="keyword">if</span> (config &amp;&amp; $.isPlainObject(config)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.config = $.extend(&#123;&#125;, <span class="keyword">this</span>.config, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="创建Mulselect静态方法"><a href="#创建Mulselect静态方法" class="headerlink" title="创建Mulselect静态方法"></a>创建Mulselect静态方法</h6><p>构造函数完成后，开始创建Mulselect静态页面，需要注意的是，因为设置了是否启用新增功能、是否启用全选功能，故这两个模块需要根据配置项判断是否启用，列表项需要传入的是数组，直接循环即可，具体代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.create = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            isShowAdd,</span><br><span class="line">            data,</span><br><span class="line">            isCheckAll,</span><br><span class="line">            isOpen,</span><br><span class="line">            selectAllText,</span><br><span class="line">            chooseText,</span><br><span class="line">            noDataText,</span><br><span class="line">        &#125; = _this.config;</span><br><span class="line">    <span class="keyword">let</span> _html = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> checkAllDisable = data.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.disable.length === <span class="number">0</span>;</span><br><span class="line">    &#125;).length === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    _html += <span class="string">`</span></span><br><span class="line"><span class="string">                &lt;div class="mulselect"&gt;</span></span><br><span class="line"><span class="string">                    &lt;button type="button" class="mulselect-btn dropDownToggle" title="<span class="subst">$&#123;chooseText&#125;</span>" data-toggle="<span class="subst">$&#123;isOpen ? <span class="string">'open'</span> : <span class="string">'close'</span>&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                        &lt;span class="mulselect-text"&gt;<span class="subst">$&#123;chooseText&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">                        &lt;b class="caret"&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="string">                    &lt;/button&gt;</span></span><br><span class="line"><span class="string">                    &lt;ul class="mulselect-list <span class="subst">$&#123;isOpen ? <span class="string">''</span> : <span class="string">'none'</span>&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">            `</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否显示新增栏</span></span><br><span class="line">    <span class="keyword">if</span> (isShowAdd) &#123;</span><br><span class="line">        _html += <span class="string">`</span></span><br><span class="line"><span class="string">                    &lt;li class="mulselect-item input"&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type="text" value="" class="add-col" placeholder="请输入新增项"&gt;</span></span><br><span class="line"><span class="string">                        &lt;button class="btn btn-add"&gt;增加&lt;/button&gt;</span></span><br><span class="line"><span class="string">                        &lt;p class="red-font text-center none vilExpression"&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;/li&gt;</span></span><br><span class="line"><span class="string">                `</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否显示全选</span></span><br><span class="line">        <span class="keyword">if</span> (isCheckAll) &#123;</span><br><span class="line">            _html += <span class="string">`</span></span><br><span class="line"><span class="string">                        &lt;li class="mulselect-item checked-item <span class="subst">$&#123;checkAllDisable ? <span class="string">'disable'</span> : <span class="string">''</span>&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                            &lt;input type="checkbox" name="checkAll" data-type="checkAll"&gt;</span></span><br><span class="line"><span class="string">                            <span class="subst">$&#123;selectAllText&#125;</span></span></span><br><span class="line"><span class="string">                        &lt;/li&gt;</span></span><br><span class="line"><span class="string">                    `</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            _html += <span class="string">`</span></span><br><span class="line"><span class="string">                        &lt;li class="mulselect-item checked-item <span class="subst">$&#123;item.disable&#125;</span>" title="<span class="subst">$&#123;item.name&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                            &lt;input type="checkbox" value="<span class="subst">$&#123;item.name&#125;</span>" name="mulItem" data-type="item"&gt;<span class="subst">$&#123;item.name&#125;</span></span></span><br><span class="line"><span class="string">                        &lt;/li&gt;</span></span><br><span class="line"><span class="string">                    `</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _html += <span class="string">`</span></span><br><span class="line"><span class="string">                    &lt;li class="mulselect-item text-center"&gt;</span></span><br><span class="line"><span class="string">                       &lt;span class="red-font"&gt;<span class="subst">$&#123;noDataText&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;/li&gt;</span></span><br><span class="line"><span class="string">                `</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _html += <span class="string">`&lt;/ul&gt;&lt;/div&gt;`</span>;</span><br><span class="line"></span><br><span class="line">    _this.element.html(_html);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="创建显示隐藏列表方法"><a href="#创建显示隐藏列表方法" class="headerlink" title="创建显示隐藏列表方法"></a>创建显示隐藏列表方法</h6><p>完成Mulselect的静态页面创建，这里遇到个问题，需要隐藏和显示下拉多选列表，那么需要绑定显示框的点击事件，点击时判断显示和隐藏状态，如果列表展开状态，则隐藏，反之，则显示。需要注意的时，如果展开时，点击空白位置也需要隐藏，具体代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.showList = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> $selector = <span class="keyword">this</span>.element;</span><br><span class="line"></span><br><span class="line">    $selector.off(<span class="string">'click'</span>).on(<span class="string">'click'</span>, <span class="string">'.dropDownToggle'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        <span class="keyword">const</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</span><br><span class="line">            _toggle = $<span class="keyword">this</span>.data(<span class="string">'toggle'</span>);</span><br><span class="line"></span><br><span class="line">        $(<span class="string">'.dropDownToggle'</span>).data(<span class="string">'toggle'</span>, <span class="string">'close'</span>);</span><br><span class="line">        $(<span class="string">'.mulselect-list'</span>).hide();</span><br><span class="line">        <span class="keyword">if</span> (_toggle === <span class="string">'close'</span>) &#123;</span><br><span class="line">            $<span class="keyword">this</span>.data(<span class="string">'toggle'</span>, <span class="string">'open'</span>);</span><br><span class="line">            $<span class="keyword">this</span>.addClass(<span class="string">'active'</span>);</span><br><span class="line">            $selector.find(<span class="string">'.mulselect-list'</span>).show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $<span class="keyword">this</span>.data(<span class="string">'toggle'</span>, <span class="string">'close'</span>);</span><br><span class="line">            $<span class="keyword">this</span>.removeClass(<span class="string">'active'</span>);</span><br><span class="line">            $selector.find(<span class="string">'.mulselect-list'</span>).hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $selector.on(<span class="string">'click'</span>, <span class="string">'.mulselect-list'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $selector.find(<span class="string">'.mulselect-list'</span>).hide();</span><br><span class="line">        $selector.find(<span class="string">'.dropDownToggle'</span>).data(<span class="string">'toggle'</span>, <span class="string">'close'</span>).removeClass(<span class="string">'active'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="创建选中、全选、反选事件绑定方法"><a href="#创建选中、全选、反选事件绑定方法" class="headerlink" title="创建选中、全选、反选事件绑定方法"></a>创建选中、全选、反选事件绑定方法</h6><p>因为使用CheckBox来做选中、全选、反选，则判断是否选中只需考虑CheckBox的checked是否为true，则能判断当前选中的状态；如果是全选和反选，则需要判断当点击全选时，当前列表的所有CheckBox的checked是否全为true，故还需要一个判断当前下拉多选列表是否全选的状态。<br>是否全选状态代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.checkedStatus =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> checkedArr = [],</span><br><span class="line">        disableArr = [];</span><br><span class="line">    <span class="keyword">this</span>.element.find(<span class="string">'input[name="mulItem"]'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($(<span class="keyword">this</span>).is(<span class="string">':checked'</span>)) &#123;</span><br><span class="line">            checkedArr.push(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($(<span class="keyword">this</span>).parent().hasClass(<span class="string">'disable'</span>)) &#123;</span><br><span class="line">            disableArr.push(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.find(<span class="string">'input[name="mulItem"]'</span>).length === checkedArr.length + disableArr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>选中、全选、反选代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.checkedItem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        $selector = _this.element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.element.on(<span class="string">'click'</span>, <span class="string">'input[type="checkbox"]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        <span class="keyword">const</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</span><br><span class="line">            $checkItem = $selector.find(<span class="string">"input[name='mulItem']"</span>),</span><br><span class="line">            $checkAll = $selector.find(<span class="string">"input[name='checkAll']"</span>),</span><br><span class="line">            _dataType = $<span class="keyword">this</span>.data(<span class="string">'type'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.is(<span class="string">':checked'</span>)) &#123;</span><br><span class="line">            $<span class="keyword">this</span>.parent().addClass(<span class="string">'checked'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $<span class="keyword">this</span>.parent().removeClass(<span class="string">'checked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_dataType === <span class="string">'checkAll'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($<span class="keyword">this</span>.prop(<span class="string">"checked"</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                $checkItem.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">                $checkItem.parent().addClass(<span class="string">'checked'</span>);</span><br><span class="line">                $selector.find(<span class="string">'.disable'</span>).removeClass(<span class="string">'checked'</span>);</span><br><span class="line">                $selector.find(<span class="string">'.disable input'</span>).prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $checkItem.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">                $checkItem.parent().removeClass(<span class="string">'checked'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ischeckedAll = _this.checkedStatus();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//是否全选</span></span><br><span class="line">            <span class="keyword">if</span> (ischeckedAll) &#123;</span><br><span class="line">                $checkAll.prop(<span class="string">'checked'</span>, <span class="literal">true</span>);</span><br><span class="line">                $checkAll.parent().addClass(<span class="string">'checked'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $checkAll.prop(<span class="string">'checked'</span>, <span class="literal">false</span>);</span><br><span class="line">                $checkAll.parent().removeClass(<span class="string">'checked'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _this.getCheckedValue();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _this.element.on(<span class="string">'click'</span>, <span class="string">'.checked-item'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="keyword">this</span>).find(<span class="string">'input[type="checkbox"]'</span>).click();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="获取选中状态的值"><a href="#获取选中状态的值" class="headerlink" title="获取选中状态的值"></a>获取选中状态的值</h6><p>已经完成了选中状态，需要返回选中的值，只需获取当前列表下CheckBox的checked为true的值，并存于一个数组中，通过回调函数返回即可，需要注意的是，构造函数中设置了showNumber参数，即当选中个数超出这个设置值时，则显示已选多少个数，这里需要判断一下，还有当全选并且选中的个数大于showNumber时显示全选，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.getCheckedValue =<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        checkedArr = [],</span><br><span class="line">        _string = <span class="string">''</span>,</span><br><span class="line">        &#123;showNumber, getCheckedValue, data, chooseText&#125; = _this.config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.element.find(<span class="string">'input[name="mulItem"]'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.is(<span class="string">':checked'</span>)) &#123;</span><br><span class="line">            checkedArr.push($<span class="keyword">this</span>.val());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    getCheckedValue(checkedArr, _this.element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (showNumber &lt;= checkedArr.length) &#123;</span><br><span class="line">        _string = <span class="string">`<span class="subst">$&#123;checkedArr.length&#125;</span> selected`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _string = checkedArr.join(<span class="string">' , '</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkedArr.length === data.length &amp;&amp; showNumber &lt; checkedArr.length) &#123;</span><br><span class="line">        _string = <span class="string">`All selected(<span class="subst">$&#123;checkedArr.length&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkedArr.length === <span class="number">0</span>) &#123;</span><br><span class="line">        _string = chooseText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _this.element.find(<span class="string">'.mulselect-text'</span>).text(_string).attr(<span class="string">'title'</span>, _string);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="新增列表项"><a href="#新增列表项" class="headerlink" title="新增列表项"></a>新增列表项</h6><p>列表的下拉多选基本完成，现在做额外的功能，新增列表项功能，同名的列表项不能新增，触发新增的功能键为：新增按钮或enter，当新增框不为空并且没同名项时，点击新增，在列表的尾部添加一下，并选中，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MulSelect.prototype.addItem = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        $selector = _this.element,</span><br><span class="line">        &#123;canNotSameName&#125; = _this.config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增列</span></span><br><span class="line">    $selector.on(<span class="string">'click'</span>, <span class="string">'.btn-add'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        <span class="keyword">const</span> _val = $(<span class="keyword">this</span>).prev().val();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_val.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> checkedArr = [];</span><br><span class="line">            $selector.find(<span class="string">'input[name="mulItem"]'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                checkedArr.push($(<span class="keyword">this</span>).val());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (checkedArr.indexOf(_val) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                $selector.find(<span class="string">'.vilExpression'</span>).text(canNotSameName).show();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            $selector.find(<span class="string">'.vilExpression'</span>).hide();</span><br><span class="line"></span><br><span class="line">            _this.config.data.push(&#123;</span><br><span class="line">                name: <span class="string">`.<span class="subst">$&#123;_val&#125;</span>`</span>,</span><br><span class="line">                disable: <span class="string">''</span></span><br><span class="line">            &#125;);</span><br><span class="line">            _this.config.isOpen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            $selector.find(<span class="string">'.mulselect-list'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">                            &lt;li class="mulselect-item checked-item checked" title="<span class="subst">$&#123;_val&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                                &lt;input type="checkbox" value="<span class="subst">$&#123;_val&#125;</span>" name="mulItem" data-type="item" checked=true&gt;<span class="subst">$&#123;_val&#125;</span></span></span><br><span class="line"><span class="string">                            &lt;/li&gt;</span></span><br><span class="line"><span class="string">                        `</span>);</span><br><span class="line">            $selector.find(<span class="string">'.add-col'</span>).val(<span class="string">''</span>);</span><br><span class="line">            _this.getCheckedValue();</span><br><span class="line">            <span class="comment">// _this.create();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//enter新增</span></span><br><span class="line">    $selector.on(<span class="string">'keyup'</span>, <span class="string">'.add-col'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _value = $(<span class="keyword">this</span>).val();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> checkedArr = [];</span><br><span class="line">            $selector.find(<span class="string">'input[name="mulItem"]'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                checkedArr.push($(<span class="keyword">this</span>).val());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (checkedArr.indexOf(_value) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                $selector.find(<span class="string">'.vilExpression'</span>).show().text(canNotSameName);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $selector.find(<span class="string">'.vilExpression'</span>).hide();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">                _this.config.data.push(&#123;</span><br><span class="line">                    name: _value,</span><br><span class="line">                    disable: <span class="string">''</span></span><br><span class="line">                &#125;);</span><br><span class="line">                _this.config.isOpen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                $selector.find(<span class="string">'.mulselect-list'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">                                &lt;li class="mulselect-item checked-item checked" title="<span class="subst">$&#123;_value&#125;</span>"&gt;</span></span><br><span class="line"><span class="string">                                    &lt;input type="checkbox" value="<span class="subst">$&#123;_value&#125;</span>" name="mulItem" data-type="item" checked=true&gt;<span class="subst">$&#123;_value&#125;</span></span></span><br><span class="line"><span class="string">                                &lt;/li&gt;</span></span><br><span class="line"><span class="string">                            `</span>);</span><br><span class="line">                _this.getCheckedValue();</span><br><span class="line">                $selector.find(<span class="string">'.add-col'</span>).val(<span class="string">''</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="封装到jQuery和window上"><a href="#封装到jQuery和window上" class="headerlink" title="封装到jQuery和window上"></a>封装到jQuery和window上</h6><p>到目前为止已经完成了下拉多选的封装，只需在jQuery和window上扩展可直接使用，代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装到window对象上</span></span><br><span class="line"><span class="built_in">window</span>.MulSelect = MulSelect;</span><br><span class="line"><span class="comment">//封装到jquery对象上</span></span><br><span class="line">$.fn.MulSelect = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mulSelect = <span class="keyword">new</span> MulSelect(<span class="keyword">this</span>, config);</span><br><span class="line">    <span class="keyword">return</span> mulSelect.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>一个完整的jQuery下拉多选封装已经完成，目前只是处版，后期有时间会将功能扩展到多层级，完整代码已经上传GitHub，有兴趣<strong><a href="https://github.com/zhuLni/Mulselect" target="_blank" rel="noopener">狠狠的点击这儿</a></strong></p>
]]></content>
      <categories>
        <category>自定义功能封装</category>
      </categories>
      <tags>
        <tag>自定义功能封装</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript之深入原型与原型链</title>
    <url>/2019/10/11/js/JavaScript%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天、惊雷一声，响彻神州大地，凄厉厉的大雨瞬间而至，街上行色匆匆，视线所致，一辆辆车，五颜六色的伞，夹杂着各色水声，来了又走，而留下的只有你形单影只。如人生一般，身边总有那么多的人来了又走……<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因项目增多，缺乏人手，最近面了一些工作多年的面试者，普遍现象，业务代码写的太多，而不太注重底层原理的加深。故这儿整理下一些常用方法的底层原来及实现，本文主要记录什么是原型，什么是原型链，以及他们之间的关系。</p>
<h3 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h3><h6 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在讲解原型前，首先需要知道什么是构造函数，先看一个例子：<br> <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子就是一个构造函数，JavaScript默认函数首字母大写为构造函数，调用方式必须通过new关键字调用。上面的代码创建一个名为<code>Person</code>的构造函数，通过<code>new</code>实例出来一个实例对象<code>p</code>, 如下：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">console.log(p<span class="function">.<span class="keyword">constructor</span> === <span class="title">Person</span>);</span>   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>下面的图展示了实例p和构造函数Person之间的关系：<br><img src="/images/js/原型与原型链/构造函数与实例.jpg" alt="构造函数和实例的关系"></p>
<p>注：从上面打印的结果看，实例p应该会有一个constructor属性，指向的构造函数Person，其实并不是这样的。p本身并没有constructor属性，虽然p.constructor是指向了Person。原理是p.constructor被委托给了Person.prototype，而Person.prototype.constructor默认指向的时Person。</p>
<h3 id="2、prototype"><a href="#2、prototype" class="headerlink" title="2、prototype"></a>2、prototype</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript规定每一个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向原型对象，这样就可以包含特定类型的所有实例共享的属性和方法。如下所示：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">name</span> = '<span class="title">zhangSan</span>';</span></span><br><span class="line">Person.prototype.age = <span class="number">35</span>;</span><br><span class="line">Person.prototype.showInfo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(this.name, this.age);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">p1</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">const</span> p2 = new Person();</span><br><span class="line">console.log(p1.<span class="keyword">name</span>, p2.<span class="keyword">name</span>);  <span class="comment">// zhangSan zhangSan</span></span><br><span class="line">console.log(p1.showInfo === p2.showInfo); <span class="comment">// true</span></span><br><span class="line">console.log(p1.prototype<span class="function">.<span class="keyword">constructor</span> === <span class="title">Person</span>);</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可看出，创建了一个空的构造函数<code>Person</code>，在Person的prototype属性中添加了属性和方法<code>name、age、showInfo</code>，并且在新创建的实例对象中，这些属性和方法是被实例所共享的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么prototype属性指向的是什么呢？例子中不难发现，prototype属性指向了一个对象，这个对象叫做<code>原型对象（Person.prototype）</code>， 而原型对象的constructor属性指向的是构造函数Person，从下面的可以直观的看出，构造函数和原型对象的关系：<br><img src="/images/js/原型与原型链/构造函数与原型对象.jpg" alt="构造函数和原型对象的关系"></p>
<h3 id="3、-proto"><a href="#3、-proto" class="headerlink" title="3、__proto__"></a>3、__proto__</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>__proto__</code>是JavaScript对象中特殊的内置属性，即对其他对象的一个引用。每当创建一个新实例后，该实例内部都包含一个指针（<code>__proto__</code>），指向原型对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>到此，已可以看出构造函数、原型对象、实例之间的关系，如下：<br><img src="/images/js/原型与原型链/构造函数、实例与原型对象.jpg" alt="构造函数、实例和原型对象的关系"></p>
<p>总结：每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<h3 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再讲原型链前，先回顾最开始讲的，Person.prototype.constructor默认是指向的Person，假如创建一个新的对象来替代Person.prototype的引用，那么会发生什么呢？看个例子：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span> = <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    name: 'zhangSan',</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">p</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">()</span>;</span></span><br><span class="line">console.log(p<span class="function">.<span class="keyword">constructor</span> === <span class="title">Person</span>);</span> <span class="comment">// false</span></span><br><span class="line">console.log(p<span class="function">.<span class="keyword">constructor</span> === <span class="title">Object</span>);</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看结果为什么Person.prototype.constructor指向了Object？因为改变了Person.prototype的引用，Person.prototype并不会自动获取.constructor属性。简单讲就是p并没有constructor属性，所以p会委托__proto__链上的Person.prototype，Person.prototype默认constructor属性已经被改变，所以这个对象上并没有constructor属性，它会继续委托，委托给最顶端的Object.prototype，这个对象的.constructor指向Object。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何让p.constructor指向Person呢？直接在Person.prototype中创建一个constructor属性即可，如下：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span> = <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    constructor: 'Person',</span></span></span><br><span class="line"><span class="function"><span class="comment">    name: 'zhangSan',</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">p</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">()</span>;</span></span><br><span class="line">console.log(p<span class="function">.<span class="keyword">constructor</span> === <span class="title">Person</span>);</span> <span class="comment">// true</span></span><br><span class="line">console.log(p<span class="function">.<span class="keyword">constructor</span> === <span class="title">Object</span>);</span> <span class="comment">// true</span></span><br><span class="line">console.log(<span class="keyword">Object</span>.prototype.__proto__); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>故更新上面的图如下：<br><img src="/images/js/原型与原型链/原型链1.jpg" alt="原型链1"></p>
<p>总结：当查找实例属性时，如果找不到，就会查找与原型相关联的属性，一直往上找，直到最顶层。这样就构成了实例与原型的链条，叫做<code>原型链</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能还没有太明白什么是原型链，再以原型链继承的方式，具体解释原型链的构成。<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">Man</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">Man</span>.<span class="title">prototype</span> = <span class="title">new</span> <span class="title">Person</span><span class="params">()</span>;</span> <span class="comment">// 关键代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = new Man();</span><br><span class="line">console.log(m<span class="function">.<span class="keyword">constructor</span>);</span> <span class="comment">// Person</span></span><br><span class="line">console.log(Man.prototype.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line">console.log(Person.prototype.__proto__ === <span class="keyword">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line">console.log(<span class="keyword">Object</span>.prototype.__proto__ === null); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码创建了两个构造函数Person、Man，第三行代码改变了Man.prototype的引用，本质上是重写了Man的原型对象，Man.prototype.constructor已不指向默认的Man了，而是指向了Person实例，而Person的实例的constructor会委托Person.prototype上，故m.constructor指向了Person，这样的一个过程就构成了原型链。如图：<br><img src="/images/js/原型与原型链/原型链2.jpg" alt="原型链2"></p>
<p>上面的图中，通过由相关联__proto__连接组成的链条结构，就是原型链。</p>
<h3 id="4、-方法"><a href="#4、-方法" class="headerlink" title="4、 方法"></a>4、 方法</h3><h6 id="1）、isPrototypeOf-方法"><a href="#1）、isPrototypeOf-方法" class="headerlink" title="1）、isPrototypeOf()方法"></a>1）、isPrototypeOf()方法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现实中是无法访问到prototype，但可以通过一个方法（<code>isPrototypeOf()</code>）来确定对象之间是否存在这种关系，如果存在就返回true，否则false。以上面的例子为例，如下：<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">console</span>.log(<span class="type">Man</span>.proto<span class="keyword">type</span>.isPrototypeOf(m)); // true</span><br><span class="line"><span class="title">console</span>.log(<span class="type">Person</span>.proto<span class="keyword">type</span>.isPrototypeOf(m)); // true</span><br><span class="line"><span class="title">console</span>.log(<span class="type">Object</span>.proto<span class="keyword">type</span>.isPrototypeOf(m)); // true</span><br></pre></td></tr></table></figure></p>
<p>从上面的结果可以看出，prototype指向了调用<code>isPrototypeOf()</code>方法的对象Man.prototype，故这个方法返回true，因Person.prototype、Object.prototype都是存在同一条原型链上，故返回结果都都为true。</p>
<h6 id="2）、getPrototypeOf-方法"><a href="#2）、getPrototypeOf-方法" class="headerlink" title="2）、getPrototypeOf()方法"></a>2）、getPrototypeOf()方法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES5新增了Object.getPrototypeOf()返回对象的原型，即返回prototype。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(m) === Man.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h6 id="3）、hasOwnProperty-方法"><a href="#3）、hasOwnProperty-方法" class="headerlink" title="3）、hasOwnProperty()方法"></a>3）、hasOwnProperty()方法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasOwnProperty方法检测一个属性是否存在实例中。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'zhangSan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">'age'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>从结果看，hasOwnProperty()只能判断对象的属性在构造函数中，不能判断原型对象上的属性，那么如何判断原型对象上的属性呢？</p>
<h6 id="4）、in操作符"><a href="#4）、in操作符" class="headerlink" title="4）、in操作符"></a>4）、in操作符</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>in</code>操作符访问给定属性会返回true，无论该属性在原型对象上还是在构造函数上。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">'zhangSan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> p); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>从上面看，同时使用in和hasOwnProperty()可判断一个属性在原型对象上，只需该属性在hasOwnProperty上为false，在in上为true即可，封装如下：<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title">hasOwnProtorypeProperty</span>(object, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">!object.hasOwnProperty(name)</span> &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a>5、结语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此，已写完了，构造函数、原型、实例及之间的关系，同时通过实例指向原型对象的内部指针，一直到顶层Object.prototype，构成原型链。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若文章中有不对的地方，欢迎指出。</p>
<p>Git地址：<a href="https://github.com/chicAboo/zt-blogs" target="_blank" rel="noopener">JavaScript</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义鼠标右键</title>
    <url>/2018/09/11/jQuery/jQuery-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="一、自定义鼠标右键的实现原理"><a href="#一、自定义鼠标右键的实现原理" class="headerlink" title="一、自定义鼠标右键的实现原理"></a>一、自定义鼠标右键的实现原理</h1><p><img src="https://upload-images.jianshu.io/upload_images/12926544-0fba8e14b4e89680.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM图片20180911164755.png"></p>
<p>自定义右键菜单功能，需清楚，所有浏览器都自带了右键功能，那么自定义右键菜单，需要先屏蔽系统自带的右键功能，如何实现呢？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$selector.on(<span class="string">'contextmenu'</span>, <span class="string">'.box'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注：$selector为选择器，.box为禁用鼠标右键的class<br>完成系统自带鼠标右键的禁用后，开始自定义鼠标右键。</p>
<hr>
<p>获取鼠标事件的方法，使用mousedown,获取后需区分是鼠标左键还是右键，事件返回的参数event中，event.which为3表示右键，为1表示左键，为2表示中键。如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#box"</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="number">3</span> === e.which)&#123;</span><br><span class="line">           alert(<span class="string">"这 是右键单击事件"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> === e.which)&#123;</span><br><span class="line">               alert(<span class="string">"这 是左键单击事件"</span>);</span><br><span class="line">         &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>  ===  e.which)  &#123;</span><br><span class="line">            alert(<span class="string">"这是鼠标中键"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二、自定义鼠标右键实例（表格行右键自定菜单）"><a href="#二、自定义鼠标右键实例（表格行右键自定菜单）" class="headerlink" title="二、自定义鼠标右键实例（表格行右键自定菜单）"></a>二、自定义鼠标右键实例（表格行右键自定菜单）</h1><h4 id="html"><a href="#html" class="headerlink" title="html:"></a>html:</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table-list"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table-thead "</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"table-col"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"名称"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"类型"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>类型<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"数据"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>数据<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table-tbody"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"table-col saveCol"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test1"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test2"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test3"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"point-icon opratePointDrop"</span> <span class="attr">data-toggle</span>=<span class="string">"close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"oprate-dropdown opDropDown none"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRun"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>运行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRename"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveEdit"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveDelete"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>导出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"table-col saveCol"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test1"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test2"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test3"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"point-icon opratePointDrop"</span> <span class="attr">data-toggle</span>=<span class="string">"close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"oprate-dropdown opDropDown none"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRun"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>运行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRename"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveEdit"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveDelete"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>导出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"table-col saveCol"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test1"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test2"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span> <span class="attr">title</span>=<span class="string">"test3"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">span</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"save-item"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"point-icon opratePointDrop"</span> <span class="attr">data-toggle</span>=<span class="string">"close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"oprate-dropdown opDropDown none"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRun"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>运行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveRename"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveEdit"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"op-item btn-mySaveDelete"</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span></span><br><span class="line">                             <span class="tag">&lt;<span class="name">span</span>&gt;</span>导出<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                         <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="css"><a href="#css" class="headerlink" title="css:"></a>css:</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ul</span> <span class="selector-tag">li</span>, <span class="selector-tag">ol</span> <span class="selector-tag">li</span>, <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.none</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义table */</span></span><br><span class="line"><span class="selector-class">.table-list</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-list</span> <span class="selector-class">.table-tbody</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">350px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">225px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-list</span> <span class="selector-class">.table-thead</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span> &gt; <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span>, <span class="selector-class">.table-tbody</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span> &gt; <span class="selector-tag">ul</span>, <span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>, <span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">36px</span>;</span><br><span class="line">    <span class="attribute">font</span>: normal <span class="number">12px</span>/<span class="number">36px</span> <span class="string">'Microsoft YaHei'</span>, <span class="string">'Arial'</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d9d9d9</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>, <span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#d9d9d9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-thead</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">span</span>, <span class="selector-class">.table-tbody</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下拉 */</span></span><br><span class="line"><span class="selector-class">.oprate-dropdown</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">28px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d9d9d9</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/* 禁用选择字体 */</span></span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none; <span class="comment">/*火狐*/</span></span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none; <span class="comment">/*webkit浏览器*/</span></span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none; <span class="comment">/*IE10*/</span></span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.oprate-dropdown</span> <span class="selector-tag">li</span><span class="selector-class">.op-item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.oprate-dropdown</span> <span class="selector-tag">li</span><span class="selector-class">.op-item</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: <span class="number">#f2f3f6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.oprate-dropdown</span> <span class="selector-tag">li</span><span class="selector-class">.op-item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#d9d9d9</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2a313f</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.oprate-dropdown</span> <span class="selector-tag">li</span><span class="selector-class">.op-item</span> <span class="selector-class">.op-icon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.point-icon</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(../image/point-icon.png) no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="js"><a href="#js" class="headerlink" title="js:"></a>js:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _rightMenu = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        _this.rightMenuOprate();</span><br><span class="line">    &#125;,</span><br><span class="line">    rightMenuOprate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $searchPart = $(<span class="string">'.box'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作点击下拉</span></span><br><span class="line">        $searchPart.on(<span class="string">'click'</span>, <span class="string">'.opratePointDrop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.stopPropagation();</span><br><span class="line">            <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</span><br><span class="line">                _isOpen = $<span class="keyword">this</span>.attr(<span class="string">'data-toggle'</span>),</span><br><span class="line">                $dropDown = $<span class="keyword">this</span>.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//清空所有显示下拉</span></span><br><span class="line">            $searchPart.find(<span class="string">'.opDropDown'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">                $<span class="keyword">this</span>.hide();</span><br><span class="line">                $<span class="keyword">this</span>.prev().attr(<span class="string">'data-toggle'</span>, <span class="string">'close'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (_isOpen === <span class="string">'close'</span>) &#123;</span><br><span class="line">                $dropDown.show().css(<span class="string">'left'</span>, <span class="string">''</span>);</span><br><span class="line">                $<span class="keyword">this</span>.attr(<span class="string">'data-toggle'</span>, <span class="string">'open'</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_isOpen === <span class="string">'open'</span>) &#123;</span><br><span class="line">                $dropDown.hide();</span><br><span class="line">                $<span class="keyword">this</span>.attr(<span class="string">'data-toggle'</span>, <span class="string">'close'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//禁止鼠标右键事件</span></span><br><span class="line">        $searchPart.on(<span class="string">'contextmenu'</span>, <span class="string">'.saveCol'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//鼠标右键</span></span><br><span class="line">        $searchPart.on(<span class="string">'mousedown'</span>, <span class="string">'.saveCol'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.stopPropagation();</span><br><span class="line">            <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">3</span> === e.which) &#123;</span><br><span class="line">                <span class="comment">//隐藏其他展开的下拉</span></span><br><span class="line">                $searchPart.find(<span class="string">'.opDropDown'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">                    $<span class="keyword">this</span>.hide();</span><br><span class="line">                    $<span class="keyword">this</span>.prev().attr(<span class="string">'data-toggle'</span>, <span class="string">'close'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                $<span class="keyword">this</span>.find(<span class="string">'.opDropDown'</span>).show().css(&#123;</span><br><span class="line">                    <span class="string">'left'</span>: e.pageX - <span class="number">50</span>  + <span class="string">'px'</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//点击清除</span></span><br><span class="line">        $(<span class="built_in">document</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//兼容火狐</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> === e.which) &#123;</span><br><span class="line">                $searchPart.find(<span class="string">'.opratePointDrop'</span>).attr(<span class="string">'data-toggle'</span>, <span class="string">'close'</span>);</span><br><span class="line">                $searchPart.find(<span class="string">'.opDropDown'</span>).hide();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    _rightMenu.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>jQuery自定义功能</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript之深入多种种继承方式及优缺点</title>
    <url>/2019/11/30/js/JavaScript%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%A4%9A%E7%A7%8D%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>上一篇文章讲解了<a href="https://github.com/chicAboo/zt-blogs/issues/1#issue-647957995" target="_blank" rel="noopener">JavaScript之深入原型与原型链</a>，继承本质就是在构造函数和原型上进行一系列的操作，以达到子类能访问到父类的属性和方法。下面会介绍多种继承方式，及每种继承的优缺点。</p>
<h3 id="二、构造函数继承"><a href="#二、构造函数继承" class="headerlink" title="二、构造函数继承"></a>二、构造函数继承</h3><p>构造函数的继承使用<code>.call()</code>或<code>.apply()</code>方法，在子类中调用父类的构造函数，本质上是在子类中引用父类的构造函数，初始化父类构造函数。代码如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`构造函数中的方法：<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原型链上的方法： <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Man(<span class="string">'chicABoo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> Man);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> Person); <span class="comment">// false</span></span><br><span class="line">m.show(); <span class="comment">// 构造函数中的方法：chicABoo</span></span><br><span class="line">m.showName(); <span class="comment">// typeError: m.showName is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了一个Person构造函数，Person中有属性name和show方法，Person的原型对象上定义了showName方法；构造函数Man中通过.call()的方法，初始化了父类的构造函数，即能Man继承了父类的构造函数。<br>优点：<br>1、子类能成功继承到父类的构造函数；<br>2、子类能继承多个父类的构造函数；<br>3、可以通过call或apply方法向父类传参；</p>
<p>缺点：<br>1、只能继承到父类构造函数的属性和方法，无法继承原型链上的属性和方法；<br>2、每个新的实例都会创建父类的副本；<br>3、无法实现构造函数的复用，每次都要调用；</p>
<h3 id="三、原型链继承"><a href="#三、原型链继承" class="headerlink" title="三、原型链继承"></a>三、原型链继承</h3><p>原型链继承的方式，通过子类的原型对象去指向父类的实例，这样能继承到父类原型链上的属性和方法，代码如下<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'chicAboo'</span>;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Man.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 关键代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.age = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Man();</span><br><span class="line">m.showName(); <span class="comment">// chicAboo</span></span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> Man);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>原型链继承，通过子类的原型对象等于父类的实例，实现继承。<br>优点：<br>1、子类可继承父类构造函数中的属性、原型链上的属性和方法。</p>
<p>缺点：<br>1、子类创建的实例无法向父类传参；<br>2、父类引用类型的属性被所有实例所共享；如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.names = [];</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Man.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 关键代码</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> Man();</span><br><span class="line">m1.names.push(<span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> Man();</span><br><span class="line">m2.showName(); <span class="comment">// ['张三']</span></span><br></pre></td></tr></table></figure>
<p>从上面例子能看到，在父类Person的原型链上是引用类型即时，在子类实例m1上push一个值，m2也能访问。</p>
<h3 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h3><p>原型链继承和构造函数继承，都存在致命的缺点，原型链继承不能传参、原型链上属性为引用类型时会被所有的实例所共享；构造函数继承，只能继承到构造函数的属性和方法，每次创建实例，父类都重新生成一遍。为了解决这些问题，将它们组合起来使用，便解决了这些问题，同时组合继承也是JavaScript最常用的继承方式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.names = [];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line">Man.prototype = <span class="keyword">new</span> Person; <span class="comment">// 原型链继承关键代码</span></span><br><span class="line">Man.prototype.constructor = Man; <span class="comment">// Man的原型对象的constructor指向Person，需手动指回来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> Man(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> Man(<span class="string">'李四'</span>, <span class="number">25</span>);</span><br><span class="line">m1.names.push(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m2.names); <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>优点：<br>1、结合了前两种构造函数的优点，构造函数继承传参和原型链继承复用；<br>2、每个实例引用的构造函数属性都是私有的；</p>
<p>缺点：<br>1、调用了两次父类构造函数，Person.call(this)和Man.prototype = new Person()<br>2、子类上的构造函数会代替父类原型链上的构造函数（这不能算是缺点，上章讲过，类中查找属性和方法时，现在构造函数中查找，如果找不到，才会在原型链上查找，直到找到为止）</p>
<h3 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(obj)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用函数包装一个对象，返回这个函数的调用。ES5中Object.create的模拟实现，将传入对象作为创建对象的原型。<br>缺点：<br>1、 引用类型的属性值，会被所有的实例所共享，类似原型链。如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'chicABoo'</span>,</span><br><span class="line">    names: [<span class="string">'zs'</span>, <span class="string">'ls'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c1 = create(obj);</span><br><span class="line"><span class="keyword">const</span> c2 = create(obj);</span><br><span class="line">c1.names.push(<span class="string">'ww'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c2.names); <span class="comment">// ['zs', 'ls', 'ww]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h3><p>创建一个用于继承过程的封装函数，该函数内部以某种形式来做增强函数，返回该对象。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> <span class="params">(obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">clone</span> = Object.create(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clone</span>.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        console.log(<span class="string">'something...'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式类似构造函数继承，每次创建就会创建父类的构造函数。<br>缺点：<br>1、没有原型，无法复用；<br>2、每次都会创建一遍父类的构造函数；</p>
<h3 id="六、寄生组合式继承（常用）"><a href="#六、寄生组合式继承（常用）" class="headerlink" title="六、寄生组合式继承（常用）"></a>六、寄生组合式继承（常用）</h3><p>寄生组合在继承修正了组合继承调用两次父类问题，那么如何修正的呢？先看下组合继承，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.names = [];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用父类</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line">Man.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 第一次调用父类</span></span><br><span class="line">Man.prototype.constructor = Man;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> Man(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> Man(<span class="string">'李四'</span>, <span class="number">25</span>);</span><br><span class="line">m1.names.push(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m2.names); <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看到，子类共调用了父类两次。<br>第一次调用是子类的原型对象指向父类实例时<br><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">Man</span>.proto<span class="keyword">type</span> = new <span class="type">Person</span>()</span><br></pre></td></tr></table></figure></p>
<p>第二次调用时子类实例时，初始化了父类<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> Man(<span class="string">'张三'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">Person.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure></p>
<p>借鉴寄生式继承方式，可以避免<code>Man.prototype = new Person()</code>这一次调用，封装一个函数，创建父类的副本，为副本添加构造函数，并将副本赋给子类的原型。如下：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">_sub, _super</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(_super.prototype); <span class="comment">// 创建Super对象原型的副本</span></span><br><span class="line">    prototype.<span class="keyword">constructor</span> = _sub; <span class="comment">// 为创建的副本添加构造函数</span></span><br><span class="line">    _sub.prototype = prototype; <span class="comment">// 将新创建的副本赋值给子类的原型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">_sub, _super</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(_super.prototype); <span class="comment">// 创建Super对象原型的副本</span></span><br><span class="line">    prototype.constructor = _sub; <span class="comment">// 为创建的副本添加构造函数</span></span><br><span class="line">    _sub.prototype = prototype; <span class="comment">// 将新创建的副本赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Man, Person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Man(<span class="string">'chicABoo'</span>, <span class="number">35</span>);</span><br><span class="line">c1.showName(); <span class="comment">// chicABoo</span></span><br><span class="line"><span class="built_in">console</span>.log(c1.age); <span class="comment">// 35</span></span><br><span class="line"><span class="built_in">console</span>.log(c1 <span class="keyword">instanceof</span> Man); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(c1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>借用高程上的话来说：<br>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript执行机制一</title>
    <url>/2021/05/21/js/JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="JavaScript-的执行顺序"><a href="#JavaScript-的执行顺序" class="headerlink" title="JavaScript 的执行顺序"></a>JavaScript 的执行顺序</h2><p>对于人的直观感受而言，一串 JavaScript 的代码执行逻辑应该是一行一行的执行的，那么 JavaScript 的执行是否是一行一行的执行的呢？先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// fn2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">// fn2</span></span><br></pre></td></tr></table></figure>
<p>两次调用函数的结果都是 fn2，为什么是这样的？先不管为什么，再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"Jackson"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"showName函数被执行"</span>); <span class="comment">// showName函数被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设 JavaScript 引擎执行的代码是一行一行的执行，那么执行到第一行代码就会报错，但是实际上却调用了 showName 函数。执行第二行代码，在前面并没有声明 myName 变量，但是打印出来的结果却是 undefined，说明 myName 是声明了，未定义。这说明 JavaScript 引擎执行代码并不是一行一行的执行的。<br>JavaScript 引擎是如何执行一段代码的呢？</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>在了解 JavaScript 代码是如何执行之前，需要先了解什么是变量提升。<br>首先看看 JavaScript 的声明和赋值。</p>
<p>变量的声明和赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"Jackson"</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中变量可以拆解成 2 个部分，声明和复制，函数因为没有赋值操作，就是完整的声明，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="literal">undefined</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myName);</span><br><span class="line">&#125;</span><br><span class="line">myName = <span class="string">"Jackson"</span>; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>
<p>到这里了解了声明和赋值后，再来看看变量提升。</p>
<blockquote>
<p>变量提升是指 JavaScript 在执行的过程中，JavaScript 引擎会把变量声明的部分和函数声明的部分提升到代码开头的行为，变量提升后会给默认值为 undefined。</p>
</blockquote>
<p>结合变量提升的概念，模拟一下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">"Jackson"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"showName函数被执行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  变量提升部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'showName函数被执行'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  可执行部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myName = <span class="string">'Jackson'</span>;</span><br></pre></td></tr></table></figure>
<p>通过这段代码的模拟，我们知道<code>函数和变量在执行代码之前已经被提升到了代码开头</code>。变量的提升意味着从物理层面上把代码移到了最前面，正如上面模拟的一样，变量和函数在执行的过程中，并不会改变位置，而是在编译阶段被 JavaScript 引擎放入了内存中。故一段 JavaScript 的执行的大致流程如下：</p>
<ol>
<li>编译阶段：对变量和函数进行变量提升操作，如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  变量提升部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'showName函数被执行'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行代码阶段：一行一行的执行代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  可执行部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line">myName = <span class="string">'Jackson'</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript 代码经过编译后会分为两个部分：<code>执行上下文和可执行代码</code>。执行上下文分为：全局执行上下文、函数执行上下文、eval 执行上下文；</p>
<p>执行上下文是 JavaScript 执行一段代码时的运行环境。具体可以看下图：<br><img src="/images/js/JavaScript执行机制/execution_context1.jpg" alt="执行上下文"></p>
<p>上图中执行上下文中存放一个<code>变量环境的对象（Viriable Environment）</code>，该对象中保存了变量提升的内容，如 myName 和 showName 函数，当然执行上下文还有其他的对象，如块级作用域中的变量存放在词法环境；每一个执行上下文都存放有一个外部引用 outer，存放于外部环境；以及每一个执行上下文中都存放有一个 this。这些后面会详细讲解，这儿就不多说了。</p>
<p>变量环境中存放的对象可简单表示为如下结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ViriableEnvironment:</span><br><span class="line">  myName -&gt; <span class="literal">undefined</span>,</span><br><span class="line">  showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>
<p>在执行阶段，JavaScript 引擎对可执行代码，按照顺序进行一行一行的执行。显示对声明的 myName 进行赋值操作，然后执行 showName 方法，变量环境如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ViriableEnvironment:</span><br><span class="line">  myName -&gt; <span class="string">'Jackson'</span>,</span><br><span class="line">  showName -&gt;<span class="function"><span class="keyword">function</span> : </span>&#123;<span class="built_in">console</span>.log(myname)</span><br></pre></td></tr></table></figure>
<p>到这里已经明白了 JavaScript 执行代码的机制，首先 JavaScript 引擎会对代码进行编译，编译阶段会有变量提升的部分，存放于变量环境，然后是代码执行部分。那么如果有两个相同的变量和函数 JavaScript 会如何执行呢？结合本文的第一个例子，后面的代码会覆盖前面的代码。</p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>上面提到过，一段代码经过编译并创建执行上下文，分为三种情况：</p>
<blockquote>
<ol>
<li>全局执行上下文：在执行 JavaScript 全局代码的时候，会编译全局代码创建全局执行上下文，在整个页面的生存周期内，只有一份全局执行上下文；</li>
<li>函数执行上下文：在调用一个函数时，会编译函数内部代码，并创建函数执行上下文，在函数执行结束后，创建的函数执行上下文会被销毁；</li>
<li>当使用 eval 函数时，eval 代码会被编译，并创建 eval 执行上下文；</li>
</ol>
</blockquote>
<p>明确了三种执行上下文的情况，在谈谈什么是调用栈，调用栈是一种<code>栈（后进先出）</code>的数据结构。调用栈是用来管理函数调用关系的数据结构。如下 JavaScript 代码，执行上下文是如何创建并存储的呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">10</span>;</span><br><span class="line">  res = fn1(b, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码声明了一个变量 a，函数 fn1、fn2，在全局范围内调用 fn2，fn2 中调用 fn1，在整个代码的执行过程中调用栈是如何执行的呢？下面会一步一步分析，调用栈的变化情况。</p>
<ol>
<li><p>创建全局上下文，并将其压入栈底，如图：<br><img src="/images/js/JavaScript执行机制/call_stack1.jpg" alt="执行上下文"><br>从图中可以看出来，变量 a，函数 fn1 和 fn2 都保存到了全局上下文的变量环境对象中。需要注意的是，函数调用伴随的值传递的过程。全局执行上下文压入栈后，JavaScript 开始执行全局代码，首先将执行 a = 2 的赋值操作。</p>
</li>
<li><p>调用 fn2 方法，JavaScript 引擎会编译该函数，创建执行上下文，并压入调用栈中，如下图所示<br><img src="/images/js/JavaScript执行机制/call_stack2.jpg" alt="执行上下文"><br>函数 fn2 执行上下文后，便开始执行函数 fn2 中的代码，将 fn2 中的 10 赋值给 d，即 d = 10；</p>
</li>
<li><p>调用 fn1 方法，JavaScript 引擎会编译该函数，创建执行上下文，并压入调用栈中，如下图所示<br><img src="/images/js/JavaScript执行机制/call_stack3.jpg" alt="执行上下文"><br>函数 fn1 执行上下文入栈后，便开始执行 fn1 中的代码，将 fn1 中的 5 赋值给 a，即 a = 5;并执行 a + b + c，返回给 fn2 函数中的调用 res 调用方。</p>
</li>
<li><p>fn1 执行完成后，fn1 执行上下文出栈，如图<br><img src="/images/js/JavaScript执行机制/call_stack4.jpg" alt="执行上下文"><br>fn1 执行完成后，会将返回值赋值给 fn2 中的 res，即 res = 10</p>
</li>
<li><p>fn2 执行完成后，fn2 执行上下文出栈，如图<br><img src="/images/js/JavaScript执行机制/call_stack5.jpg" alt="执行上下文"><br>fn2 执行完成后，将返回值 res + d 的结果返回，因全局环境没有变量接收，故函数 fn2 执行上下文出栈。到此，调用栈中只剩下全局执行上下文，将全局执行上下文的代码执行完成，结束。</p>
</li>
<li><p>栈溢出<br>调用栈是存在大小的，当栈的空间满后，就会存在栈溢出的情况，如下代码</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stackOverflow</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * stackOverflow(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">stackOverflow(<span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<p>上面函数是计算阶乘使用，当递归调用 5 万次，即每一次执行函数都会产生一个执行上下文，存入调用栈，我使用的时 chrome81 版本浏览器，调用栈的大小为<code>12540</code>，故超出调用栈的大小会出现栈溢出的情况。<br>那么如何解决呢？<br>这里有两种方法:</p>
<blockquote>
<ol>
<li>将每次执行的结果存入宏任务队列中，借助 setTimeout；</li>
<li>通过尾递归的方式处理，但是很多浏览器不兼容，尾递归方式无意义，不如直接循环；</li>
</ol>
</blockquote>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>由于 JavaScript 的变量提升，造成很多不符合直观感受的代码，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">"Jackson"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">"Monchic"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： Monchic</span></span><br></pre></td></tr></table></figure>
<p>正常的逻辑应该是输出<code>Jackson</code>的，但是因为变量提升的关系，输出的是<code>Monchic</code>，这不得不说是 JavaScript 的设计缺陷，在 es6 中提出了块级作用域，解决了因变量提升造成很多直觉不一致的代码。</p>
<p>块级作用域是使用大括号包裹的一段代码，比如函数、判断语句、循环语句、单独块等，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if块</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while块</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独一个块</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解块级作用域，通过 let 改写下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myName = <span class="string">"Jackson"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myName = <span class="string">"Monchic"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： Jackson</span></span><br></pre></td></tr></table></figure>
<p>结果即是我们预期的结果。<br>我们知道，通过 var 声明的变量是存放到执行上下文中的变量环境中的，那么通过 let 和 const 声明的变量存放到哪里呢？</p>
<h2 id="JavaScript-引擎如何支持块级作用域？"><a href="#JavaScript-引擎如何支持块级作用域？" class="headerlink" title="JavaScript 引擎如何支持块级作用域？"></a>JavaScript 引擎如何支持块级作用域？</h2><p>我们可以通过 let 和 const 声明块级作用域，在一段代码中，使用的有 let、const 和 var，JavaScript 引擎能同时支持变量提升和块级作用域，那么 JavaScript 引擎是如何同时支持的呢？<br>首先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>结合前面将的执行上下文的思路，执行上下文的思想来分析内存中的存储情况，<code>块级作用域是存放在执行上下文中的词法环境中</code>，它是一个小型的栈结构。</p>
<ol>
<li><p>编译并创建执行上下文，如图<br><img src="/images/js/JavaScript执行机制/block1.jpg" alt="执行上下文"><br>分析上图：</p>
<blockquote>
<ul>
<li>通过 var 声明的变量 a 和 c 存放到执行上下文中的变量环境中</li>
<li>通过 let 声明的变量 b 存放到执行上下文中的词法环境中</li>
</ul>
</blockquote>
</li>
<li><p>编译块级作用域代码<br>当执行块级作用域中代码时，变量环境中的 a 的值被设置成 1，词法环境中的变量 b 被设置成 2，同时对块级作用域中的代码进行编译，如图所示<br><img src="/images/js/JavaScript执行机制/block2.jpg" alt="执行上下文"></p>
<p>分析上图：</p>
<blockquote>
<ul>
<li>块级内部通过 let 声明了变量 b，这个区域的变量 b 并不会影响外部的变量 b，在词法环境入栈，当执行完成后再出栈；</li>
<li>块级内部通过 var 声明了变量 c，编译时会对 c 变量提升，在变量环境中存放 c = undefined，当执行代码的时候变量 c 会被设置成 4；</li>
<li>块级内部通过 let 声明了变量 d，编译变量 d 时，编译后的在赐福环境入栈，然执行时，变量 c 会被设置成 5；</li>
</ul>
</blockquote>
</li>
</ol>
<p><img src="/images/js/JavaScript执行机制/block3.jpg" alt="执行上下文"><br>在词法环境中，会维护一个小型的栈结构，栈底是最外层通过 let 或 const 声明的变量，进入一个作用域后，会把该作用域内部通过 let 或 const 声明的变量存入栈顶，当作用域执行完成会从栈顶弹出。<br>当执行到 console.log(a)时，JavaScript 引擎会先从词法环境中查找变量，如果找到就返回给 JavaScript 引擎，如果没找到会到变量环境中继续查找。如下图所示<br><img src="/images/js/JavaScript执行机制/block4.jpg" alt="执行上下文"></p>
<p>块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<ol>
<li>JavaScript 代码在执行的过程中，需要先做变量提升，之所以如此，是因为 JavaScript 代码再执行前需要进行<code>编译</code>；</li>
<li>在编译阶段，变量和函数会被存放到<code>变量环境</code>中，变量的默认值为 undefined；块级作用域会被存放到<code>词法环境</code>中；</li>
<li>在编译阶段，存在两个相同的函数，后面的会覆盖前面的函数；</li>
<li>调用函数时，JavaScript 引擎维护了一个栈的数据结构（调用栈），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；</li>
<li>当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈；</li>
<li>当分配的栈控件被占满时，会引发<code>栈溢出</code>的情况；</li>
</ol>
</blockquote>
<p>在最后一个例子中，我们在查找变量时，先从词法环境中查找，找不到会到变量环境中查找，直到找了为止，这个查找的逻辑底层是怎么实现的呢？this 是怎么定义的？闭包产生的原因？等等问题，JavaScript 引擎是工作的，请关注下一节《JavaScript 运行机制二》</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手写call、apply和bind函数</title>
    <url>/2021/04/08/js/%E6%89%8B%E5%86%99call-apply%E5%92%8Cbind%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到改变 this 的指向，首先想到的方式就是 call、apply 和 bind。对于每种方式底层是如何实现，大多数人不太清楚，如果你还不清楚他们的用法，请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind</a>。本文会简单讲解他们的用法，底层实现思路，及模拟实现 call、apply、bind。</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><h3 id="1、定义：-使用一个指定的-this-值和单独给出一个或多个参数来调用一个函数。"><a href="#1、定义：-使用一个指定的-this-值和单独给出一个或多个参数来调用一个函数。" class="headerlink" title="1、定义： 使用一个指定的 this 值和单独给出一个或多个参数来调用一个函数。"></a>1、定义： 使用一个指定的 this 值和单独给出一个或多个参数来调用一个函数。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">call</span>(<span class="params">this, arg1, arg2, arg3, ...</span>)</span></span><br></pre></td></tr></table></figure>
<p>根据定义我们知道，call()方法有两个作用，一个是改变 this 指向，另外一个传递参数，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, arg); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子，使用 call()方法使函数<code>fn</code>的 this 指向了<code>obj</code>，所以 this.value 的值为 1。那么如果不使用 call()方法，该如何实现呢？</p>
<h3 id="2、call-实现思路"><a href="#2、call-实现思路" class="headerlink" title="2、call 实现思路"></a>2、call 实现思路</h3><p>不考虑使用 call、apply、bind 方法，上面例子 fn 函数如何能拿到 obj 里面的 value 值呢？改造一下上面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure>
<p>这样一改，this 就指向了 obj，根据这个思路，可以封装一个方法，将传入的 this，转换成这样的方式，那么当前 this 的指向就是我们想要的结果。<code>需要注意fn函数不能写成箭头函数，因为箭头函数没有this</code>。所以模拟的步骤为：</p>
<ol>
<li>将函数设置为传入对象的属性；</li>
<li>执行该函数；</li>
<li>删除该属性；<br>上面的例子就可以改写为：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给obj添加属性func</span></span><br><span class="line">obj.func = fn;</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">obj.func();</span><br><span class="line"><span class="comment">// 删除添加的属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.func;</span><br></pre></td></tr></table></figure>
<h3 id="3、模拟-call-方法"><a href="#3、模拟-call-方法" class="headerlink" title="3、模拟 call 方法"></a>3、模拟 call 方法</h3><p>根据上面的思路，来模拟实现一版 call()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.func = <span class="keyword">this</span>;</span><br><span class="line">  context.func();</span><br><span class="line">  <span class="keyword">delete</span> context.func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了简化版 call 方法，来试验下是否能正确改变 this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, arg); <span class="comment">// 1, undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call1(obj, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>根据上面例子，已经能正确改变 this 的指向，但是传入的值却没有拿到，该怎么办呢？考虑的传入的值是不确定的，只能借助<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">Arguments 对象</a>。通过它可以拿到所有传入的参数。</p>
<h3 id="4、模拟-call-方法第二版"><a href="#4、模拟-call-方法第二版" class="headerlink" title="4、模拟 call 方法第二版"></a>4、模拟 call 方法第二版</h3><p>上面提到可以通过 arguments 解决传入参数不定长问题，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line"><span class="comment">// 因为第一个参数是传入的this，故这里从i = 1开始遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    res.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> args = [...arguments].splice(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这样就能拿到所有的参数，接下来我们是不是将拿到的参数放到函数里面执行就可以了吗？先试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化存储函数参数</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="comment">// 改变当前函数的this指向</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        res.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.fn(res.join(<span class="string">','</span>));</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, ...arguments); <span class="comment">// 1 "1,2,200,[object Object]"</span></span><br><span class="line">&#125;</span><br><span class="line">fn.call1(obj, [<span class="number">1</span>,<span class="number">2</span>], <span class="number">200</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>结果和我们期望的不一致，函数的参数被转换成了一个字符串，那么怎么出来才能达到想要的结果呢？这儿可以考虑两种方式处理</p>
<p>第一种方式 es6 的“…”操作符，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化存储函数参数</span></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="comment">// 改变当前函数的this指向</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        res.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.fn(...res);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, ...arguments);  <span class="comment">// 1 [1, 2] 200 &#123;a: 1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.call1(obj, [<span class="number">1</span>,<span class="number">2</span>], <span class="number">200</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>第二种方式，借助<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">eval</a>方法，eval 会将传入的字符串当做 JavaScript 代码执行。那么我们可以考虑将要执行的函数，拼装成字符串，然后通过 eval 执行即可。思路如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化，用于存放参数</span></span><br><span class="line">   <span class="keyword">const</span> args = [];</span><br><span class="line">   <span class="comment">// 在传入的对象上设置属性为待执行函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 将参数从第二个开始，拼装成待执行的字符串参数列表</span></span><br><span class="line">       args.push(<span class="string">`arguments[<span class="subst">$&#123;i&#125;</span>]`</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">eval</span>(<span class="string">`context.fn(<span class="subst">$&#123;args&#125;</span>)`</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">   value: <span class="number">1</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, ...arguments); <span class="comment">// 1 [1, 2] 200 &#123;a: 1&#125;</span></span><br><span class="line"> &#125;</span><br><span class="line"> fn.call1(obj, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">200</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>到这里，通过模拟实现 call 方法，已经能实现改变 this，传入参数，是不是就完了呢？可能会有这样一种情况，如果函数本身会有返回值，还是用吗？如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, ...args); <span class="comment">// 1 [1, 2] 200 &#123;a: 1&#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c: args,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn.call1(obj, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">200</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此时，执行函数的返回值为<code>undefined</code>，解决这个问题很好办，在封装的 call 方法里面，将执行的函数结果存下来，return 出来即可，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，用于存放参数</span></span><br><span class="line">    <span class="keyword">const</span> args = [];</span><br><span class="line">    <span class="comment">// 在传入的对象上设置属性为待执行函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 将参数从第二个开始，拼装成待执行的字符串参数列表</span></span><br><span class="line">      args.push(<span class="string">`arguments[<span class="subst">$&#123;i&#125;</span>]`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">`context.fn(<span class="subst">$&#123;args&#125;</span>)`</span>);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value, ...args); <span class="comment">// 1 [1, 2] 200 &#123;a: 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      c: args[<span class="number">0</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(fn.call1(obj, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">200</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)); <span class="comment">// &#123;c: [1, 2]&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="模拟-call-终版"><a href="#模拟-call-终版" class="headerlink" title="模拟 call 终版"></a>模拟 call 终版</h3><p>上面的方式都是使用 eval 来实现 call 方法，es6 提供了很多语法糖，个人比较喜欢 es6 的实现方式，比较简洁，故终版使用的 es6 的实现方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，获取传入的this对象和后续所有参数</span></span><br><span class="line">    <span class="keyword">const</span> [context, ...args] = [...arguments];</span><br><span class="line">    <span class="comment">// 在传入的对象上设置属性为待执行函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">const</span> res = context.fn(args);</span><br><span class="line">    <span class="comment">// 删除属性</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>到此，模拟实现了 call 方法。</p>
<h2 id="模拟-apply-方法"><a href="#模拟-apply-方法" class="headerlink" title="模拟 apply 方法"></a>模拟 apply 方法</h2><h3 id="定义：-调用一个具有给定-this-值的函数，及以一个数组的形式提供的参数。"><a href="#定义：-调用一个具有给定-this-值的函数，及以一个数组的形式提供的参数。" class="headerlink" title="定义： 调用一个具有给定 this 值的函数，及以一个数组的形式提供的参数。"></a>定义： 调用一个具有给定 this 值的函数，及以一个数组的形式提供的参数。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.apply(thisArg, [argsArray]);</span><br></pre></td></tr></table></figure>
<p>从定义上知道，apply 相比于 call 方法，区别在与 this 后面的参数,call 后面的有一个或多个参数，而 apply 只有两个参数，第二个参数是一个数组，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...arguments]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>apply 的实现思路和 call 一样，需要考虑的是 apply 只有两个参数，因此，根据 call 的思路实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply1 = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 给传入的对象添加属性，值为当前函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断第二个参数是否存在，不存在直接执行，否则拼接参数执行，并存储函数执行结果</span></span><br><span class="line">    <span class="keyword">let</span> res = !args ? context.fn() : context.fn(...args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除新增属性</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回函数执行结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...arguments]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.apply(obj, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="模拟-bind"><a href="#模拟-bind" class="headerlink" title="模拟 bind"></a>模拟 bind</h2><h3 id="定义：创建一个新的函数，在-bind-被调用时，这个新函数的-this-被指定为-bind-的第一个参数，而其余参数将作为新函数的参数，供调用时使用。"><a href="#定义：创建一个新的函数，在-bind-被调用时，这个新函数的-this-被指定为-bind-的第一个参数，而其余参数将作为新函数的参数，供调用时使用。" class="headerlink" title="定义：创建一个新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。"></a>定义：创建一个新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">bind</span>(<span class="params">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>
<p>bind 相比于 call、apply 有较大的区别，bind 方法会创建一个新的函数，返回一个函数，并允许传入参数。首先看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = obj.fn;</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>为什么值是 undefined 呢？这会涉及到 this 的问题，不清楚的可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">这里</a>，简单来讲，函数的调用决定 this 的值，即运行时绑定。这里声明了 func 用于存放 obj.fn,再执行 func()方法时，当前的 this 指向的是 window 是，故值为 undefined。改如何处理才能达到预期的值呢？这时 bind 即将登场。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = obj.fn;</span><br><span class="line"><span class="keyword">const</span> bindFunc = func.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(bindFunc()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="模拟-bind-第一版"><a href="#模拟-bind-第一版" class="headerlink" title="模拟 bind 第一版"></a>模拟 bind 第一版</h3><p>首先解决 bind 的第一个问题，返回一个函数，可通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包</a>的模式实现，改变 this 指向问题，可以使用 call 和 apply 方法，可参照上面的实现方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前函数的this存放起来</span></span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 改变this</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(context);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>this 改变了后，需要考虑第二个问题，传参，bind 的参数，从第二个到第 n 个函数，存在参数不定的情况，结合上面 call 的实现方式，解决这个问题如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1, 从第二个参数开始</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">const</span> [context, ...args] = [...arguments];</span><br></pre></td></tr></table></figure>
<p>参数取到后，将参数传入即可，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前函数的this存放起来</span></span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 绑定bind传入的参数，从第二个开始</span></span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定bind返回新的函数，执行所带的参数</span></span><br><span class="line">    <span class="keyword">const</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 改变this</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(context, [...args, ...bindArgs]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="keyword">this</span>.value,</span><br><span class="line">      args: [...arguments],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = obj.fn;</span><br><span class="line"><span class="keyword">const</span> bindFunc = func.bind1(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bindFunc(<span class="number">3</span>)); <span class="comment">// &#123; value: 1, args: [1, 2, 3]&#125;</span></span><br></pre></td></tr></table></figure>
<p>到这里，bind 的模拟已经完成一半，为什么说完成一半呢？功能已经实现，考虑到有这样一种情况，将绑定的 bind 返回的新函数作为构造函数使用，使用<code>new</code>操作符去创建一个由目标函数创建的新实例。当绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。什么意思呢？先看下面例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// jack</span></span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindPerson = Person.bind1(obj, <span class="string">"jack"</span>);</span><br><span class="line"><span class="keyword">var</span> bp = <span class="keyword">new</span> bindPerson(<span class="number">35</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出，尽管已经在全局和 obj 上定义了 value 值，但是构造函数 Person 中拿到的 this.value 仍然是 undefined 值，说明 this 的绑定失效了，为什么会出现这样的情况呢？<br>出现这样的情况是因为关键字<code>new</code>造成的，当程序遇到 new 会进行如下的操作：</p>
<ol>
<li>创建一个空的简单的 JavaScript 对象（如{}）;</li>
<li>设置该对象的 constructor 到另外一个对象；</li>
<li>将步骤 1 创建的对象作为 this 的上下文；</li>
<li>如果函数没有返回对象则返回 this；<br>这样就明白为什么 this.value 的值为 undefined 了，当前的 this 指向的是 bp，bp 上并没有 value 属性，所以为 undefined。</li>
</ol>
<h3 id="模拟-bind-终版"><a href="#模拟-bind-终版" class="headerlink" title="模拟 bind 终版"></a>模拟 bind 终版</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将当前函数的this存放起来</span></span><br><span class="line">  <span class="keyword">var</span> _self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 绑定bind传入的参数，从第二个开始</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明一个空的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fNOP</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定bind返回新的函数，执行所带的参数</span></span><br><span class="line">    <span class="keyword">const</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 合并数组</span></span><br><span class="line">    args.push.apply(args, bindArgs);</span><br><span class="line">    <span class="comment">// 作为普通函数，this指向Window</span></span><br><span class="line">    <span class="comment">// 作为构造函数，this指向实例</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : context, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    <span class="comment">// 修改返回函数的prototype为绑定函数的prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FNOP继承fBound</span></span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面用到了原型与原型链、继承等知识，不清楚的可以转到到<a href="https://juejin.cn/post/6914158539787370509" target="_blank" rel="noopener">《JavaScript 之深入原型与原型链》</a>、<a href="https://juejin.cn/post/6914643284803452935" target="_blank" rel="noopener">《JavaScript 之深入多种继承方式及优缺点》</a>。<br>到这里，还需要思考调用 bind 不是函数怎么办？报个错就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里模拟的 bind 函数不是最终版，在 CDN 上有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind 实现</a>;</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">《Function.prototype.call()》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">《Function.prototype.bind()》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">《Function.prototype.apply()》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">《JavaScript 深入之 bind 的模拟实现》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux管理状态-todoList实现</title>
    <url>/2018/11/23/react/Redux%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81-todoList%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux的学习，让人又爱又狠，爱它状态管理的便捷，恨它的文档让人一脸懵逼。总之学习Redux的过程痛并快乐着。为什么要些这篇文章？经历了从Redux文档一步一步爬过来，踩了无数地雷，死了无数脑细胞，连亲爱的头发也一天天离我远去，终于神功大成…。话说当年，文档已烂熟于心，本以为从此React江湖任我游，不想，刚出门就差点撞死在<code>Action</code>的门口；好不容易，将货(<code>data</code>),开着兰博基尼(<code>dispatch</code>)送到了仓库(<code>store</code>),不曾想，一堆相同的烂货(<code>initState</code>),陈列在仓库，散发着腐朽的味道，苍蝇呜呜呜的拍打着翅膀，仿佛在嘲笑着<del>傻逼傻逼</del>。拖着疲惫的步伐将货更换完成(<code>reducer</code>),开心的骑着电动小马达，越行越远…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写文章的目的为了记录学习新技术的心路历程，以及对当前学习技术的一个总结。顺便带着，如果正在学习，正在看的你有一点点帮助，那么人生便已圆满，废话已经写了这么多，如果不喜欢，欢迎来喷。一直坚信，做技术的，如果不在被喷中成长，就在喷子的口水中变成泼妇。</p>
<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章讲到使用react实现todoList,使用react做一些简单的页面交互可行，如果页面上的功能比较复杂，多组件之间的交互频繁，只是用react会使整个程序变得非常复杂，不利于维护，可能做到后面自己都不清楚数据是怎么走向的。怎么办呢？2014年Facebook就提出了Flux架构的概念，引发了一系列的实现。2015年，Redux的出现，将Flux与函数式变成结合在一起，很快就成为了前端的热门框架。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux是什么，其实Redux就是React的状态管理工具，当然React状态管理工具不止Redux，比如Mobx等，个人觉得使用Mobx更简单，本文主要介绍如何使用Redux一步一步使用页面功能开发。文章中会简单如何使用阿里的ReactUI组件antd。本文主要讲如何使用Redux管理React的状态，不会涉及太多的原理，想看原理，为啥不直接到官网去，带图的、彩色的、各国的都有，看的你不能自我、欲罢不能。</p>
<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脚手架使用<code>create-react-app</code>, 不清楚如何安装，请看上一篇文章<a href="https://www.jianshu.com/p/60dea52bd960" target="_blank" rel="noopener">React的增删功能-todoList实现</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装Redux: <code>npm install -S redux</code></p>
<h3 id="二、Redux知识总览"><a href="#二、Redux知识总览" class="headerlink" title="二、Redux知识总览"></a>二、Redux知识总览</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redux管理React状态的步骤。<code>Action</code>描述事件简单对象，它是改变<code>store</code>中<code>state</code>的唯一方法，通过<code>store.dispatch()</code>方法将<code>Action</code>传到<code>store</code>中。<code>Action</code>的作用只是传递数据，并没有更新数据，如何更新数据<code>Reducer</code>的工作。<code>Reducer</code>接收到<code>Action</code>传入的对应数据，更新数据后返回到store，更新页面。简化来讲，<code>用户触发事件 -&gt;action(dispatch分发) -&gt; store -&gt; Reducer更新数据 -&gt; 返回更新后的数据到store -&gt; 更新页面</code>。如下图：<br>    <img src="https://upload-images.jianshu.io/upload_images/12926544-a3205fe638c36463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux流程图"></p>
<h3 id="三、Redux实现TodoList"><a href="#三、Redux实现TodoList" class="headerlink" title="三、Redux实现TodoList"></a>三、Redux实现TodoList</h3><h6 id="1-Action"><a href="#1-Action" class="headerlink" title="1. Action"></a>1. Action</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Action</code>是把数据从应用传到<code>store</code>的有效载荷，它是<code>store</code>的<code>唯一</code>来源。通过<code>store.dispatch()</code>将数据传到<code>store</code>。<code>Action</code>是一个对象，里面必须有属性<code>type</code>,type是一个常量,type的作用是数据在Reducer中对应匹配数据使用。在这里我们可以思考下每一个<code>Action</code>都会有对应的type，那么一个网站必然会有很多的type，便于后期维护，最好把type放到统一的文件夹中进行管理。<br>   <code>Action</code>是一个对象，type表示Action的名称。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   type: INIT_LIST,</span><br><span class="line">   payload: data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，Action的名称是<code>INIT_LIST</code>,它携带的信息是<code>data</code>数据。</p>
<h6 id="2-Action-Creator"><a href="#2-Action-Creator" class="headerlink" title="2. Action Creator"></a>2. Action Creator</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;View要发多少种信息，就会有多少个Action，如果每个都要写，那么会很麻烦，也不利于维护。使用ActionCreator.js统一管理所有的Action。同时Action的名称type，统一使用ActionTypes.js管理。名称可以随便取，不做强求。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INIT_LIST = <span class="string">'init_list'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initListAction = <span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;</span><br><span class="line">    type: INIT_LIST,</span><br><span class="line">    data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码<code>initListAction</code>函数就是一个Action。</p>
<h6 id="3-store-dispatch"><a href="#3-store-dispatch" class="headerlink" title="3. store.dispatch()"></a>3. store.dispatch()</h6><p>store.dispatch()是View发出Action的唯一方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: INIT_LIST,</span><br><span class="line">  data: <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，<code>store.dispatch</code>接收一个Action对象作为参数，发送给store。<br>结合<code>initListAction</code>，可改写成：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.dispatch(initListAction(data));</span><br></pre></td></tr></table></figure></p>
<h6 id="4-Reducer"><a href="#4-Reducer" class="headerlink" title="4. Reducer"></a>4. Reducer</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store收到Action后，必须给出新的state，这样View才能发生变化，计算state的过程交Reducer。Reducer是一个纯函数，即有什么样的输入就有什么样的输出。Reducer的写法如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE, SUBMIT_BTN_ITEM, DELETE_ITEM, INIT_LIST &#125; <span class="keyword">from</span> <span class="string">'../actions/types'</span></span><br><span class="line"><span class="keyword">const</span> initialList = &#123;</span><br><span class="line">    inputValue: <span class="string">''</span>,</span><br><span class="line">    list: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> reducerList = <span class="function">(<span class="params">state = initialList, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> CHANGE_INPUT_VALUE:</span><br><span class="line">            <span class="keyword">const</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">            newState.inputValue = action.inputValue;</span><br><span class="line">            <span class="keyword">return</span> newState;</span><br><span class="line">        <span class="keyword">case</span> SUBMIT_BTN_ITEM:</span><br><span class="line">            <span class="keyword">const</span> submitState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">            <span class="built_in">console</span>.log(submitState);</span><br><span class="line">            submitState.list.push(submitState.inputValue);</span><br><span class="line">            submitState.inputValue = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">return</span> submitState;</span><br><span class="line">        <span class="keyword">case</span> DELETE_ITEM:</span><br><span class="line">            <span class="keyword">const</span> deleteState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">            deleteState.list.splice(action.index);</span><br><span class="line">            <span class="keyword">return</span> deleteState;</span><br><span class="line">        <span class="keyword">case</span> INIT_LIST:</span><br><span class="line">            <span class="keyword">const</span> initState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">            initState.list = action.data;</span><br><span class="line">            <span class="keyword">return</span> initState;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>export default reducerList;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，type放在公用的文件夹中管理，Action的type和Reduce的type必须一致。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因会有很多Action，故使用switch的方式。如果case下面的数据比较复杂，可以单独提出来进行处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const newState = JSON.parse(JSON.stringify(state));</code>这句话的作用是深拷贝，目的是如果直接操作state,会影响其他View的数据。</p>
<h6 id="5-Store"><a href="#5-Store" class="headerlink" title="5. Store"></a>5. Store</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Store是保存数据的地方，整个应用只有一个Store。Redux提供了<code>createStore</code>函数来生成Store。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，<code>createStore</code>接收另外一个函数作为参数，返回新生成的Store对象。</p>
<h6 id="6-store-subscribe"><a href="#6-store-subscribe" class="headerlink" title="6. store.subscribe()"></a>6. store.subscribe()</h6><p><code>store.subscribe()</code>是Store的监听函数，一旦state改变，就会自动执行这个函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure></p>
<pre><code>store.subscribe(listener);
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，只要把View的更新数据替换上面的<code>listener</code>,当state改变时，就能更新数据。<br>绑定事件监听，完成后需要解除事件，只需执行<code>listener</code>就会自动解除监听。</p>
<h6 id="7-store-getState"><a href="#7-store-getState" class="headerlink" title="7. store.getState"></a>7. store.getState</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在View中需要使用state中的数据，使用<code>store.getState</code>获取store中state数据，展示到页面即可。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line">store.getState(state);</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面介绍了Redux一些基础的使用方法，一个完整的项目使用这样的方法，会比较繁琐，那么怎么办呢？下一节会讲到，中间键<code>redux-saga、redux-thunk</code>和异步的使用方法，同时会讲到antd UI组建的使用。想看源码请<a href="https://github.com/zhuLni/redux-todoList" target="_blank" rel="noopener">狠狠的点击这里</a>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>css-in-js框架style-components</title>
    <url>/2018/11/27/react/style-component/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端飞一般的发展中，衍生出各式各样的框架，框架的目的是减轻开发人员的开发难度，提高效率。以前网页开发的原则是<code>关注点分离</code>，意思是各种技术只负责自己的领域，不要混合在一起，形成耦合。如html、css、js代码分离。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React的出现，这个原则不在实用，React是组件结构，强制把html、css、js写在一起。如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">    <span class="string">'fontSize'</span>: <span class="string">'46px'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickHandler = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1 style=&#123;style&#125; onclick=&#123;clickHandler&#125;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码在一个js文件里，封装了结构、样式、逻辑，完全违背了<code>关注点分离</code>，很多人刚开始学习React很不适应，但是，这有利于组件的隔离，每个组件需要的代码不依赖于外部、组件之间没有耦合，方便复用。使用React的越来越多，组件模式深入人心，这种<code>关注点混合</code>的新写法逐渐成为主流。<br><img src="https://upload-images.jianshu.io/upload_images/12926544-78fb2ecaa29849c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关注点混合"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表面上，React的写法是html、css、js混合写在一起，实际上是用js在写html、css。React对html的封装是<code>jsx</code>，那么对css的封装是什么呢？这就涉及到今天需要讲的内容<code>style-components</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12926544-b23d58045a72fa6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css in js"></p>
<h3 id="什么是style-components"><a href="#什么是style-components" class="headerlink" title="什么是style-components"></a>什么是style-components</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components是针对React写的一套css in js框架，简单来讲就是在js中写css。相对于与预处理器(<code>sass、less</code>)的好处是，css in js使用的是js语法，不用重新再学习新技术，也不会多一道编译步骤。无疑会加快网页速度。如果有sass或less的开发经验，几分钟就可以学会style-components。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12926544-bd2a6d306912bb59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="style-components"></p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://www.styled-components.com/docs/basics" target="_blank" rel="noopener">https://www.styled-components.com/docs/basics</a></p>
<h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h6><p><code>npm install --save style-components</code></p>
<h6 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components最基础的用法就是以组件的形式编写样式，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HomeWrapper = styled.div <span class="string">`</span></span><br><span class="line"><span class="string">  width: 960px;</span></span><br><span class="line"><span class="string">  margin: 0 auto;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">const</span> HomeLeft = styled.div <span class="string">`</span></span><br><span class="line"><span class="string">  float: left;</span></span><br><span class="line"><span class="string">  width: 625px;</span></span><br><span class="line"><span class="string">  margin-left: 15px;</span></span><br><span class="line"><span class="string">  padding-top: 30px;</span></span><br><span class="line"><span class="string">  .bannder-img &#123;</span></span><br><span class="line"><span class="string">    width: 625px;</span></span><br><span class="line"><span class="string">    height: 270px;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="keyword">const</span> HomeRight = styled.div <span class="string">`</span></span><br><span class="line"><span class="string">  float: right;</span></span><br><span class="line"><span class="string">  width: 280px;</span></span><br><span class="line"><span class="string">  margin-left: 15px;</span></span><br><span class="line"><span class="string">  padding-top: 30px;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;HomeWrapper&gt;</span><br><span class="line">            &lt;HomeLeft&gt;</span><br><span class="line">                left</span><br><span class="line">            &lt;<span class="regexp">/HomeLeft&gt;</span></span><br><span class="line"><span class="regexp">            &lt;HomeRight&gt;</span></span><br><span class="line"><span class="regexp">                right</span></span><br><span class="line"><span class="regexp">            &lt;/</span>HomeRight&gt;</span><br><span class="line">        &lt;<span class="regexp">/HomeWrapper&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了三个组件，分别为<code>HomeWrapper 、HomeLeft 、HomeRight</code>，这样每一个组件对应唯一的样式，不在出现样式污染的情况。</p>
<h6 id="2-全局样式"><a href="#2-全局样式" class="headerlink" title="2. 全局样式"></a>2. 全局样式</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一个组件对应唯一的样式，那么需要设置全局样式怎么办呢？style-components的最新版提供了<code>createGlobalStyle</code>可以设置全局样式，如下：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import &#123; createGlobalStyle &#125; from 'styled-components';</span><br><span class="line"></span><br><span class="line">const GrobalStyle = createGlobalStyle `</span><br><span class="line">  <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">div</span>, <span class="selector-tag">span</span>, <span class="selector-tag">applet</span>, <span class="selector-tag">object</span>, <span class="selector-tag">iframe</span>,</span><br><span class="line">    <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">pre</span>,</span><br><span class="line">    <span class="selector-tag">a</span>, <span class="selector-tag">abbr</span>, <span class="selector-tag">acronym</span>, <span class="selector-tag">address</span>, <span class="selector-tag">big</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">code</span>,</span><br><span class="line">    <span class="selector-tag">del</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">img</span>, <span class="selector-tag">ins</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">q</span>, <span class="selector-tag">s</span>, <span class="selector-tag">samp</span>,</span><br><span class="line">    <span class="selector-tag">small</span>, <span class="selector-tag">strike</span>, <span class="selector-tag">strong</span>, <span class="selector-tag">sub</span>, <span class="selector-tag">sup</span>, <span class="selector-tag">tt</span>, <span class="selector-tag">var</span>,</span><br><span class="line">    <span class="selector-tag">b</span>, <span class="selector-tag">u</span>, <span class="selector-tag">i</span>, <span class="selector-tag">center</span>,</span><br><span class="line">    <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">li</span>,</span><br><span class="line">    <span class="selector-tag">fieldset</span>, <span class="selector-tag">form</span>, <span class="selector-tag">label</span>, <span class="selector-tag">legend</span>,</span><br><span class="line">    <span class="selector-tag">table</span>, <span class="selector-tag">caption</span>, <span class="selector-tag">tbody</span>, <span class="selector-tag">tfoot</span>, <span class="selector-tag">thead</span>, <span class="selector-tag">tr</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>,</span><br><span class="line">    <span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">canvas</span>, <span class="selector-tag">details</span>, <span class="selector-tag">embed</span>,</span><br><span class="line">    <span class="selector-tag">figure</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>,</span><br><span class="line">    <span class="selector-tag">menu</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">output</span>, <span class="selector-tag">ruby</span>, <span class="selector-tag">section</span>, <span class="selector-tag">summary</span>,</span><br><span class="line">    <span class="selector-tag">time</span>, <span class="selector-tag">mark</span>, <span class="selector-tag">audio</span>, <span class="selector-tag">video</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">font</span>: inherit;</span><br><span class="line">        <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* HTML5 display-role reset for older browsers */</span></span><br><span class="line">    <span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">details</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">figure</span>,</span><br><span class="line">    <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>, <span class="selector-tag">menu</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">section</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line">        <span class="attribute">quotes</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>, <span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,</span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-pseudo">:before</span>, <span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">        <span class="attribute">content</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">table</span> &#123;</span><br><span class="line">        <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">        <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@font-face</span> &#123;</span><br><span class="line">      <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;  <span class="comment">/* project id 897264 */</span></span><br><span class="line">      <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_897264_7ma62sn10m3.eot'</span>);</span><br><span class="line">      <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_897264_7ma62sn10m3.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_897264_7ma62sn10m3.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_897264_7ma62sn10m3.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">      <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_897264_7ma62sn10m3.svg#iconfont'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">      <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">      <span class="attribute">font-style</span>:normal;</span><br><span class="line">      <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">      <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;<span class="attribute">visibility</span>: hidden;<span class="attribute">display</span>: block;<span class="attribute">font-size</span>: <span class="number">0</span>;<span class="attribute">content</span>: <span class="string">"."</span>;<span class="attribute">clear</span>: both;<span class="attribute">height</span>: <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="selector-class">.clearfix</span> &#123;<span class="attribute">zoom</span>: <span class="number">1</span>;&#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">render</span>() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;<span class="selector-tag">Fragment</span>&gt;</span><br><span class="line">            &lt;Provider&gt;...&lt;/Provider&gt;</span><br><span class="line">            &lt;GrobalStyle/&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码<code>GrobalStyle</code>是全局样式组件，只需在React组件的最外层引入即可。</p>
<h6 id="3-图片引入"><a href="#3-图片引入" class="headerlink" title="3. 图片引入"></a>3. 图片引入</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要图片引入，如果像css一样的引入方式，会报错。正确的引入方式是import导入，再以变量的方式引入，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span>;</span><br><span class="line"><span class="keyword">import</span> logPic <span class="keyword">from</span> <span class="string">'../../statics/images/logo.png'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Logo = styled.div <span class="string">`</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  top: 0;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  width: 100px;</span></span><br><span class="line"><span class="string">  height: 56px;</span></span><br><span class="line"><span class="string">  background-image: url(<span class="subst">$&#123;logPic&#125;</span>);</span></span><br><span class="line"><span class="string">  background-size: contain;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码<code>logPic</code>是存放logo图片地址的变量，只需使用<code>${logPic}</code>的方式引入即可。如果是后台传过来的图片，如何使用的背景图呢？</p>
<h6 id="4-props"><a href="#4-props" class="headerlink" title="4. props"></a>4. props</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面提到的问题，可使用组件的传值。先看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">recommendList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">RecommendItem</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> <span class="attr">imgUrl</span>=<span class="string">&#123;item&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RecommendItem = styled.div <span class="string">`</span></span><br><span class="line"><span class="string">  width: 280px;</span></span><br><span class="line"><span class="string">  height: 50px;</span></span><br><span class="line"><span class="string">  background-image: url(<span class="subst">$&#123;(props) =&gt; props.imgUrl&#125;</span>);</span></span><br><span class="line"><span class="string">  background-size: contain;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子，不难发现，父组件传入的值，会存放在子组件的props中，故操作props便能得到预期效果。</p>
<h6 id="5-标签属性"><a href="#5-标签属性" class="headerlink" title="5. 标签属性"></a>5. 标签属性</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用style-components，需要使用标签属性，如input 的placeholder，a标签的href等，style-components提供了属性<code>attrs</code>，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NavSearch = styled.input.attrs(&#123;</span><br><span class="line">    placeholder: <span class="string">'搜索'</span>，</span><br><span class="line">    type: <span class="string">'text'</span></span><br><span class="line">&#125;) <span class="string">`</span></span><br><span class="line"><span class="string">  width: 160px;</span></span><br><span class="line"><span class="string">  height: 38px;</span></span><br><span class="line"><span class="string">  margin-top: 9px;</span></span><br><span class="line"><span class="string">  padding: 0 40px 0 20px;</span></span><br><span class="line"><span class="string">  box-sizing: border-box;</span></span><br><span class="line"><span class="string">  background-color: #eee;</span></span><br><span class="line"><span class="string">  outline: none;</span></span><br><span class="line"><span class="string">  border: none;</span></span><br><span class="line"><span class="string">  border-radius: 19px;</span></span><br><span class="line"><span class="string">  color: #666;</span></span><br><span class="line"><span class="string">  &amp;::placeholder &#123;</span></span><br><span class="line"><span class="string">    color: #999;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &amp;.focused &#123;</span></span><br><span class="line"><span class="string">    width: 240px;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，<code>attrs</code>里面是一个对象，如果需要多个属性，以对象的形式添加即可。</p>
<h6 id="6-塑造组件"><a href="#6-塑造组件" class="headerlink" title="6. 塑造组件"></a>6. 塑造组件</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种情况，一些原本就已经是组件，需要给这些组件添加样式，这时需要用到塑造组件，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123;className , children&#125;</span>) =&gt;</span> (</span><br><span class="line">    &lt;a className=&#123;className&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const StyledLink = styled(Link)`</span></span><br><span class="line"><span class="regexp">    color: palevioletred;</span></span><br><span class="line"><span class="regexp">`</span></span><br><span class="line"><span class="regexp">render(</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link&gt;普通组件&lt;/</span>Link&gt;</span><br><span class="line">        &lt;StyledLink&gt;添加了样式的组件&lt;<span class="regexp">/StyledLink&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h6 id="7-继承"><a href="#7-继承" class="headerlink" title="7. 继承"></a>7. 继承</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某一组件的样式会用到多个地方，不能每个地方都重新写一套样式，这样代码不够优雅。比如：一个button，有warning、有default、有primary等，这个button只是颜色不同，其他样式一样，这里便可用到继承。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">        line-height: 1.499;</span></span><br><span class="line"><span class="string">        display: inline-block;</span></span><br><span class="line"><span class="string">        font-weight: 400;</span></span><br><span class="line"><span class="string">        text-align: center;</span></span><br><span class="line"><span class="string">        -ms-touch-action: manipulation;</span></span><br><span class="line"><span class="string">        touch-action: manipulation;</span></span><br><span class="line"><span class="string">        cursor: pointer;</span></span><br><span class="line"><span class="string">        background-image: none;</span></span><br><span class="line"><span class="string">        border: 1px solid transparent;</span></span><br><span class="line"><span class="string">        white-space: nowrap;</span></span><br><span class="line"><span class="string">        padding: 0 15px;</span></span><br><span class="line"><span class="string">        font-size: 14px;</span></span><br><span class="line"><span class="string">        border-radius: 4px;</span></span><br><span class="line"><span class="string">        height: 32px;</span></span><br><span class="line"><span class="string">        -webkit-user-select: none;</span></span><br><span class="line"><span class="string">        -moz-user-select: none;</span></span><br><span class="line"><span class="string">        -ms-user-select: none;</span></span><br><span class="line"><span class="string">        user-select: none;</span></span><br><span class="line"><span class="string">        -webkit-transition: all .3s cubic-bezier(.645,.045,.355,1);</span></span><br><span class="line"><span class="string">        transition: all .3s cubic-bezier(.645,.045,.355,1);</span></span><br><span class="line"><span class="string">        position: relative;</span></span><br><span class="line"><span class="string">        -webkit-box-shadow: 0 2px 0 rgba(0,0,0,.015);</span></span><br><span class="line"><span class="string">        box-shadow: 0 2px 0 rgba(0,0,0,.015);</span></span><br><span class="line"><span class="string">        color: rgba(0,0,0,.65);</span></span><br><span class="line"><span class="string">        background-color: #fff;</span></span><br><span class="line"><span class="string">        border-color: #d9d9d9;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="keyword">const</span> ButtonPrimary = styled(Button)<span class="string">`</span></span><br><span class="line"><span class="string">        color: #fff;</span></span><br><span class="line"><span class="string">        background-color: #1890ff;</span></span><br><span class="line"><span class="string">        border-color: #1890ff;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="keyword">const</span> ButtonWarning = styled(Button)<span class="string">`</span></span><br><span class="line"><span class="string">        color: #f5222d;</span></span><br><span class="line"><span class="string">        background-color: #f5f5f5;</span></span><br><span class="line"><span class="string">        border-color: #d9d9d9;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">有人说，公用样式的组件完全可以写到全部样式里面，设置不同的class。这样做可行，但是为什么不直接去写css呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">###### 8. 动画</span></span><br><span class="line"><span class="string">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官网上有这样一个例子，如下：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">const</span> rotate = keyframes<span class="string">`</span></span><br><span class="line"><span class="string">      from &#123;</span></span><br><span class="line"><span class="string">        transform: rotate(0deg);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      to &#123;</span></span><br><span class="line"><span class="string">        transform: rotate(360deg);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Rotate = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">      display: inline-block;</span></span><br><span class="line"><span class="string">      animation: <span class="subst">$&#123;rotate&#125;</span> 2s linear infinite;</span></span><br><span class="line"><span class="string">      padding: 2rem 1rem;</span></span><br><span class="line"><span class="string">      font-size: 1.2rem;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    render(</span><br><span class="line">        &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;<span class="regexp">/Rotate&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br></pre></td></tr></table></figure></p>
<p>个人觉得，如果是简单的动画，直接以这样的方式去做，即可，如果动画比较复杂，建议使用react-transition-group框架有更好的体验。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;style-components的常用用法介绍完成，当然官网上还有一些其他的用法，有兴趣可以了解下。使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度，期待下一版能解决这个问题。</p>
]]></content>
      <categories>
        <category>style-components</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>reduxjs/toolkit黑魔法</title>
    <url>/2021/01/05/redux/reduxjs-toolkit%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>年中，公司启动新项目，需要搭建微前端架构，经过多番调研，确定了<code>乾坤、umi、dva</code>的技术方案，开始一个月就遇到了大的难题。第一，dva是约定式，不能灵活的配置；第二，乾坤并不能完全满足业务需求，需要更改很多源码，比如主子通信，兄弟通信等。经过一番取舍，放弃了这个方案。后基于single-spa，搭建一套微前端架构，同时通过命令生成模板，类似create-react-app，使用技术栈react、redux。<br>之前习惯了dva的操作方法，使用redux比较繁琐，因新项目比较庞大，不建议使用mobx。调研了多种方案，最终选择redux作者Dan Abramov今年三月份出的工具库<a href="https://redux-toolkit.js.org/introduction/quick-start" target="_blank" rel="noopener">reduxjs/toolkit</a>（以下简称RTK）。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RTK旨在帮助解决关于Redux的三个问题：</p>
<ul>
<li>配置Redux存储太复杂；</li>
<li>必须添加很多包才能让Redux做预期的事情；</li>
<li>Redux需要太多样板代码；</li>
</ul>
<p>简单讲配置Redux存储的流程太复杂，完整需要actionTypes、actions、reducer、store、通过connect连接。使用<code>RTK</code>，只需一个reducer即可，前提是组件必须是hooks的方式。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>configureStore</li>
<li>createAction</li>
<li>createReducer</li>
<li>createSlice</li>
<li>createAsyncThunk</li>
<li>createEntityAdapter</li>
<li>部分难点代码的unit test</li>
</ol>
<h3 id="configureStore"><a href="#configureStore" class="headerlink" title="configureStore"></a>configureStore</h3><p>configureStore是对标准的Redux的createStore函数的抽象封装，添加了默认值，方便用户获得更好的开发体验。<br>传统的Redux，需要配置reducer、middleware、devTools、enhancers等，使用configureStore直接封装了这些默认值。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">'reduxjs/toolkit'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个store已经集成了redux-thunk和Redux DevTools</span></span><br><span class="line"><span class="keyword">const</span> store = configureStore(&#123; <span class="attr">reducer</span>: rootReducer &#125;)</span><br></pre></td></tr></table></figure>
<p>相较于原生的Redux简化了很多，具体的Redux配置方法就不在这儿赘述了。</p>
<h3 id="createAction、createReducer"><a href="#createAction、createReducer" class="headerlink" title="createAction、createReducer"></a>createAction、createReducer</h3><p>createAction语法： function createAction(type, prepareAction?)</p>
<ol>
<li>type：Redux中的actionTypes</li>
<li>prepareAction：Redux中的actions<br>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> INCREMENT = <span class="string">'counter/increment'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">amount: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: INCREMENT,</span><br><span class="line">    payload: amount,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> action = increment(<span class="number">3</span>) <span class="comment">// &#123; type: 'counter/increment', payload: 3 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>createReducer简化了Redux reducer函数创建程序，在内部集成了<a href="https://github.com/immerjs/immer" target="_blank" rel="noopener">immer</a>,通过在reducer中编写<code>可变</code>代码，简化了不可变的更新逻辑，并支持特定的操作类型直接映射到case reducer函数，这些操作将调度更新状态。<br>不同于Redux reducer使用switch case的方式，<code>createReducer</code>简化了这种方式，它支持两种不同的形式：</p>
<ol>
<li>builder callback</li>
<li>map object</li>
</ol>
<p>第一种方式如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction, createReducer &#125; <span class="keyword">from</span> <span class="string">'reduxjs/toolkit'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建actions</span></span><br><span class="line"><span class="keyword">const</span> increment = createAction(<span class="string">'counter/increment'</span>)</span><br><span class="line"><span class="keyword">const</span> decrement = createAction(<span class="string">'counter/decrement'</span>)</span><br><span class="line"><span class="keyword">const</span> incrementByAmount = createAction&lt;number&gt;(<span class="string">'counter/incrementByAmount'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState: CounterState = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建reducer</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = createReducer(initialState, (builder) =&gt; &#123;</span><br><span class="line">  builder</span><br><span class="line">    .addCase(increment, (state, action) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 使用了immer， 所以不需要使用原来的方式: return &#123;...state, value: state.value + 1&#125;</span></span><br><span class="line">      state.value++</span><br><span class="line">    &#125;)</span><br><span class="line">    .addCase(decrement, (state, action) =&gt; &#123;</span><br><span class="line">      state.value--</span><br><span class="line">    &#125;)</span><br><span class="line">    .addCase(incrementByAmount, (state, action) =&gt; &#123;</span><br><span class="line">      state.value += action.payload</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>看起来比Redux的actions和reducer要好一些，这儿先不讲第二种方式<code>map object</code>，后面讲到createSlice和createAsyncThunk结合使用时再讲解。</p>
<p>Builder提供了三个方法</p>
<ol>
<li>addCase： 根据action添加一个reducer case的操作。</li>
<li>addMatcher： 在调用actions前，使用matcher function过滤</li>
<li>addDefaultCase： 默认值，等价于switch的default case;</li>
</ol>
<h3 id="createSlice"><a href="#createSlice" class="headerlink" title="createSlice"></a>createSlice</h3><p>createSlice对actions、Reducer的一个封装，咋一看比较像dva的方式，是一个函数，接收initial state、reducer、action creator和action types，这是使用RTK的标准写法，它内部使用了createAction和createReducer，并集成了immer，完成写法如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initial state</span></span><br><span class="line"><span class="keyword">const</span> initialState: InitialStateTypes = &#123;</span><br><span class="line">  loading: <span class="literal">false</span>,</span><br><span class="line">  visible: <span class="literal">false</span>,</span><br><span class="line">  isEditMode: <span class="literal">false</span>,</span><br><span class="line">  formValue: &#123;&#125;,</span><br><span class="line">  customerList: [],</span><br><span class="line">  fetchParams: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个slice</span></span><br><span class="line"><span class="keyword">const</span> customerSlice = createSlice(&#123;</span><br><span class="line">  name: namespaces, <span class="comment">// 命名空间</span></span><br><span class="line">  initialState, <span class="comment">// 初始值</span></span><br><span class="line">  <span class="comment">// reducers中每一个方法都是action和reducer的结合，并集成了immer</span></span><br><span class="line">  reducers: &#123;</span><br><span class="line">    changeLoading: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;boolean&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      state.loading = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeCustomerModel: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;IndexProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; isOpen, value &#125; = action.payload;</span><br><span class="line">      state.visible = isOpen;</span><br><span class="line">      <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        state.isEditMode = <span class="literal">true</span>;</span><br><span class="line">        state.formValue = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.isEditMode = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 额外的reducer，处理异步action的reducer</span></span><br><span class="line">  extraReducers: <span class="function">(<span class="params">builder: ActionReducerMapBuilder&lt;InitialStateTypes&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    builder.addCase(fetchCustomer.fulfilled, (state: InitialStateTypes, &#123; payload &#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; content, pageInfo &#125; = payload;</span><br><span class="line">      state.customerList = content;</span><br><span class="line">      state.fetchParams.pageInfo = pageInfo;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>页面传值取值方式，前提必须是hooks的方式，class方式不支持：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  fetchCustomer,</span><br><span class="line">  changeCustomerModel,</span><br><span class="line">  saveCustomer,</span><br><span class="line">  delCustomer,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'root/store/reducer/customer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="comment">// 取值</span></span><br><span class="line">  <span class="keyword">const</span> &#123; loading, visible, isEditMode, formValue, customerList, fetchParams &#125; = useSelector(</span><br><span class="line">    (state: ReducerTypes) =&gt; state.customer,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dispatch</span></span><br><span class="line">    dispatch(fetchCustomer(fetchParams));</span><br><span class="line">  &#125;, [dispatch, fetchParams]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>少了connect的连接，代码优雅不少。</p>
<h3 id="createAsyncThunk"><a href="#createAsyncThunk" class="headerlink" title="createAsyncThunk"></a>createAsyncThunk</h3><p>这儿讲RTK本身集成的thunk，想使用redux-saga的自己配置，方式相同。<br>createAsyncThunk接受Redux action type字符串，返回一个promise callback。它根据传入的操作类型前缀生成Promise的操作类型生命周期，并返回一个thunk action creator。它不跟踪状态或如何处理返回函数，这些操作应该放在reducer中处理。<br>用法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchCustomer = createAsyncThunk(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;namespaces&#125;</span>/fetchCustomer`</span>,</span><br><span class="line">  <span class="keyword">async</span> (params: ParamsTypes, &#123; dispatch &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; changeLoading &#125; = customerSlice.actions;</span><br><span class="line">    dispatch(changeLoading(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> server.fetchCustomer(params);</span><br><span class="line">    dispatch(changeLoading(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      message.error(res.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>createAsyncThunk可接受三个参数</p>
<ol>
<li>typePrefix： action types</li>
<li>payloadCreator： { dispatch, getState, extra, requestId …}, 平常开发只需要了解dispatch和getState就够了，注：这儿的getState能拿到整个store里面的state</li>
<li>options: 可选，{ condition, dispatchConditionRejection}， condition：可在payload创建成功之前取消执行，return false表示取消执行。</li>
</ol>
<p>讲createReducer时，有两种表示方法，一种是<code>builder callback</code>,即build.addCase(),一种是<code>map object</code>。下面以这种方式讲解。<br>createAsyncThunk创建成功后，return出去的值，会在extraReducers中接收，有三种状态：</p>
<ol>
<li>pending: ‘fetchCustomer/requestStatus/pending’，运行中；</li>
<li>fulfilled: ‘fetchCustomer/requestStatus/fulfilled’，完成；</li>
<li>rejected: ‘fetchCustomer/requestStatus/rejected’，拒绝；<br>代码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> customerSlice = createSlice(&#123;</span><br><span class="line">  name: namespaces, <span class="comment">// 命名空间</span></span><br><span class="line">  initialState, <span class="comment">// 初始值</span></span><br><span class="line">  <span class="comment">// reducers中每一个方法都是action和reducer的结合，并集成了immer</span></span><br><span class="line">  reducers: &#123;</span><br><span class="line">    changeLoading: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;boolean&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      state.loading = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    changeCustomerModel: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;IndexProps&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; isOpen, value &#125; = action.payload;</span><br><span class="line">      state.visible = isOpen;</span><br><span class="line">      <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        state.isEditMode = <span class="literal">true</span>;</span><br><span class="line">        state.formValue = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.isEditMode = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 额外的reducer，处理异步action的reducer</span></span><br><span class="line">  extraReducers: &#123;</span><br><span class="line">    <span class="comment">// padding</span></span><br><span class="line">    [fetchCustomer.padding]: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;IndexProps&gt;</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// fulfilled</span></span><br><span class="line">    [fetchCustomer.fulfilled]: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;IndexProps&gt;</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// rejected</span></span><br><span class="line">    [fetchCustomer.rejected]: <span class="function">(<span class="params">state: InitialStateTypes, action: PayloadAction&lt;IndexProps&gt;</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对应的builder.addCase的方式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">extraReducers: <span class="function">(<span class="params">builder: ActionReducerMapBuilder&lt;InitialStateTypes&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">  builder.addCase(fetchCustomer.padding, (state: InitialStateTypes, &#123; payload &#125;) =&gt; &#123;&#125;);</span><br><span class="line">  builder.addCase(fetchCustomer.fulfilled, (state: InitialStateTypes, &#123; payload &#125;) =&gt; &#123;&#125;);</span><br><span class="line">  builder.addCase(fetchCustomer.rejected, (state: InitialStateTypes, &#123; payload &#125;) =&gt; &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="createEntityAdapter"><a href="#createEntityAdapter" class="headerlink" title="createEntityAdapter"></a>createEntityAdapter</h3><p>字面意思是<code>创建实体适配器</code>，目的为了生成一组预建的缩减器和选择器函数，对包含特定类型的对象进行CRUD操作，可以作为case reducers 传递给createReducer和createSlice，也可以作为辅助函数。createEntityAdapter是根据<a href="https://ngrx.io/guide/entity" target="_blank" rel="noopener">ngrx/entity</a>移植过来进行大量修改。其作用就是实现<a href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" target="_blank" rel="noopener">state范式化</a>的思想。<br><code>Entity</code>用于表示数据对象的唯一性，一般以id作为key值。<br>由createEntityAdapter方法生成的<code>entity state</code>结构如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 每个对象唯一的id，必须是string或number</span></span><br><span class="line">  ids: []</span><br><span class="line">  <span class="comment">// 范式化的对象，实体id映射到相应实体对象的查找表，即key为id,value为id所在对象的值，</span></span><br><span class="line">  entities: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个createEntityAdapter：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> booksAdapter = createEntityAdapter&lt;Book&gt;(&#123;</span><br><span class="line">  selectId: <span class="function">(<span class="params">book</span>) =&gt;</span> book.bookId,</span><br><span class="line">  sortComparer: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.title.localeCompare(b.title),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bookSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">'books'</span>,</span><br><span class="line">  initialState: booksAdapter.getInitialState(),</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="comment">// 添加一个book实体</span></span><br><span class="line">    bookAdd: booksAdapter.addOne,</span><br><span class="line">    <span class="comment">// 接受所有books实体</span></span><br><span class="line">    booksReceived(state, action) &#123;</span><br><span class="line">      booksAdapter.setAll(state, action.payload.books);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; bookAdd, booksReceived &#125; = bookSlice.actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bookSlice.reducer;</span><br></pre></td></tr></table></figure></p>
<p>组件中取值：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"><span class="keyword">const</span> entityAdapter = useSelector(<span class="function">(<span class="params">state: ReducerTypes</span>) =&gt;</span> state);</span><br><span class="line"><span class="keyword">const</span> books = booksAdapter.getSelectors(<span class="function">(<span class="params">state: ReducerTypes</span>) =&gt;</span> state.entityAdapter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(entityAdapter);</span><br><span class="line"><span class="comment">// &#123; ids: ['a001', 'a002'], entities: &#123; a001: &#123; bookId: 'a001', title: 'book1' &#125;, a002: &#123; bookId: 'a002', title: 'book2' &#125; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(books.selectById(entityAdapter, <span class="string">'a001'</span>));</span><br><span class="line"><span class="comment">// &#123; bookId: 'a001', title: 'book1' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(books.selectIds(entityAdapter));</span><br><span class="line"><span class="comment">// ['a001', 'a002']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(books.selectAll(entityAdapter));</span><br><span class="line"><span class="comment">// [&#123; bookId: 'a001', title: 'book1' &#125;, &#123; bookId: 'a002', title: 'book2' &#125;]</span></span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(bookAdd(&#123; <span class="attr">bookId</span>: <span class="string">'a001'</span>, <span class="attr">title</span>: <span class="string">'book1'</span> &#125;));</span><br><span class="line">  dispatch(bookAdd(&#123; <span class="attr">bookId</span>: <span class="string">'a002'</span>, <span class="attr">title</span>: <span class="string">'book2'</span> &#125;));</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></p>
<p>从提供的方法中，可以获取到原始的数组值，范式化后的key-value方式，可以获取以存储key的数组ids，就是state范式化。</p>
<h3 id="unit-test"><a href="#unit-test" class="headerlink" title="unit test"></a>unit test</h3><p>公共部分：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = jest.fn();</span><br><span class="line"><span class="keyword">const</span> getState = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  dispatch: jest.fn(),</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">const</span> condition = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>reducers中方法，actions单元测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = changeCustomerModel(&#123;</span><br><span class="line">      isOpen: <span class="literal">true</span>,</span><br><span class="line">      value,</span><br><span class="line">    &#125;);</span><br><span class="line">    expect(action.payload).toEqual(&#123;</span><br><span class="line">      isOpen: <span class="literal">true</span>,</span><br><span class="line">      value,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>thunk actions(createAsyncThunk)单元测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockData = &#123;</span><br><span class="line">  status: <span class="number">0</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    content: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="string">'001'</span>,</span><br><span class="line">        code: <span class="string">'table001'</span>,</span><br><span class="line">        name: <span class="string">'张三'</span>,</span><br><span class="line">        phoneNumber: <span class="string">'15928797333'</span>,</span><br><span class="line">        address: <span class="string">'成都市天府新区'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// server.fetchCustomer方法mock数据</span></span><br><span class="line">server.fetchCustomer.mockResolvedValue(mockData);</span><br><span class="line"><span class="comment">// 执行thunk action异步方法</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> fetchCustomer(params)(dispatch, getState, &#123; condition &#125;);</span><br><span class="line"><span class="comment">// 请求接口数据,断言是否是mock的数据</span></span><br><span class="line">expect(<span class="keyword">await</span> server.fetchCustomer(params)).toEqual(mockData);</span><br><span class="line"><span class="comment">// dispatch设置loading状态为true</span></span><br><span class="line">dispatch(changeLoading(<span class="literal">true</span>));</span><br><span class="line"><span class="comment">// 断言thunk action执行成功</span></span><br><span class="line">expect(fetchCustomer.fulfilled.match(result)).toBe(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行extraReducers的fetchCustomer.fulfilled</span></span><br><span class="line">customerReducer(</span><br><span class="line">  initState,</span><br><span class="line">  fetchCustomer.fulfilled(</span><br><span class="line">    &#123;</span><br><span class="line">      payload: &#123;</span><br><span class="line">        content: [value],</span><br><span class="line">        pageInfo: initState.fetchParams.pageInfo,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    initState.fetchParams,</span><br><span class="line">  ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言第一次dispatch设置loading为true</span></span><br><span class="line">expect(dispatch.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toEqual(&#123;</span><br><span class="line">  payload: <span class="literal">true</span>,</span><br><span class="line">  type: <span class="string">'customer/changeLoading'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求成功，第二次dispatch设置loading为false</span></span><br><span class="line">expect(dispatch.mock.calls[<span class="number">2</span>][<span class="number">0</span>]).toEqual(&#123;</span><br><span class="line">  payload: <span class="literal">false</span>,</span><br><span class="line">  type: <span class="string">'customer/changeLoading'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// thunk action return 到extraReducers的值</span></span><br><span class="line">expect(dispatch.mock.calls[<span class="number">3</span>][<span class="number">0</span>].payload).toEqual(mockData.data);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>写的有点凌乱，就是当做笔记来记录的，有写的不对的地方不吝赐教。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://redux-toolkit.js.org/introduction/quick-start" target="_blank" rel="noopener">https://redux-toolkit.js.org/introduction/quick-start</a></li>
<li><a href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" target="_blank" rel="noopener">https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape</a></li>
</ol>
]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于qiankun的微前端</title>
    <url>/2021/09/29/%E5%BE%AE%E5%89%8D%E7%AB%AF/%E5%9F%BA%E4%BA%8Eqiankun%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>公司的 erp 项目已经很多年，为了方便维护和迭代，同时能保证不能模块之间能独立部署，独立运行，经过一番调研，决定使用微前端的思想将代码拆分。最开始使用 webpack5 的<code>Module Federation</code>进行拆分，能保证每个模块独立部署，独立发布，每个子应用的 CI/CD 已经跑通，发布到开发环境也没问题。但是<code>Module Federation</code>不同技术会有一定限制，有些极端情况没办法处理，同时 js 沙箱和 css 沙箱也是一定的问题，故决定使用<code>qiankun</code>进行拆分。</p>
<p>本教程使用<code>Vue</code>作为主应用的基座，接入不同技术栈的子应用，同时会拿一个模块来讲解通信相关内容。</p>
<p><img src="/images/微前端/qiankun/main.jpg" alt="微前端"></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里使用 vue 作为基座，因此首先需要创建 vue 教授架，使用<a href="https://cli.vuejs.org/zh/guide/prototyping.html" target="_blank" rel="noopener">vue-cli</a>创建，命令如下：</p>
<ol>
<li>安装 vue 脚手架</li>
</ol>
<p>安装</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">global</span> <span class="keyword">add</span> <span class="title">@vue</span>/cli</span><br></pre></td></tr></table></figure>
<p>检查版本是否正确</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">vue <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<p>创建项目</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vue create hello-world</span></span><br></pre></td></tr></table></figure>
<p>安装 qiankun</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> qiankun</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装 react 脚手架</li>
</ol>
<p>这儿使用<a href="https://create-react-app.dev/docs/getting-started" target="_blank" rel="noopener">create-react-app</a>作为 react 脚手架生成工具，具体操作如下：</p>
<p>安装</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npx </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">yarn </span><span class="string">eject</span></span><br><span class="line"><span class="string">yarn </span><span class="string">start</span></span><br></pre></td></tr></table></figure>
<h3 id="ERP-前端架构设计"><a href="#ERP-前端架构设计" class="headerlink" title="ERP 前端架构设计"></a>ERP 前端架构设计</h3><p>erp 前端架构设计如下：</p>
<blockquote>
<ol>
<li>主应用（基座）：用于注册子应用的容器，使用 vue 作为主应用，包括：登录、注销、修改密码、Layout、动态路由、公共 State 等；</li>
<li>子应用（若干）：可使用任何技术栈；</li>
<li>公共模块: 两种方式（mf 或 npm 包）<br>3.1. Module Federation: 公共组件、指令、字典、工具方法存放于主应用，通过 mf shared 出去（推荐）；<br>3.2. npm 包：将公共组件、指令、工具方法封装成 npm 包，更新版本所有应用都需要更新，稍微麻烦；</li>
</ol>
</blockquote>
<p>详细的设计如下图所示：</p>
<p><img src="/images/微前端/qiankun/erp-frontend-desigin.png" alt="ERP Design"></p>
<h3 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h3><p>erp 项目的路由分为主路由和子路由，主路由主要是登录、home 页、修改密码，子路由是各个模块自己的路由模块，具体如下</p>
<p>主路由</p>
<blockquote>
<ol>
<li>所有页面访问，都需要经过全局路由守卫，这时需判断该用户是否登录，如果没登录，跳转回登录页面；</li>
<li>登录页登录后拿到菜单权限，根据已经配置的所有模块的路由进行过滤，配置动态路由；</li>
<li>然后判断是否是启动页，如果不是跳转到 home 页， 如果是走当前启动页的子应用路由</li>
</ol>
</blockquote>
<p>子路由</p>
<blockquote>
<ol>
<li>子应用拿到主应用返回的菜单权限，配置动态路由</li>
<li>当主应用确定启动项后，会到当前启动项的子应用去找匹配的路由</li>
</ol>
</blockquote>
<p>通过上面的路由设计，即可完成主子应用的路由匹配情况，具体如下图所示</p>
<p><img src="/images/微前端/qiankun/router_design.png" alt="ERP Design"></p>
<h3 id="搭建主应用基座"><a href="#搭建主应用基座" class="headerlink" title="搭建主应用基座"></a>搭建主应用基座</h3><p>创建好脚手架后，根据<code>qiankun</code>官网教程，改造主应用基座，首先需要在入口文件注册微应用信息，创建微应用容器，设置默认路由等，并启动</p>
<p>在主应用的入口文件<code>main.js</code>注册微应用信息，启动，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  main.js文件</span></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册微应用信息</span></span><br><span class="line">registerMicroApps(</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'sub-vue'</span>,</span><br><span class="line">      entry: <span class="string">'//localhost:7001'</span>,</span><br><span class="line">      container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">      activeRule: <span class="string">'/sub-vue'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        shared,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  &#123;</span><br><span class="line">    beforeLoad: [</span><br><span class="line">      (app) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before load %c%s'</span>, <span class="string">'color: green;'</span>, app.name)</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    beforeMount: [</span><br><span class="line">      (app) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before mount %c%s'</span>, <span class="string">'color: green;'</span>, app.name)</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    afterUnmount: [</span><br><span class="line">      (app) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] after unmount %c%s'</span>, <span class="string">'color: green;'</span>, app.name)</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认路由</span></span><br><span class="line">setDefaultMountApp(<span class="string">'/sub-vue'</span>)</span><br><span class="line"><span class="comment">// 启动，并开启严格沙箱模式</span></span><br><span class="line">start(&#123; <span class="attr">experimentalStyleIsolation</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...  App.vue 文件</span></span><br><span class="line"><span class="comment">// 设置子应用容器</span></span><br><span class="line">&lt;div id=<span class="string">"subapp-viewport"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>qiankun API 说明：</p>
<blockquote>
<ol>
<li>registerMicroApps(apps, lifeCycles?): 注册微应用的基础配置信息。当浏览器 url 发生变化时，会自动检查每一个微应用注册的 activeRule 规则，符合规则的应用将会被自动激活。<br>1.1. apps: 必选，微应用注册信息<br>2.2. lifeCycles: 声明周期</li>
<li>start(opts?): 启动 qiankun， opts: 可选</li>
<li>setDefaultMountApp(appLink): 设置主应用启动后默认进入的微应用</li>
<li>loadMicroApp(app, configuration?): 手动加载一个微应用</li>
<li>prefetchApps(apps, importEntryOpts?): 手动预加载指定的微应用静态资源</li>
<li>initGlobalState(state): 定义全局状态，并返回通信方法，建议在主应用使用，微应用通过 props 获取通信方法。</li>
<li>setGlobalState(state): 按一级属性设置全局状态，微应用中只能修改已存在的一级属性</li>
<li>onGlobalStateChange(callback: OnGlobalStateChangeCallback, fireImmediately?: boolean) =&gt; void: 监听状态的变化</li>
<li>offGlobalStateChange() =&gt; boolean: 移除当前应用的状态监听，微应用 umount 时会默认调用</li>
</ol>
</blockquote>
<p>这儿只简单列了部分 api，详情请移步<a href="https://qiankun.umijs.org/zh/api" target="_blank" rel="noopener">qiankun 官网</a></p>
<h3 id="搭建-vue-微应用"><a href="#搭建-vue-微应用" class="headerlink" title="搭建 vue 微应用"></a>搭建 vue 微应用</h3><p>使用 vue-cli 创建一个 vue 脚手架，安装好所需依赖</p>
<ol>
<li>在 vue.config.js 中配置如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// publicPath: '/subapp/sub-vue',</span></span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> config.resolve.symlinks(<span class="literal">false</span>),</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">      <span class="comment">// 把子应用打包成 umd 库格式</span></span><br><span class="line">      library: <span class="string">`<span class="subst">$&#123;name&#125;</span>-[name]`</span>,</span><br><span class="line">      libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">      jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">7001</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>webpack</code>中的<code>libraryTarget</code>设置为<code>umd</code>或者<code>window</code>，表示 library 下的所有模块暴露到了全局，主应用就可以通过微应用的生命周期钩子获取。devServer 中的 headers 必须设置跨域，不然主应用拿不到微应用信息。</p>
<ol start="2">
<li>在 src 下创建一个 public-path.js 文件，加上下面代码，并在 main.js 引入(必须在最开头引入)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public-path.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./public-path'</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>main.js 配置声明周期，如下</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./public-path'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./shared/actions'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 注入 actions 实例</span></span><br><span class="line">    actions.setActions(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; container &#125; = props</span><br><span class="line">  <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    base: <span class="built_in">window</span>.__POWERED_BY_QIANKUN__ ? <span class="string">'/sub-vue'</span> : <span class="string">'/'</span>,</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  instance = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">  &#125;).$mount(container ? container.querySelector(<span class="string">'#app'</span>) : <span class="string">'#app'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[vue] vue app bootstraped'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[vue] props from main framework'</span>, props)</span><br><span class="line"></span><br><span class="line">  props.onGlobalStateChange(<span class="function">(<span class="params">state, prev</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// state: 变更后的状态; prev 变更前的状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子应用监听的全局状态'</span>, state)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册子应用路由</span></span><br><span class="line">  props.setGlobalState(&#123; routes &#125;)</span><br><span class="line"></span><br><span class="line">  render(props)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  instance.$destroy()</span><br><span class="line">  instance.$el.innerHTML = <span class="string">''</span></span><br><span class="line">  instance = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>主应用注册新增的 vue 应用，入口 main.js 文件中</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">registerMicroApps(</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'sub-vue'</span>,</span><br><span class="line">      entry: <span class="string">'//localhost:7001'</span>,</span><br><span class="line">      container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">      activeRule: <span class="string">'/sub-vue'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        shared,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>
<p>到这里，<code>Vue</code> 微应用就配置好了，此时启动主子应用就可以在主应用中看到刚接入的子应用信息。</p>
<h3 id="搭建-React-微应用"><a href="#搭建-React-微应用" class="headerlink" title="搭建 React 微应用"></a>搭建 React 微应用</h3><p>按照上面的教程，使用<code>create-react-app</code>创建一个 react 脚手架，使用<code>yarn eject</code>命令暴露出 webpack 配置，然后进行下面的配置</p>
<ol>
<li>在<code>config/webpack.config.js</code>配置如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">      <span class="comment">// 把子应用打包成 umd 库格式</span></span><br><span class="line">      library: <span class="string">`<span class="subst">$&#123;name&#125;</span>-[name]`</span>,</span><br><span class="line">      libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">      jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;name&#125;</span>`</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在<code>config/webpackDevServer.config.js</code>文件中配置 headers 跨域，如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">headers: &#123;</span><br><span class="line">  <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在 src 下创建文件<code>public-path.js</code>文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将新创建的<code>public-path.js</code>文件,在入口文件<code>src/index.js</code>文件的最开头引入，并配置<code>qiankun</code>的生命周期，如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./public-path'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./shared/actions'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// 注入 actions 实例</span></span><br><span class="line">    actions.setActions(props)</span><br><span class="line">  &#125;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.StrictMode&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export async function bootstrap() &#123;</span></span><br><span class="line"><span class="regexp">  console.log('react app bootstraped')</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export async function mount(props) &#123;</span></span><br><span class="line"><span class="regexp">  console.log('reactApp mount', props)</span></span><br><span class="line"><span class="regexp">  render(props)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export async function unmount() &#123;</span></span><br><span class="line"><span class="regexp">  console.log('react unmount')</span></span><br><span class="line"><span class="regexp">  ReactDOM.unmountComponentAtNode(document.getElementById('root'))</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在主应用注册 react 应用即可，如下</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册微应用信息</span></span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'sub-vue'</span>,</span><br><span class="line">    entry: <span class="string">'//localhost:7001'</span>,</span><br><span class="line">    container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">    activeRule: <span class="string">'/sub-vue'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      shared,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'sub-react'</span>,</span><br><span class="line">    entry: <span class="string">'//localhost:7002'</span>,</span><br><span class="line">    container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">    activeRule: <span class="string">'/sub-react'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      shared,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>到此，React 微应用已经搭建完成，可以启动看效果了~</p>
<h3 id="主子通信管理"><a href="#主子通信管理" class="headerlink" title="主子通信管理"></a>主子通信管理</h3><p>对于主子应用的通信，qiankun 给出有 api，如下</p>
<blockquote>
<ol>
<li>initGlobalState(state): 定义全局状态，并返回通信方法，建议在主应用使用，微应用通过 props 获取通信方法。</li>
<li>setGlobalState(state): 按一级属性设置全局状态，微应用中只能修改已存在的一级属性</li>
<li>onGlobalStateChange(callback: OnGlobalStateChangeCallback, fireImmediately?: boolean) =&gt; void: 监听状态的变化</li>
<li>offGlobalStateChange() =&gt; boolean: 移除当前应用的状态监听，微应用 umount 时会默认调用</li>
</ol>
</blockquote>
<p>首先说一下对于简单的主子通信，使用 qiankun 给我 api 完全够了</p>
<ol>
<li>在主应用定义全局状态，如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initGlobalState &#125; <span class="keyword">from</span> <span class="string">'qiankun'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">routes</span>: [] &#125;</span><br><span class="line"><span class="keyword">const</span> actions = initGlobalState(initialState)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions</span><br></pre></td></tr></table></figure>
<p>初始化全局状态后，可使用上面定义的<code>actions.onGlobalStateChange</code>监听状态，实现原理就是<code>观察者模式</code>，具体操作如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions.onGlobalStateChange(<span class="function">(<span class="params">state, prev</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'新的状态：'</span>, state)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'上一次的状态：'</span>, state)</span><br><span class="line">  store.commit(<span class="string">'SET_ROUTES'</span>, state.routes)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>拿到状态值改变后，可将值存放到当前使用技术的状态管理里面，这儿使用的是 vuex</p>
<ol start="2">
<li>子应用拿到主应用的状态</li>
</ol>
<p>主应用在注册微应用时，通过 props 将全局状态传给子应用，子应用可以通过 props 拿到的的<code>actions</code>进行数据处理，也可通过<code>actions.setGlobalState</code>将子应用的数据返给主应用，如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[vue] props from main framework'</span>, props)</span><br><span class="line"></span><br><span class="line">  props.onGlobalStateChange(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// state: 变更后的状态; prev 变更前的状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子应用监听的全局状态'</span>, state)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册子应用路由</span></span><br><span class="line">  props.setGlobalState(&#123; routes &#125;)</span><br><span class="line"></span><br><span class="line">  render(props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当设置了全局状态的值后，所有监听了全局状态变化的地方都会返回最新的状态，这样就实现了主子通信，子子通信的情况。</p>
<p>对于复杂的状态管理，逻辑如下图所示</p>
<p><img src="/images/微前端/qiankun/store.png" alt="ERP Design"></p>
<p>到这里便使用 qiankun 实现了不同技术栈的整合。</p>
]]></content>
      <categories>
        <category>Micro Frontend</category>
      </categories>
      <tags>
        <tag>Micro Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>flex-骰子布局</title>
    <url>/2019/02/13/css/flex-%E9%AA%B0%E5%AD%90%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li><ol>
<li>概念</li>
</ol>
</li>
<li><ol start="2">
<li>flex容器的属性<ul>
<li>2.1.  flex-direction</li>
<li>2.2.  flex-wrap</li>
<li>2.3.  flex-flow</li>
<li>2.4.  justify-content</li>
<li>2.5.  align-items</li>
<li>2.6.  align-content</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>项目的属性<ul>
<li>3.1.  order</li>
<li>3.2. flex-grow</li>
<li>3.3. flex-shrink</li>
<li>3.4. flex-basis</li>
<li>3.5. flex</li>
<li>3.6. align-self</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>flex布局实践（骰子布局）</li>
</ol>
</li>
<li><ol start="5">
<li>总结</li>
</ol>
</li>
<li><ol start="6">
<li>源码</li>
</ol>
</li>
</ul>
<hr>
<hr>
<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex布局称为flex容器，flex容器默认两根轴：水平主轴和垂直交叉轴。以下概念都围绕水平主轴和垂直交叉轴而定义。<br><img src="/images/css/flex/1.png" alt="flex"></p>
<h3 id="二、flex容器的属性"><a href="#二、flex容器的属性" class="headerlink" title="二、flex容器的属性"></a>二、flex容器的属性</h3><p>以下6个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h6 id="1-flex-direction-决定主轴的方向"><a href="#1-flex-direction-决定主轴的方向" class="headerlink" title="1. flex-direction 决定主轴的方向"></a>1. flex-direction 决定主轴的方向</h6><blockquote>
<ul>
<li>row(默认值): 主轴水平方向，左端为起点</li>
<li>row-reverse: 主轴水平方向，右端为起点</li>
<li>column: 主轴垂直方向，上端为起点</li>
<li>column-reverse: 主轴垂直方向，下端为起点</li>
</ul>
</blockquote>
<h6 id="2-flex-wrap-项目是否排列在轴线上，是否换行属性"><a href="#2-flex-wrap-项目是否排列在轴线上，是否换行属性" class="headerlink" title="2. flex-wrap 项目是否排列在轴线上，是否换行属性"></a>2. flex-wrap 项目是否排列在轴线上，是否换行属性</h6><blockquote>
<ul>
<li>nowrap(默认值): 不换行</li>
<li>wrap: 换行，第一行在上方</li>
<li>wrap-reverse: 换行，第一行在下方</li>
</ul>
</blockquote>
<h6 id="3-flex-flow-flex-direction和flex-wrap的简写"><a href="#3-flex-flow-flex-direction和flex-wrap的简写" class="headerlink" title="3. flex-flow:  flex-direction和flex-wrap的简写"></a>3. flex-flow:<flex-direction> <flex-wrap> flex-direction和flex-wrap的简写</flex-wrap></flex-direction></h6><h6 id="4-justify-content-定义主轴上的对其方式"><a href="#4-justify-content-定义主轴上的对其方式" class="headerlink" title="4. justify-content 定义主轴上的对其方式"></a>4. justify-content 定义主轴上的对其方式</h6><blockquote>
<ul>
<li>flex-start(默认值): 左对齐</li>
<li>flex-end: 右对齐</li>
<li>center: 居中</li>
<li>space-between: 两端对其，项目间间距相等</li>
<li>space-around: 每个项目两端的间距相等</li>
</ul>
</blockquote>
<h6 id="5-align-items-项目在交叉线上的对齐方式"><a href="#5-align-items-项目在交叉线上的对齐方式" class="headerlink" title="5. align-items 项目在交叉线上的对齐方式"></a>5. align-items 项目在交叉线上的对齐方式</h6><blockquote>
<ul>
<li>flex-start: 交叉线的起点对齐</li>
<li>flex-end: 交叉线的终点对齐</li>
<li>center: 交叉线的中心对齐</li>
<li>baseline: 项目第一行文字的基线对齐</li>
<li>stretch(默认值): 如果项目未设置高度或auto,将占满容器的高度</li>
</ul>
</blockquote>
<h6 id="6-align-content-多行对其，如果只有一行，不起作用"><a href="#6-align-content-多行对其，如果只有一行，不起作用" class="headerlink" title="6. align-content 多行对其，如果只有一行，不起作用"></a>6. align-content 多行对其，如果只有一行，不起作用</h6><blockquote>
<p>flex-start: 与交叉点的起点对齐</p>
<ul>
<li>flex-end: 与交叉点的终点对齐</li>
<li>center: 与交叉点的中心对齐</li>
<li>space-between: 与交叉线两端对齐，轴线间间隔平均分配</li>
<li>space-around: 每根轴线间隔相等</li>
<li>stretch: 轴线占满整个交叉线</li>
</ul>
</blockquote>
<h3 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h3><p>以下6个属性设置在项目上。</p>
<blockquote>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
</blockquote>
<h6 id="1-order定义项目的排列顺序，值越小越靠前，默认为0"><a href="#1-order定义项目的排列顺序，值越小越靠前，默认为0" class="headerlink" title="1. order定义项目的排列顺序，值越小越靠前，默认为0"></a>1. <code>order</code>定义项目的排列顺序，值越小越靠前，默认为0</h6><blockquote>
<p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;order: <integer>;<br>}</integer></p>
</blockquote>
<h6 id="2-flex-grow定义项目的放大比例，默认为0"><a href="#2-flex-grow定义项目的放大比例，默认为0" class="headerlink" title="2. flex-grow定义项目的放大比例，默认为0"></a>2. <code>flex-grow</code>定义项目的放大比例，默认为0</h6><blockquote>
<p>.item {<br> &nbsp;&nbsp;&nbsp;&nbsp; flex-grow: <number>;<br>}</number></p>
</blockquote>
<p>如果flex-grow为1，则项目等分，如果有一个为2，其他为1，则该项目是其他项目的两倍。</p>
<h6 id="3-flex-shrink定义项目的缩小比例，默认值为1。"><a href="#3-flex-shrink定义项目的缩小比例，默认值为1。" class="headerlink" title="3. flex-shrink定义项目的缩小比例，默认值为1。"></a>3. <code>flex-shrink</code>定义项目的缩小比例，默认值为1。</h6><blockquote>
<p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex-shrink: <number>;<br>}</number></p>
</blockquote>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效</p>
<h6 id="4-flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。"><a href="#4-flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。" class="headerlink" title="4. flex-basis定义在分配空间之前，项目占主轴空间，默认值为auto。"></a>4. <code>flex-basis</code>定义在分配空间之前，项目占主轴空间，默认值为auto。</h6><blockquote>
<p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex-basis: <length> | auto;<br>}</length></p>
</blockquote>
<p>它可以设为跟width或height属性一样的值（比如250px），则项目将占据固定空间。</p>
<h6 id="5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。"><a href="#5-flex属性是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。" class="headerlink" title="5. flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。"></a>5. <code>flex</code>属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h6><blockquote>
<p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>}</p>
</blockquote>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。习惯使用这个属性。</p>
<h6 id="6-align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性-默认值为auto。"><a href="#6-align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性-默认值为auto。" class="headerlink" title="6. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。"></a>6. <code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性, 默认值为auto。</h6><blockquote>
<p>.item {<br>  &nbsp;&nbsp;&nbsp;&nbsp;align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>}</p>
</blockquote>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h3 id="四、flex布局实践（骰子布局）"><a href="#四、flex布局实践（骰子布局）" class="headerlink" title="四、flex布局实践（骰子布局）"></a>四、flex布局实践（骰子布局）</h3><p>假设骰子的一面最多可以放9个点。<br><img src="/images/css/flex/2.png" alt="point"></p>
<p>下面来说如何使用flex布局骰子，html默认为</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>.box元素代表flex容器，.item元素代表一个项目，需要几个项目就有几个class为item的div元素。</p>
<h6 id="1-单项目"><a href="#1-单项目" class="headerlink" title="1. 单项目"></a>1. 单项目</h6><p>1.1 首先左上角一个点，默认情况即可。<br><img src="/images/css/flex/3.png" alt="flex"></p>
<pre><code>.box {
    width: 60px;
    height: 60px;
    border: 1px solid white;
    background: white;
    border-radius: 5px;
    display: flex;
    margin: 10px;
}
</code></pre><p>.box的样式为以上，下面所有都依据这个来的。</p>
<p>1.2  黑点在第一行居中对齐，使用justify-content: center即可。<br><img src="/images/css/flex/4.png" alt="flex"></p>
<pre><code>.box.one1 {
    flex-direction: row;   /* 默认值可以不写*/
    justify-content: center;
}
</code></pre><p>1.3  黑点在第一行右对齐，使用justify-content: flex-end。<br><img src="/images/css/flex/5.png" alt="flex"></p>
<pre><code>.box.one2 {
    justify-content: flex-end;
}
</code></pre><p>1.4 黑点在第二行第一个，转化为垂直交叉线排列方式，居中即可。<br><img src="/images/css/flex/6.png" alt="flex"></p>
<pre><code>.box.one3 {
    align-items: center;
}
</code></pre><p>1.5 黑点垂直水平居中<br><img src="/images/css/flex/7.png" alt="flex"></p>
<pre><code>.box.one4 {
    align-items: center;
    justify-content: center;
}
</code></pre><p>1.6  黑点在第二行右侧<br><img src="/images/css/flex/8.png" alt="flex"></p>
<pre><code>.box.one5 {
    align-items: center;
    justify-content: flex-end;
}
</code></pre><p>1.7 黑点在最后一行第一个<br><img src="/images/css/flex/9.png" alt="flex"></p>
<pre><code>.box.one6 {
    align-items: flex-end;
}
</code></pre><p>1.8 黑点在最后一行居中<br><img src="/images/css/flex/11.png" alt="flex"></p>
<pre><code>.box.one7 {
    align-items: flex-end;
    justify-content: center;
}
</code></pre><p>1.9 黑点在最后一行最后一个<br><img src="/images/css/flex/12.png" alt="flex"></p>
<pre><code>.box.one8 {
    align-items: flex-end;
    justify-content: flex-end;
}
</code></pre><h6 id="2-双项目"><a href="#2-双项目" class="headerlink" title="2. 双项目"></a>2. 双项目</h6><p>html模版为</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>2.1 第一行左右布局<br><img src="/images/css/flex/13.png" alt="flex"></p>
<pre><code>.box.two1 {
    justify-content: space-between;
}
</code></pre><p>2.2 左侧上下布局<br><img src="/images/css/flex/14.png" alt="flex"></p>
<pre><code>.box.two2 {
      flex-direction: column;
      justify-content: space-between;
  }
</code></pre><p>2.3 居中上下布局<br><img src="/images/css/flex/15.png" alt="flex"></p>
<pre><code>.box.two3 {
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
}
</code></pre><p>2.4 右侧上下布局<br><img src="/images/css/flex/16.png" alt="flex"></p>
<pre><code>.box.two4 {
    flex-direction: column;
    justify-content: space-between;
    align-items: flex-end;
}
</code></pre><p>2.5 左上右下布局<br><img src="/images/css/flex/17.png" alt="flex"></p>
<pre><code>.box.two3 {
    justify-content: space-between;
}
.two3 .item:last-child {
    align-self: flex-end;
}
</code></pre><h6 id="3-三项目"><a href="#3-三项目" class="headerlink" title="3. 三项目"></a>3. 三项目</h6><p>html模版</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>3.1 一左二中三右布局<br><img src="/images/css/flex/18.png" alt="flex"></p>
<pre><code>.three1 {
    flex-direction: column;
}
.three1 .item:nth-child(2) {
    align-self: center;
}
.three1 .item:nth-child(3) {
    align-self: flex-end;
}
</code></pre><p>3.2 一右二中三左布局<br><img src="/images/css/flex/19.png" alt="flex"></p>
<pre><code>.three2 {
    flex-direction: column;
    align-items: flex-end;
}
.three2 .item:nth-child(2) {
    align-self: center;
}
.three2 .item:nth-child(3) {
    align-self: flex-start;
}
</code></pre><h6 id="4-四项目"><a href="#4-四项目" class="headerlink" title="4. 四项目"></a>4. 四项目</h6><p>4.1 第一排铺满，最后一排右布局<br>模版：</p>
<pre><code>&lt;div class=&quot;box four1&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>图：<br><img src="/images/css/flex/20.png" alt="flex"><br>样式：</p>
<pre><code>.four1 {
    flex-wrap: wrap;
    justify-content: flex-end;
    align-content: space-between;
}
</code></pre><p>4.2 上下左右四个角布局<br>html模版:</p>
<pre><code>&lt;div class=&quot;box four2&quot;&gt;
    &lt;div class=&quot;column&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;column&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>图：<br><img src="/images/css/flex/21.png" alt="flex"></p>
<p>样式：</p>
<pre><code>.four2 {
    flex-direction: column;
    justify-content: space-between;
}
.column {
    display: flex;
    justify-content: space-between;
}
</code></pre><h6 id="5-五项目"><a href="#5-五项目" class="headerlink" title="5. 五项目"></a>5. 五项目</h6><p>html模版：</p>
<pre><code>&lt;div class=&quot;box four2&quot;&gt;
    &lt;div class=&quot;column&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;column mid&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;column&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>图：<br><img src="/images/css/flex/22.png" alt="flex"></p>
<p>样式：</p>
<pre><code>.four2 {
    flex-direction: column;
    justify-content: space-between;
}
.column {
    display: flex;
    justify-content: space-between;
}
.mid {
    align-items: center;
    justify-content: center;
}
</code></pre><h6 id="6-六项目"><a href="#6-六项目" class="headerlink" title="6. 六项目"></a>6. 六项目</h6><p>html模版：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>6.1 上三下三布局<br><img src="/images/css/flex/23.png" alt="flex"></p>
<pre><code>.s1 {
    flex-wrap: wrap;
    align-content: space-between;
}
</code></pre><p>6.2 左三右三布局<br><img src="/images/css/flex/24.png" alt="flex"></p>
<pre><code>.s2 {
    flex-direction: column;
    flex-wrap: wrap;
    align-content: space-between;
}
</code></pre><h6 id="7-九项目"><a href="#7-九项目" class="headerlink" title="7 九项目"></a>7 九项目</h6><p>html模版：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>图：<br><img src="/images/css/flex/25.png" alt="flex"></p>
<p>样式：</p>
<pre><code>.n1 {
    flex-wrap: wrap;
}
</code></pre><h6 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用flex布局很多情况下节省很多工作量，方便简单好用。特别手机端用的很多。</p>
<h6 id="六、完整代码没上传GitHub，这儿随便写了下符在下面。"><a href="#六、完整代码没上传GitHub，这儿随便写了下符在下面。" class="headerlink" title="六、完整代码没上传GitHub，这儿随便写了下符在下面。"></a>六、完整代码没上传GitHub，这儿随便写了下符在下面。</h6><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        body {
            background: black;
        }

        .con {
            margin: 50px;
            display: flex;
            flex-direction: row;
        }

        .box {
            width: 60px;
            height: 60px;
            border: 1px solid white;
            background: white;
            border-radius: 5px;
            display: flex;
            margin: 10px;
        }
        .item {
            width: 10px;
            height: 10px;
            background: black;
            border-radius: 5px;
            margin: 5px;
        }

        .box.one1 {
            flex-direction: row;
            justify-content: center;
        }
        .box.one2 {
            flex-direction: row;
            justify-content: flex-end;
        }
        .box.one3 {
            flex-direction: row;
            align-items: center;
        }
        .box.one4 {
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }
        .box.one5 {
            align-items: center;
            justify-content: flex-end;
        }
        .box.one6 {
            align-items: flex-end;
        }
        .box.one7 {
            align-items: flex-end;
            justify-content: center;
        }
        .box.one8 {
            align-items: flex-end;
            justify-content: flex-end;
        }

        .box.two1 {
            justify-content: space-between;
        }
        .box.two2 {
            flex-direction: column;
            justify-content: space-between;
        }
        .box.two21 {
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        .box.two22 {
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-end;
        }
        .box .item1 {
            align-self: center;
        }
        .box.two3 {
            justify-content: space-between;
        }
        .two3 .item:last-child {
            align-self: flex-end;
        }

        .t1 {
            flex-direction: column;
        }
        .t1 .item:nth-child(2) {
            align-self: center;
        }
        .t1 .item:nth-child(3) {
            align-self: flex-end;
        }
        .t2 {
            flex-direction: column;
            align-items: flex-end;
        }
        .t2 .item:nth-child(2) {
            align-self: center;
        }
        .t2 .item:nth-child(3) {
            align-self: flex-start;
        }

        .f1 {
            flex-wrap: wrap;
            justify-content: flex-end;
            align-content: space-between;
        }

        .f2 {
            flex-direction: column;
            justify-content: space-between;
        }
        .column {
            display: flex;
            justify-content: space-between;
        }
        .mid {
            align-items: center;
            justify-content: center;
        }

        .s1 {
            flex-wrap: wrap;
            align-content: space-between;
        }
        .s2 {
            flex-direction: column;
            flex-wrap: wrap;
            align-content: space-between;
        }

    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;!-- 1 --&gt;
    &lt;div class=&quot;con&quot;&gt;
        &lt;div class=&quot;box&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;box one1&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one2&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one3&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one4&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one5&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one6&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one7&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;box one8&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;!-- 2 --&gt;
&lt;div class=&quot;con&quot;&gt;
    &lt;div class=&quot;box&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box two1&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box two2&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box two21&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box two22&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item item1&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box two3&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 3 --&gt;
&lt;div class=&quot;con&quot;&gt;
    &lt;div class=&quot;box t1&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box t2&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 4、5 --&gt;
&lt;div class=&quot;con&quot;&gt;
    &lt;div class=&quot;box f1&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box f2&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box f2&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column mid&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 6、9 --&gt;
&lt;div class=&quot;con&quot;&gt;
    &lt;div class=&quot;box s1&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box s2&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;box s1&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的节点</title>
    <url>/2021/04/16/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、反转链表（简单）"><a href="#一、反转链表（简单）" class="headerlink" title="一、反转链表（简单）"></a>一、反转链表（简单）</h2><blockquote>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>来源： <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Leecode - 反转链表</a></p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>链表是一种线性表，它不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。每个元素实际上是一个单独的对象，所有的对象都是通过每个元素中的引用字段链接在一起。考虑需要反转链表，那么只需要将当前指针的 next 指向上一个节点，上一个节点的 next 指向当前节点，便可以反转链表。对于头结点来说，没有上一个节点，需要我们定义一个空节点来表示上一个节点，分析图如下：<br><img src="/images/算法/reverse1.jpg" alt="reverseList"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义上一个节点，用于承载链表头结点反转使用</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 定义当前节点指向头结点</span></span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历链表</span></span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="comment">// 储存下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    <span class="comment">// 当前节点的next指向上一个节点</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    <span class="comment">// 上一个节点指向当前节点</span></span><br><span class="line">    pre = cur;</span><br><span class="line">    <span class="comment">// 继续下一个节点遍历</span></span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回反转后的链表</span></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、反转链表-两两交换链表中的节点（中等难度）"><a href="#二、反转链表-两两交换链表中的节点（中等难度）" class="headerlink" title="二、反转链表 - 两两交换链表中的节点（中等难度）"></a>二、反转链表 - 两两交换链表中的节点（中等难度）</h2><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<p><img src="/images/算法/swap_ex3.jpeg" alt="swap_ex1"></p>
<blockquote>
<p>示例 1：</p>
<p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head = []<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1]<br>输出：[1]</p>
<p>来源： <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Leecode - 两两交换链表中的节点</a></p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>从上图中知道，需要两两交换节点，并要求在原链表上操作，分解步骤如下：</p>
<ol>
<li>创建一个空节点 dummy，dummy.next 指向 head，用于 head 节点改变后能找到头结点；</li>
<li>遍历链表，一组节点的交换需要三个步骤:<blockquote>
<p>当前节点的 next 节点指向下一个节点的 next；<br>下一个节点的 next 指向当前节点；<br>上一个节点 pre 的 next 指向下一个节点；</p>
</blockquote>
</li>
<li>更新 pre 节点指针为 head，即目前的第二个节点；</li>
<li>指针推进，准备交换下一组节点；<br>……..</li>
<li>返回 dummy.next，即交换后的头结点；</li>
</ol>
<p>如图：<br><img src="/images/算法/swap_ex2.jpg" alt="节点两两交换分析图"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建个dummy节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy的next指向head节点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="comment">// 初始化上一个为dummy</span></span><br><span class="line">  <span class="keyword">let</span> pre = dummy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历head节点</span></span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">    <span class="comment">// 缓存head的下一个节点</span></span><br><span class="line">    <span class="keyword">const</span> next = head.next;</span><br><span class="line">    <span class="comment">// 第一步，将当前节点指向下下个节点</span></span><br><span class="line">    head.next = next.next;</span><br><span class="line">    <span class="comment">// 第二步，下个节点的next指向当前节点</span></span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="comment">// 第三步，上一个节点next指向下一个节点</span></span><br><span class="line">    pre.next = next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步上个节点指向每组的第二个节点</span></span><br><span class="line">    pre = head;</span><br><span class="line">    <span class="comment">// 下一次循环</span></span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回dummy的next节点，即新节点的头结点</span></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="反转链表-3-局部反转-中等难度"><a href="#反转链表-3-局部反转-中等难度" class="headerlink" title="反转链表 3 - 局部反转 (中等难度)"></a>反转链表 3 - 局部反转 (中等难度)</h2><blockquote>
<p>给你单链表的头指针 head 和两个整数  left 和 right ，其中  left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
</blockquote>
<p><img src="/images/算法/swap_ex1.jpeg" alt="swap_ex1"></p>
<blockquote>
<p>示例 1：</p>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p>
<p>来源： <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Leecode - 局部反转链表</a></p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>从 left 位置开始到 right 位置局部反转，需要定位反转区域的上一个节点<code>leftHead</code>，第一个节点为<code>pre</code>, 第二个节点为<code>cur</code>, 第三个节点为<code>next</code>，根据反转链表的思路执行反转进行反转即可，具体步骤：</p>
<ol>
<li>初始化<code>pre、cur、leftHead</code>，定义<code>dummy</code>空节点，dummy.next 指向<code>head</code>，初始化<code>p</code>节点指向 dummy;</li>
<li>从第一个节点开始遍历到 left 的上一个节点，定义为<code>leftHead</code>，设置<code>start</code>指向 leftHead，即开始反转的第一个节点，pre 指向 start，cur 指向 pre.next;</li>
<li>遍历从 left 开始到 right 结束，反转这个区域的节点；</li>
<li>将 leftHead.next 指向 pre，即反转后的最后一个节点；</li>
<li>将 start.next 指向 cur，cur 为 right 的下一个节点；</li>
<li>返回 dummy.next;</li>
</ol>
<p>如图：<br><img src="/images/算法/reverse3.jpg" alt="reverse3"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果没有节点，或者只有一个节点，原样返回</span></span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化当前节点、上一个节点、反转链表左侧第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> cur, pre, leftHead;</span><br><span class="line">  <span class="comment">// 定义dummy节点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// dummy的next指向头结点</span></span><br><span class="line">  dummy.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存dummy节点，复制给p</span></span><br><span class="line">  <span class="keyword">let</span> p = dummy;</span><br><span class="line">  <span class="comment">// 链表p走到左侧开始反转节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义反转链表前结点</span></span><br><span class="line">  leftHead = p;</span><br><span class="line">  <span class="comment">// 定义第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> start = leftHead.next;</span><br><span class="line">  <span class="comment">// 定义上一个节点</span></span><br><span class="line">  pre = start;</span><br><span class="line">  <span class="comment">// 初始化当前节点</span></span><br><span class="line">  cur = pre.next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从left到right反转设置</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将反转链表的上一个指向反转后的第一个</span></span><br><span class="line">  leftHead.next = pre;</span><br><span class="line">  <span class="comment">// 反转后的最后一个节点指向后面未反转的链表</span></span><br><span class="line">  start.next = cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加</title>
    <url>/2021/04/17/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="两数之和-1（简单难度）"><a href="#两数之和-1（简单难度）" class="headerlink" title="两数之和 1（简单难度）"></a>两数之和 1（简单难度）</h2><blockquote>
<p>给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 的那   两个   整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>数组中任意两个数的值等于目标值，则返回他们的下标：第一反应的解法，双层遍历，暴力破解法，时间复杂度为 O(n^2)。考虑到能不能优化呢？能否 O(n)就能解出呢？<br>首先考虑个问题，目标值 <code>target - 当前值 nums[i] = nums[j]</code>，如存在这样的组合，只要计算出 <code>i，j</code> 就行了，只要保证 nums[i]在数据结构中存在唯一性就行了，有什么数据结构是唯一性的呢？js 中对象的 key 值就是唯一性，那么只需要将 nums[i]存为对象 key 的值，对应的索引存为对象的 value 值，每次判断 <code>target - nums[i]</code> 是否是对象的 key 值，如果是则前面出现过，将对应的索引返回即可。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  缓存nums长度</span></span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// 初始化map</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历nums</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前对象 目标值 - 当前值 已经存入对象中，说明前面已经出现过，返回对应下标</span></span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(target - nums[i]), i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储当前值为集合key，下标为集合值</span></span><br><span class="line">    map.set(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表两数相加-2（中等难度）"><a href="#链表两数相加-2（中等难度）" class="headerlink" title="链表两数相加 2（中等难度）"></a>链表两数相加 2（中等难度）</h2><p>给你两个   非空 的链表，表示两个非负的整数。它们每位数字都是按照   逆序   的方式存储的，并且每个节点只能存储   一位   数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0  开头。</p>
<p><img src="/images/算法/addtwonumber1.jpeg" alt="两数之和"></p>
<blockquote>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br>示例 2：</p>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]<br>示例 3：</p>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>从题目中两个链表中的数字都是按照<code>逆序</code>排列的，所以只要对两个链表重头到尾遍历，对应节点两两相加，大于 9 进一位即可。步骤如下：</p>
<ol>
<li>创建一个 dummy 的头结点链表，用于存储相加后的值；</li>
<li>遍历两个链表 l1 || l2，取每一次遍历的节点值相加，如果大于 9，进一位，并将个位数的值存储起来；</li>
<li>继续遍历下一个的 l1 || l2 节点，取出他们的值进行第二步操作，直到遍历结束；</li>
<li>遍历完成后，进位数还存在，则将进位数放到链表最末尾；</li>
</ol>
<p><img src="/images/算法/l1_l2.jpg" alt="两数之和"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新建头结点</span></span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// 当前节点指向头结点</span></span><br><span class="line">  <span class="keyword">let</span> cur = dummy;</span><br><span class="line">  <span class="comment">// 初始化进位数，默认为0</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历两个链表</span></span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="comment">// 获取链表1的值，若不存在设为0</span></span><br><span class="line">    <span class="keyword">let</span> val1 = l1 ? l1.val : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取链表2的值，若不存在设为0</span></span><br><span class="line">    <span class="keyword">let</span> val2 = l2 ? l2.val : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 求出当前两个链表之和，包括进位数</span></span><br><span class="line">    <span class="keyword">const</span> sum = val1 + val2 + carry;</span><br><span class="line">    <span class="comment">// 如果sum小于10，不进位，当前节点直线新建的节点，否则进位，当前节点指向十位数</span></span><br><span class="line">    cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 判断是否进位，进位值为1， 否则为0</span></span><br><span class="line">    carry = sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表1存在，则链表1向下遍历</span></span><br><span class="line">    l1 &amp;&amp; (l1 = l1.next);</span><br><span class="line">    <span class="comment">// 链表2存在，则链表2向下遍历</span></span><br><span class="line">    l2 &amp;&amp; (l2 = l2.next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储和的链表继续向下走</span></span><br><span class="line">    cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还存在进位数，则需要创建一个节点存储该进位数</span></span><br><span class="line">  <span class="keyword">if</span> (carry === <span class="number">1</span>) &#123;</span><br><span class="line">    cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="两数相加-3（中等难度）"><a href="#两数相加-3（中等难度）" class="headerlink" title="两数相加 3（中等难度）"></a>两数相加 3（中等难度）</h2><blockquote>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>相比上一题区别是上一题是逆序的链表，本题最高位为链表的开始位置，即两个正序列表相加。结合上一题的思路，我们只需要将链表先反转后，再根据上一题思路来。考虑到进阶提示:<code>不能对列表的节点进行翻转</code>，那么该如何处理呢？<br>可以借鉴栈来存储链表每个元素，然后在出栈，就可以从最后一个节点值开始相加。然后进行翻转即可，步骤如下：</p>
<ol>
<li>从头结点分别遍历 l1、l2，将每次遍历的节点值分别入栈 stack1、stack2；</li>
<li>初始化头结点<code>cur</code>、上一个节点<code>pre</code>、进位数<code>carry</code>;</li>
<li>同时遍历 stack1、stack2 且进位数不为 0；</li>
<li>对 stack1 出栈，栈为空设置值为 0，否则为出栈的值： val1 = stack1.pop() || 0；对 stack2 出栈，栈为空设置值为 0，否则为出栈的值： val2 = stack1.pop() || 0；</li>
<li>求和： sum = val1 + val2 + carry， 如果 sum &lt; 10，不进位 carry = 0, 否则进位 carry = 1;</li>
<li>创建新节点，节点值为 sum % 10;</li>
<li>反转设置：当前节点的下一个节点指向 pre: cur.next = pre; pre 的下一个节点指向当前节点：pre.next = cur;</li>
<li>继续遍历下一个节点：cur = cur.next， 重复遍历完 stack1，stack2 且 carry = 0;</li>
<li>返回反转后的节点：pre；</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> *  1、数字最高位在开始位置，故想要数字相加的话，需要翻转链表，题目要求不能翻转链表，</span></span><br><span class="line"><span class="comment"> *      故可以考虑先存放于栈中，每次出栈就是从最低位开始。</span></span><br><span class="line"><span class="comment"> *  2、相加的数大于9，不进位，否则进一位。</span></span><br><span class="line"><span class="comment"> *  3、依次遍历到结束。得到的链表是逆序的，需要翻转。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放l1的链表值的栈</span></span><br><span class="line">  <span class="keyword">const</span> stack1 = [];</span><br><span class="line">  <span class="comment">// 存放l2的链表值的栈</span></span><br><span class="line">  <span class="keyword">const</span> stack2 = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历链表1，将每个节点的值存放到stack1中，分别入栈</span></span><br><span class="line">  <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">    stack1.push(l1.val);</span><br><span class="line">    l1 = l1.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历链表2，将每个节点的值存放到stack2中，分别入栈</span></span><br><span class="line">  <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">    stack2.push(l2.val);</span><br><span class="line">    l2 = l2.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义头结点</span></span><br><span class="line">  <span class="keyword">let</span> cur = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="comment">// 定义上一个节点</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 定义进位</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历栈stack1、stack2，分别出栈</span></span><br><span class="line">  <span class="keyword">while</span> (stack1.length || stack2.length || carry !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 栈1不为空，获取出栈值，否则值为0</span></span><br><span class="line">    <span class="keyword">const</span> val1 = stack1.length ? stack1.pop() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 栈2不为空，获取出栈值，否则值为0</span></span><br><span class="line">    <span class="keyword">const</span> val2 = stack2.length ? stack2.pop() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 求和，值1 + 值2 + 进位数</span></span><br><span class="line">    <span class="keyword">const</span> sum = val1 + val2 + carry;</span><br><span class="line">    <span class="comment">// 定义节点</span></span><br><span class="line">    cur = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 计算进位数</span></span><br><span class="line">    carry = sum &lt; <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="comment">// 当前节点的下一个节点指向pre</span></span><br><span class="line">    cur.next = pre;</span><br><span class="line">    <span class="comment">// 上一个节点指向当前节点</span></span><br><span class="line">    pre = cur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续下一个节点</span></span><br><span class="line">    cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回反转后的链表</span></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>你想知道的Promise都在这里</title>
    <url>/2021/05/15/js/%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84promise%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Promise 是一种异步解决方法，它的出现解决了使用回调函数处理异步逻辑，造成回调地狱的问题，本文主要从 Promise 的基本用法、Promise A+、手写 Promise 角度出发，深度分析 Promise。</p>
<h2 id="一、Promise-基本用法"><a href="#一、Promise-基本用法" class="headerlink" title="一、Promise 基本用法"></a>一、Promise 基本用法</h2><h3 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h3><p>Promise 对象有两种状态：</p>
<ol>
<li>对象的状态不受外部影响。Promise 有三种状态：<code>pending（进行中）、fulfilled（已成功）、rejected（已失败）</code>，只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>状态一旦改变，就不会再变，其他任何时候都能得到这个结果。Promise 的状态改变只有两种可能：<code>pending -&gt; fulfilled</code>或<code>pending -&gt; rejected</code></li>
</ol>
<h3 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h3><ol>
<li>Promise 是一个构造函数，需要使用<code>new</code>关键字生成实例；</li>
<li>Promise 中有一个 executor 立即执行函数，每次 new 时，会立即执行（后面手写会具体讲解）；</li>
<li>executor 中有两个参数<code>resolve</code>和<code>reject</code>方法，resolve 表示成功的回调，reject 表示失败的回调；</li>
<li>Promise.prototype.then()：前面 resolve 和 reject 执行后，then 方法会接收传入的参数，then 方法的第一个参数<code>onFulfilled</code>表示执行 resolve 成功时的回调，then 方法的第二个参数<code>onRejected</code>表示执行 reject 失败时的回调，两个回调函数都是可选的;</li>
<li>Promise.prototype.catch()方法：是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数;</li>
<li>Promise.prototype.finally()方法：不管 Promise 对象的状态如何，最终都会执行此方法；</li>
<li>Promise.all()：用于将多个 Promise 实例包装成新的 Promise 实例，如：const p = Promise.all([p1, p2, p3]);当 p1、p2、p3 的状态都编程 fulfilled 时，p 状态才编程 fulfilled，此时 p1、p2、p3 返回的结果组成一个数组，传递给 p 的回调函数。如果其中一个状态是 rejected，则被 reject 的实例返回；</li>
<li>Promise.race()方法：同 Promise.all()方法，将多个 Promise 实例组装成一个新的 Promise 实例，但是只要其中有任意一个实例状态改变，那么率先改变的 Promise 实例的返回值，就是返回的回调函数；</li>
<li>Promise.allSettled()方法：接收一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只有等所有参数都返回结果，不管状态是 fulfilled 还是 rejected，包装实例才结束；</li>
<li>Promise.any()方法：接收一组 Promise 实例作为参数，包装成一个新的 Promise 实例，只要有一个实例的状态变为 fulfilled，包装实例就会变为 fulfilled；如果所有参数实例都是 rejected，包装函数的状态会变成 rejected；</li>
<li>Promise.reslove()方法：<br>a. 如果参数是一个 Promise 实例，Promise 不做任何修改原样返回；<br>b. 如果参数是<code>thenable</code>对象，即有<code>then</code>方法的对象，那么这个对象会转为 Promise 对象，立即执行 then 方法；<br>c. 如果不具有 then 方法或者不是对象，Promise.resolve()方法会返回一个新的 Promise 对象，并将参数返回给回调；<br>d. 如果不带参数，直接返回一个 resolved 状态的 Promise 对象；</li>
<li>Promise.reject()方法：返回一个新的 Promise 对象，该状态为 rejected；</li>
</ol>
<p>上面只简单介绍了 Promise 中存在的方法，并没有具体实例介绍每种方法是如何使用的，不了解的可以看<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师的 Promise</a>。在第一次学习 Promise 时，就有很多疑问：Promise 的底层是如何实现异步操作的？Promise.then()方法是一个微任务，是如何实现的？如果不了解<code>eventLoop</code>的同学自行网上查询，有很多相关文章。</p>
<h2 id="二、Promise-A"><a href="#二、Promise-A" class="headerlink" title="二、Promise A+"></a>二、Promise A+</h2><p>手写 Promise 之前，先讲讲什么是 Promise A+，Promise 的底层实现规范，是依赖于<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a>来实现的，英文好的建议阅读原版，下面是我翻译后的，如果不正确，请不宁指出。</p>
<hr>
<p>一个 promise 表示异步操作的最终结果。与 promise 进行交互的主要方式是通过其 then 方法，该方法注册回调以接收 promise 的最终值或无法实现 promise 的原因。</p>
<p>该规范详细介绍了该 then 方法的行为，提供了可互操作的基础，所有 Promises / A +兼容的 Promise 实现都可以依靠该基础来提供。因此，该规范应被认为是非常稳定的。尽管 Promises / A +组织有时会通过向后兼容的微小更改来修订此规范，以解决新发现的极端情况，但只有在仔细考虑，讨论和测试之后，我们才会集成大型或向后不兼容的更改。</p>
<p>从历史上看，Promises / A +阐明了早期 Promises / A 提案的行为条款，将其扩展为涵盖实际行为，并省略了未指定或有问题的部分。</p>
<p>最后，核心的 Promises / A +规范不处理如何创建，履行或拒绝诺言，而是选择专注于提供一种可互操作的 then 方法。伴随规范中的未来工作可能涉及这些主题。</p>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1. “promise”中有一个 then 方法，该方法时符合这个规范行为的函数或对象；<br>1.2. “thenable”定义 then 方法的对象和函数<br>1.3. “value”表示任何合法的 JavaScript 值（包括 undefined，ableable 或 promise）<br>1.4. “exception”表示使用 throw 抛出的值<br>1.5. “reason”表示 promise 被拒绝的原因</p>
<h3 id="2-必要条件"><a href="#2-必要条件" class="headerlink" title="2. 必要条件"></a>2. 必要条件</h3><h5 id="2-1-Promise-状态"><a href="#2-1-Promise-状态" class="headerlink" title="2.1 Promise 状态"></a>2.1 Promise 状态</h5><p>promise 必须是这三个状态中的一种：pending（进行中）、fulfilled（已成功）、rejected（已失败）</p>
<p>2.1.1. 当一个 promise 处于 pending 的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1.1. 它可能变为 fulfilled 状态或者 rejected 状态。</p>
<p>2.1.2. 当一个 promise 处于 fulfilled 状态的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2.1. 一定不能转换为任何其它状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2.2. 必须有一个不能改变的值</p>
<p>2.1.3. 当一个 promise 处于 rejected 状态的时候：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.3.1. 一定不能转换为任何其它状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.3.2. 必须有一个不能改变的原因</p>
<p>在这里，”一定不能改变”意味着不变的身份(例如 ===)，但是并不意味着深度不可变性。</p>
<h5 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 then 方法"></a>2.2 then 方法</h5><p>Promise 必须提供一个 then 方法来访问最终的值或原因。</p>
<p>Promise 的 then 方法接受俩个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<p>2.2.1 onFulfilled 和 onRejected 都是可选的参数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1.1. 如果 onFulfilled 不是一个函数，它必须被忽略<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1.2. 如果 onRejected 不是一个函数，它必须被忽略</p>
<p>2.2.2. 如果 onFulfilled 是一个函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2.1. 它必须在 promise 的状态为 fulfilled 后调用，promise 的值作为它的第一个参数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2.2. 它一定不能在 promise 的状态变为 fulfilled 前调用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2.3. 它一定不能被调用多次。</p>
<p>2.2.3. 如果 onRejected 是一个函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1. 它必须在 promise 变为 rejected 之后调用，用 promise 的结果 reason 作为它的第一个参数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2. 它一定不能在 promise 状态变为 rejected 前调用。</p>
<p>2.2.4. 在执行上下文栈中只包含平台代码之前，onFulfilled 或 onRejected 一定不能被调用 [3.1]</p>
<p>2.2.5. onFulfilled 和 onRejected 必须被作为函数调用(没有 this 值) [3.2]</p>
<p>2.2.6. 同一个 promise 上，then 方法可以被调用多次<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.6.1. 如果 promise 是 fulfilled，所有相应的 onFulfilled 回调必须按照他们原始调用 then 的顺序执行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.6.2. 如果 promise 是 rejected，所有相应的 onRejected 回调必须按照他们原始调用 then 的顺序执行</p>
<p>2.2.7. then 必须返回一个 promise [3.3]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.7.1. 如果 onFulfilled 或 onRjected 返回一个值 x，运行 promise 解决程序<a href="promise2,x">[Resolve]</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.7.2. 如果 onFulfilled 或 onRejected 抛出一个异常 e，promise2 必须用 e 作为原因被拒绝<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.7.3. 如果 onFulfilled 不是一个函数并且 promise1 被解决，promise2 必须用与 promise1 相同的值被解决<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.7.4. 如果 onRejected 不是一个函数并且 promise1 被拒绝，promise2 必须用与 promise1 相同的原因被拒绝</p>
<h5 id="2-3-Promise-解决程序"><a href="#2-3-Promise-解决程序" class="headerlink" title="2.3 Promise 解决程序"></a>2.3 Promise 解决程序</h5><p>promise 解决程序是一个抽象操作，它以一个 promise 和一个值作为输入，我们将其表示为<a href="promise, x">[Resolve]</a>。如果 x 是一个 thenable，它尝试让 promise 采用 x 的状态，并假设 x 的行为至少在某种程度上类似于 promise。否则，它将会用值 x 解决 promise。</p>
<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露一个遵循 Promise/A+协议的 then 方法即可。这同时也使遵循 Promise/A+规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>要运行<a href="promise, x">[Resolve]</a>，需要执行如下步骤：</p>
<p>2.3.1. 如果 promise 和 x 引用同一个对象，用一个 TypeError 作为原因来拒绝 promise</p>
<p>2.3.2. 如果 x 是一个 promise，采用它的状态：[3.4]</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2.1. 如果 x 是 pending，promise 必须保持等 pending 状态，直到 x 变为 fulfilled 或 rejected 状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2.2. 如果 x 是 fulfilled，用相同的 value 解决 promise<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2.3. 如果 x 是 rejected，用相同的 reason 拒绝 promise</p>
<p>2.3.3. 否则，如果 x 是一个对象或函数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.1. 让 then 成为 x.then。[3.5]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.2. 如果检索属性 x.then 导致抛出了一个异常 e，用 e 作为原因拒绝 promise<br>&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.3. 如果 then 是一个函数，用 x 作为 this 调用它。then 方法的参数为俩个回调函数，第一个参数叫做 resolvePromise，第二个参数叫做 rejectPromise：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.3.1. 如果 resolvePromise 用一个值 y 调用，运行<a href="promise, y">[Resolve]</a>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.3.2. 如果 rejectPromise 用一个原因 r 调用，用 r 拒绝 promise。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.3.3. 如果 resolvePromise 和 rejectPromise 都被调用，或者对同一个参数进行多次调用，那么第一次调用优先，以后的调用都会被忽略。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.3.4. 如果调用 then 抛出了一个异常 e<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.4.1. 如果 resolvePromise 或 rejectPromise 已经被调用，忽略它<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.4.2. 否则，用 e 作为原因拒绝 promise<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3.4. 如果 then 不是一个函数，用 x 解决 promise</p>
<p>2.3.4. 如果 x 不是一个对象或函数，用 x 解决 promise</p>
<p>如果 promise 用一个循环的 thenable 链解决，由于<a href="promise, thenalbe">[Resolve]</a>的递归特性，最终将导致<a href="promise, thenable">[Resolve]</a>被再次调用，遵循上面的算法将会导致无限递归。规范中并没有强制要求处理这种情况，但也鼓励实现者检测这样的递归是否存在，并且用一个信息丰富的 TypeError 作为原因拒绝 promise。[3.6]</p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p>3.1. 这里“平台代码”意味着引擎、环境以及 promise 的实现代码。在实践中，这需要确保 onFulfilled 和 onRejected 异步地执行，并且应该在 then 方法被调用的那一轮事件循环之后用新的执行栈执行。这可以用如 setTimeout 或 setImmediate 这样的“宏任务”机制实现，或者用如 MutationObserver 或 process.nextTick 这样的“微任务”机制实现。由于 promise 的实现被考虑为“平台代码”，因此在自身处理程序被调用时可能已经包含一个任务调度队列。<br>3.2. 严格模式下，它们中的 this 将会是 undefined；在非严格模式，this 将会是全局对象。<br>3.3. 假如实现满足所有需求，可以允许 promise2 === promise1。每一个实现都应该记录是否能够产生 promise2 === promise1 以及什么情况下会出现 promise2 === promise1。<br>3.4. 通常，只有 x 来自于当前实现，才知道它是一个真正的 promise。这条规则允许那些特例实现采用符合已知要求的 Promise 的状态。<br>3.5. 这个程序首先存储 x.then 的引用，之后测试那个引用，然后再调用那个引用，这样避免了多次访问 x.then 属性。此类预防措施对于确保访问者属性的一致性非常重要，因为访问者属性的值可能在俩次检索之间发生变化。<br>3.6. 实现不应该在 thenable 链的深度上做任意限制，并且假设超过那个任意限制将会无限递归。只有真正的循环才应该引发一个 TypeError；如果遇到一个无限循环的 thenable，永远执行递归是正确的行为。</p>
<hr>
<h2 id="三、模拟-Promise-实现"><a href="#三、模拟-Promise-实现" class="headerlink" title="三、模拟 Promise 实现"></a>三、模拟 Promise 实现</h2><p>Promise.then()方法是异步任务，在 Promise A+中提到，可以使用 setTimeout 或 setImmediate 这样的“宏任务”机制实现，也可以使用 MutationObserver 或 process.nextTick 这样的“微任务”机制实现。Promise 的实现是基于 V8 引擎的，promise.then()是微任务，故下面的模拟代码使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener">queueMicrotask()</a>创建微任务。</p>
<p>看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 成功的回调</span></span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  <span class="comment">// 失败的回调</span></span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="comment">// onFulfilled函数</span></span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="number">1</span>, value), <span class="comment">// 1 success</span></span><br><span class="line">  <span class="comment">// onRejected函数</span></span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="number">2</span>, reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 success</span></span><br></pre></td></tr></table></figure>
<p>根据例子的结果和 Promise A+的规则分析得出以下结果：</p>
<blockquote>
<ol>
<li>Promise 有三种状态：<code>pending（进行中）、fulfilled（已成功）、rejected（已失败）</code>；</li>
<li>Promise 的状态改变只有两种可能：<code>pending -&gt; fulfilled</code>或<code>pending -&gt; rejected</code>；</li>
<li>Promise 有一个立即执行函数 executor 函数，有两个回调为 resolve、reject 函数，用来更改状态；</li>
<li>then 方法用来访问最终的成功的值或失败的原因, 如果状态是成功调用成功的回调，如果是失败，调用失败的回调；</li>
</ol>
</blockquote>
<h3 id="1-创建-MyPromise-类，resolve-和-reject-方法"><a href="#1-创建-MyPromise-类，resolve-和-reject-方法" class="headerlink" title="1. 创建 MyPromise 类，resolve 和 reject 方法"></a>1. 创建 MyPromise 类，resolve 和 reject 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// 立即执行函数</span></span><br><span class="line">    executor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  这里使用箭头函数的原因：</span></span><br><span class="line"><span class="comment">    1、函数中的this指向的是全局window，严格模式指向undefined</span></span><br><span class="line"><span class="comment">    2、new运算符会创建一个空的JavaScript对象作为this的上下文</span></span><br><span class="line"><span class="comment">    3、箭头函数不会创建执行上下文，this是指向MyPromise的实例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 更改成功后的状态</span></span><br><span class="line">  resolve = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="comment">// 更改失败后的状态</span></span><br><span class="line">  reject = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-MyPromise-状态管理"><a href="#2-MyPromise-状态管理" class="headerlink" title="2. MyPromise 状态管理"></a>2. MyPromise 状态管理</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PEDDING = <span class="string">"pedding"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"fulfilled"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化存储状态，默认值为pending</span></span><br><span class="line">  status = PEDDING;</span><br><span class="line">  <span class="comment">// 初始化resolve参数value</span></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 初始化reject参数reason</span></span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="comment">// 立即执行函数</span></span><br><span class="line">    executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    这里使用箭头函数的原因：</span></span><br><span class="line"><span class="comment">      1、函数中的this指向的是全局window，严格模式指向undefined</span></span><br><span class="line"><span class="comment">      2、new运算符会创建一个空的JavaScript对象作为this的上下文</span></span><br><span class="line"><span class="comment">      3、箭头函数不会创建执行上下文，this是指向MyPromise的实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">// 更改成功后的状态</span></span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态为pending，则设置为fulfilled状态，并缓存值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="comment">// 改变状态为fulfilled</span></span><br><span class="line">      <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="comment">// 缓存成功之后的值</span></span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 更改失败后的状态</span></span><br><span class="line">  reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态为pending，则设置为rejected状态，并缓存失败原因</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">      <span class="comment">// 改变状态为rejected</span></span><br><span class="line">      <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">      <span class="comment">// 缓存失败原因</span></span><br><span class="line">      <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-then-方法实现"><a href="#3-then-方法实现" class="headerlink" title="3. then 方法实现"></a>3. then 方法实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">      <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value),</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: resolve success</span></span><br></pre></td></tr></table></figure>
<p>结果正确，继续。</p>
<h3 id="4-Promise-中的异步逻辑和-then-方法多次调用"><a href="#4-Promise-中的异步逻辑和-then-方法多次调用" class="headerlink" title="4. Promise 中的异步逻辑和 then 方法多次调用"></a>4. Promise 中的异步逻辑和 then 方法多次调用</h3><p>上面的实现没有异步逻辑处理，如果加上异步逻辑会出现什么情况呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    reject(<span class="string">"error"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value),</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: 什么也没有！</span></span><br></pre></td></tr></table></figure>
<p>为什么会出现这样的情况？前面提到过 eventLoop，js 在编译的时候会创建执行上下文（全局、函数和 eval 执行上下文），执行上下文存放在执行上下文栈中（执行栈），es6 的 let 和 const 的块级作用域存放在词法环境中。而异步任务存放在任务队列中，这里使用了 setTimeout 是宏任务，需要等待调用栈中的任务执行完成，才执行宏任务中的代码。</p>
<p>分析上面代码：</p>
<blockquote>
<p>主线程立即执行代码，setTimeout 是宏任务，存放到宏任务队列，then 方法在执行栈中立即执行，这时 status 的状态为 pending，结束。再从宏任务中拿出 resolve 执行，后面就没有代码了，故上面都不会返回。</p>
</blockquote>
<p>那么如何解决呢？可以借助队列（先进先出）的数据结构来缓存数据，当执行 then 方法时，状态还是 pending 状态，则缓存待执行的回调，当调用 resolve 或 reject 方法时，判断缓存中是否有回调缓存，如果有就执行。如下：</p>
<h6 id="MyPromise-中新增两个数组"><a href="#MyPromise-中新增两个数组" class="headerlink" title="MyPromise 中新增两个数组"></a>MyPromise 中新增两个数组</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化成功回调缓存</span></span><br><span class="line">onFulfilledCallback = [];</span><br><span class="line"><span class="comment">//初始化失败回调缓存</span></span><br><span class="line">onRejectedCallback = [];</span><br></pre></td></tr></table></figure>
<h6 id="then-方法回调函数存入数组"><a href="#then-方法回调函数存入数组" class="headerlink" title="then 方法回调函数存入数组"></a>then 方法回调函数存入数组</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then方法</span></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">    <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">    <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">    onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存当前待执行的成功回调，入成功队列</span></span><br><span class="line">    <span class="keyword">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">    <span class="comment">// 缓存当前待执行失败的回调，入失败队列</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="resolve-和-reject-中执行缓存的回调"><a href="#resolve-和-reject-中执行缓存的回调" class="headerlink" title="resolve 和 reject 中执行缓存的回调"></a>resolve 和 reject 中执行缓存的回调</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更改成功后的状态</span></span><br><span class="line">resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果状态为pending，则设置为fulfilled状态，并缓存值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">    <span class="comment">// 改变状态为fulfilled</span></span><br><span class="line">    <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">    <span class="comment">// 缓存成功之后的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="comment">// 若缓存回调中存在值，则执行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.onFulfilledCallback.length) &#123;</span><br><span class="line">      <span class="comment">// 出队列执行回调</span></span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallback.shift()(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 更改失败后的状态</span></span><br><span class="line">reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果状态为pending，则设置为rejected状态，并缓存失败原因</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PEDDING) &#123;</span><br><span class="line">    <span class="comment">// 改变状态为rejected</span></span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="comment">// 缓存失败原因</span></span><br><span class="line">    <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    <span class="comment">// 若缓存回调中存在值，则执行</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.onRejectedCallback.length) &#123;</span><br><span class="line">      <span class="comment">// 出队列执行回调</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallback.shift()(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写个例子执行下上面的程序，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    reject(<span class="string">"error"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="number">1</span>, <span class="string">"resolve"</span>),</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="number">2</span>, <span class="string">"reject"</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="number">3</span>, <span class="string">"resolve"</span>),</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="number">4</span>, <span class="string">"reject"</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1 resolve</span></span><br><span class="line"><span class="comment">// 2 resolve</span></span><br></pre></td></tr></table></figure>
<p>是预期结果，到这里已经解决了异步调用问题，then 方法多次调用问题。</p>
<h3 id="5-then-链式调用"><a href="#5-then-链式调用" class="headerlink" title="5. then 链式调用"></a>5. then 链式调用</h3><blockquote>
<p>then 方法链式调用需要返回一个 Promise，上一个 then 中返回一个 Promise 对象，下一个 then 接受上一个 resolve 的参数。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       resolve();</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">     promise</span><br><span class="line">       .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="number">1</span>, <span class="string">"resolve"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">           resolve(<span class="string">"success"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;)</span><br><span class="line">       .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>, value));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 输出: 1 "resolve"</span></span><br><span class="line">     <span class="comment">// test copy.html:99 Uncaught TypeError: Cannot read property 'then' of undefined</span></span><br></pre></td></tr></table></figure>
<p>报错是因为，then 方法中并没有返回值，在 Promise A+中要求 Promise 的 then 方法返回一个 Promise 对象，故改造下代码。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">        <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">this</span>.resolvePromise(x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">        <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        <span class="keyword">this</span>.resolvePromise(x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前待执行的成功回调，入成功队列</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">        <span class="comment">// 缓存当前待执行失败的回调，入失败队列</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  resolvePromise = <span class="function">(<span class="params">x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再执行下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>, <span class="string">"resolve"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">"success"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>, value));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1 "resolve"</span></span><br><span class="line"><span class="comment">// 2 "success"</span></span><br></pre></td></tr></table></figure>
<p>链式调用已经实现，如果 then 方法返回的是自己，会出现什么情况呢，先看下 Promise 本身自己调用自己是什么情况？<br>抛出错误，如下：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">TypeError</span>: Chaining cycle detected <span class="keyword">for</span> promise <span class="comment">#&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure>
<p>看下上面封装的代码执行自己返回自己的情况，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 test copy.html:108 Uncaught (in promise) ReferenceError: Cannot access 'p1' before initialization</span></span><br></pre></td></tr></table></figure>
<p>那么只需要判断如果返回的是 then 本身，则抛出错误即可，代码改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">        <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">        <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">        <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存当前待执行的成功回调，入成功队列</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">        <span class="comment">// 缓存当前待执行失败的回调，入失败队列</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  resolvePromise = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行看看</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) ReferenceError: Cannot <span class="keyword">access</span> <span class="symbol">'p1</span>' before initialization</span><br></pre></td></tr></table></figure>
<p>竟然报错了，从结果上看，<code>初始化前无法访问p1</code>，即必须等 promise2 执行完成。根据 eventLoop 的知识，这里需要创建一个异步任务去等待 promise2 执行，前面已经使用过的<code>queueMircotask</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      <span class="comment">// === 新增部分 ===</span></span><br><span class="line">      queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">        <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">      <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">      <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">      <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 缓存当前待执行的成功回调，入成功队列</span></span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallback.push(onFulfilled);</span><br><span class="line">      <span class="comment">// 缓存当前待执行失败的回调，入失败队列</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallback.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行结果，及是我们期望的类型错误抛出，如下：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">TypeError</span>: Chaining cycle detected <span class="keyword">for</span> promise <span class="comment">#&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-捕捉错误"><a href="#6-捕捉错误" class="headerlink" title="6. 捕捉错误"></a>6. 捕捉错误</h3><p>在代码的的执行器阶段，then 方法处理成功失败的阶段，都需要捕捉错误。</p>
<h6 id="捕捉执行器错误"><a href="#捕捉执行器错误" class="headerlink" title="捕捉执行器错误"></a>捕捉执行器错误</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 立即执行函数</span></span><br><span class="line">    executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">this</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子执行看下结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"ececutor error!"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = promise.then(</span><br><span class="line">  (value) =&gt; <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value),</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason.message)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出  reject ececutor error!</span></span><br></pre></td></tr></table></figure>
<h6 id="then-方法中错误捕捉和代码完善"><a href="#then-方法中错误捕捉和代码完善" class="headerlink" title="then 方法中错误捕捉和代码完善"></a>then 方法中错误捕捉和代码完善</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then = <span class="function">(<span class="params">onFulfilled, onRejected</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulfilledMircotask = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用成功回调，把成功的值返回</span></span><br><span class="line">          <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">          <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">const</span> rejectedMircotask = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用失败回调，把失败原因返回</span></span><br><span class="line">          <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">          <span class="keyword">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="comment">// 如果是成功状态，执行成功回调，如果是失败状态，执行失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">      fulfilledMircotask();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">      rejectedMircotask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 缓存当前待执行的成功回调，入成功队列</span></span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallback.push(fulfilledMircotask);</span><br><span class="line">      <span class="comment">// 缓存当前待执行失败的回调，入失败队列</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallback.push(rejectedMircotask);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子执行看下结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = promise</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value);</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"then throw error!"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">"resolve"</span>),</span><br><span class="line">    (reason) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason.message);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// resolve success</span></span><br><span class="line"><span class="comment">// reject then throw error!</span></span><br></pre></td></tr></table></figure>
<p>成功打印出了 then 中的错误信息。</p>
<h3 id="7-then-中的参数作为可选参数"><a href="#7-then-中的参数作为可选参数" class="headerlink" title="7. then 中的参数作为可选参数"></a>7. then 中的参数作为可选参数</h3><p>在执行 then 方法是，传入的 onFulfilled、onRejected 函数默认传入的，也可以是可选的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="comment">// 如果传入的不是函数，则转化为函数</span></span><br><span class="line">  <span class="keyword">const</span> onFulfilledReal =</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(onFulfilled) === <span class="string">"[object Function]"</span></span><br><span class="line">      ? onFulfilled</span><br><span class="line">      : <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">  <span class="keyword">const</span> onRejectedReal =</span><br><span class="line">    <span class="built_in">Object</span>.prototype.toString.call(onRejected) === <span class="string">"[object Function]"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子测试一下，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = promise</span><br><span class="line">  .then()</span><br><span class="line">  .then()</span><br><span class="line">  .then(</span><br><span class="line">    (value) =&gt; <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value),</span><br><span class="line">    (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出  resolve success</span></span><br></pre></td></tr></table></figure>
<p>预期结果。</p>
<h3 id="8-完善-promiseResolve-方法"><a href="#8-完善-promiseResolve-方法" class="headerlink" title="8. 完善 promiseResolve 方法"></a>8. 完善 promiseResolve 方法</h3><p>根据 Promise A+规范中 2.3.3 之后的规范，晚上 promiseResolve 的代码</p>
<blockquote>
<ol>
<li>x 是一个函数或对象，then = x.then;</li>
<li>若 x.then 执行失败，则抛出异常，return reject(error);</li>
<li>若 then 是一个函数，用 x 作为 this 调用它，有两个参数：resolvePromise 和 then.call(x, (y) =&gt; resolvePromise(promise, y, resolve, reject), (r) =&gt; reject(r));</li>
<li>其他则根据 Promise A+抛出错误即可</li>
</ol>
</blockquote>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolvePromise = <span class="function">(<span class="params">promise, x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 promise 和 x 指向同一对象，即自己调用自己，则抛出类型错误</span></span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"The promise and the return value are the same"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> then;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 把 x.then 赋值给 then</span></span><br><span class="line">      then = x.then;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">      <span class="keyword">return</span> reject(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 then 是函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 将 x 作为函数的作用域 this 调用</span></span><br><span class="line">      <span class="comment">// 传递两个回调函数作为参数，resolvePromise 和 rejectPromise</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="comment">// 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span></span><br><span class="line">          (y) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果 resolvePromise 和 rejectPromise 均被调用，</span></span><br><span class="line">            <span class="comment">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">            <span class="comment">// 实现这条需要前面加一个变量called</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            resolvePromise(promise, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">          (r) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 如果调用 then 方法抛出了异常 e：</span></span><br><span class="line">        <span class="comment">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则以 e 为据因拒绝 promise</span></span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-resolve-和-reject-静态方法实现"><a href="#9-resolve-和-reject-静态方法实现" class="headerlink" title="9. resolve 和 reject 静态方法实现"></a>9. resolve 和 reject 静态方法实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve 静态方法</span></span><br><span class="line"><span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">  <span class="comment">// 如果是当前对象的实例，原样返回</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新new一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 静态方法</span></span><br><span class="line"><span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">  <span class="comment">// 如果是当前对象的实例，原样返回</span></span><br><span class="line">  <span class="keyword">if</span> (reason <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">return</span> reason;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新new一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPromise.resolve(<span class="string">"success"</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value); <span class="comment">// resolve success</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyPromise.reject(<span class="string">"error"</span>).then(</span><br><span class="line">  (value) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) =&gt; <span class="built_in">console</span>.log(<span class="string">"reject"</span>, reason) <span class="comment">// reject error</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// resolve success</span></span><br><span class="line"><span class="comment">// reject error</span></span><br></pre></td></tr></table></figure>
<h3 id="10-catch-方法实现"><a href="#10-catch-方法实现" class="headerlink" title="10. catch 方法实现"></a>10. catch 方法实现</h3><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch 实现</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = promise</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"resolve"</span>, value))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch"</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出  catch error</span></span><br></pre></td></tr></table></figure>
<h3 id="11-finally-代码实现"><a href="#11-finally-代码实现" class="headerlink" title="11. finally 代码实现"></a>11. finally 代码实现</h3><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// finally 无论成功或失败都会执行</span></span><br><span class="line"><span class="keyword">finally</span>(fn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    <span class="comment">// 成功状态执行</span></span><br><span class="line">    (value) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> MyPromise.resolve(fn()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 失败状态执行</span></span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> MyPromise.resolve(fn()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-all-方法实现"><a href="#12-all-方法实现" class="headerlink" title="12. all 方法实现"></a>12. all 方法实现</h3><p>all 方法返回一个 promise 对象，要求传入的数组中所有的参数状态都变为 fulfilled，则返回 fulfilled 状态，如果有一个 rejected 状态，则返回 rejected 状态。</p>
<p>分析如下：</p>
<blockquote>
<ol>
<li>返回一个 Promise：all = (promiseList) =&gt; new MyPromise(// … );</li>
<li>传入数组中所有的状态都变为 fulfilled 状态，则返回 fulfilled 状态，则需要遍历传入的数组，通过 MyPromise.resolve(promiseList[i]).then((value) =&gt; {}, (reason) =&gt; {})来判断。</li>
<li>当执行 Promise.resolve()成功的个数等于传入数组的长度，则返回结果。</li>
</ol>
</blockquote>
<p>代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> all(promiseList) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取传入数组的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = promiseList.length;</span><br><span class="line">    <span class="comment">// 初始化结果数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="comment">// 初始化计数器</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历传入的方法</span></span><br><span class="line">    promiseList.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">      MyPromise.resolve(promise).then(</span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          count++;</span><br><span class="line">          result[index] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (count === len) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) =&gt; reject(reason)</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-race-方法实现"><a href="#13-race-方法实现" class="headerlink" title="13. race 方法实现"></a>13. race 方法实现</h3><p>race 方法，返回一个 promise 对象，要求传入的参数不管成功还是失败，第一个改变的状态就是返回的状态。</p>
<p>分析：</p>
<blockquote>
<ol>
<li>返回一个 promise， race = (promiseList) =&gt; new MyPromise(() =&gt; {});</li>
<li>遍历传入的 promiseList，获取传入的每一个 promiseItem， 这里使用 for 遍历，因为只要有返回就中断循环；</li>
<li>无论成功或失败，第一个状态改变，则返回，MyPromise.resolve(promiseList[i]).then((value) =&gt; {<br>return reslove(value)<br>}, (reason) =&gt; {<br>return reject(reason);<br>})</li>
</ol>
</blockquote>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race 静态方法，谁先完成，就返回谁</span></span><br><span class="line"><span class="keyword">static</span> race(promiseList) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取传入数组的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = promiseList.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        MyPromise.resolve(promiseList[i]).then(</span><br><span class="line">          (value) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          (reason) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-allSettled-方法实现"><a href="#14-allSettled-方法实现" class="headerlink" title="14. allSettled 方法实现"></a>14. allSettled 方法实现</h3><p>Promise.allSettled()方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
<p>一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，未决议的 Promise 将被异步完成。那时，所返回的 promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。</p>
<p>对于每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。</p>
<p>分析：</p>
<blockquote>
<ol>
<li>返回一个 promise 对象， allSettled = (promiseList) =&gt; new MyPromise(() =&gt; {});</li>
<li>遍历 promiseList，并记录无论成功或失败的个数之和；</li>
<li>当所有的个数之和等于数组的长度，则返回。</li>
</ol>
</blockquote>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allSettled静态实现</span></span><br><span class="line"><span class="keyword">static</span> allSettled(promiseList) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存数组长度</span></span><br><span class="line">    <span class="keyword">const</span> len = promiseList.length;</span><br><span class="line">    <span class="comment">// 初始化结果数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="comment">// 初始化计数器</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入的是空数组，则返回空数组</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历传入数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        MyPromise.resolve(promiseList[i]).then(</span><br><span class="line">          (value) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 成功则计数器加1</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 存储成功状态，设置状态为fulfilled</span></span><br><span class="line">            result[i] = &#123;</span><br><span class="line">              status: <span class="string">"fulfilled"</span>,</span><br><span class="line">              value,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果传入的数组长度和技术器相等，则通过resolve返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (len === count) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (reason) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 失败，计数器加1</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 存储失败状态的结果，设置返回状态为rejected</span></span><br><span class="line">            result[i] = &#123;</span><br><span class="line">              status: <span class="string">"rejected"</span>,</span><br><span class="line">              reason,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果传入的数组长度和技术器相等，则通过resolve返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (len === count) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，一个自定义版的 Promise 已经完成，接下来使用<code>promises-aplus-tests</code>安装测试一下</p>
<h2 id="四、Promise-A-测试"><a href="#四、Promise-A-测试" class="headerlink" title="四、Promise A+ 测试"></a>四、Promise A+ 测试</h2><p>手写实现的 Promise 需要遵守 Promise A+规范，需要<code>promises-aplus-tests</code>来测试是否完全遵守 Promise A+规范。</p>
<h4 id="1-安装-promises-aplus-tests"><a href="#1-安装-promises-aplus-tests" class="headerlink" title="1. 安装 promises-aplus-tests"></a>1. 安装 promises-aplus-tests</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add promises-aplus-tests -D 或 npm install promises-aplus-tests -D</span><br></pre></td></tr></table></figure>
<h4 id="2-加入测试代码-deferred"><a href="#2-加入测试代码-deferred" class="headerlink" title="2. 加入测试代码 deferred"></a>2. 加入测试代码 deferred</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPromise.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">  result.promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    result.resolve = resolve;</span><br><span class="line">    result.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-配置-package-json-文件"><a href="#3-配置-package-json-文件" class="headerlink" title="3. 配置 package.json 文件"></a>3. 配置 package.json 文件</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-promise"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"my-promise.js"</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"promises-aplus-tests my-promise"</span> <span class="comment">// 配置命令</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"promises-aplus-tests"</span>: <span class="string">"^2.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-启动测试"><a href="#4-启动测试" class="headerlink" title="4. 启动测试"></a>4. 启动测试</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn test &amp; npm <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/images/js/myPromiseTest.gif" alt="MyPromise Test"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文从 Promise 的基本用法，Promise A+、手写实现 Promise、测试手写代码等角度分析了 Promise 底层实现方式。Promise 是异步方案的一种解决方法，但是如果链路较长，也会存在代码难以维护的情况，针对这样的情况，es6 后提出了 Generator 函数、Async await 的异步解决方案。若需了解，请关注后续文章。</p>
<p>长文不易，点赞支持一下就是对笔者最好的鼓励。</p>
<p>手写 Promise 已放到仓库<a href="https://github.com/chicAboo/myPromise" target="_blank" rel="noopener">MyPromise</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<ol>
<li><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰老师 ES6 的 Promise</a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a></li>
<li><a href="https://juejin.cn/post/6844903625769091079" target="_blank" rel="noopener">BAT 前端经典面试问题：史上最最最详细的手写 Promise 教程</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
